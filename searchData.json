[{"title":"非越狱手机植入动态库","url":"/2018/12/12/20181212/","content":"\n### 目标：\n1.修改爱奇艺App\n2.将这个修改过的App重签名\n3.安装在未越狱手机上\n### 准备：\n1.越狱手机和一台未越狱手机\n2.Mac电脑\n\n<!-- more -->\n\n#### 1. 修改爱奇艺App\n* 步骤1. 在越狱手机AppStore上下载爱奇艺App.\n* 步骤2. 在越狱手机上找到爱奇艺的AppID, 这里可以通过[MJAppTools](https://github.com/CoderMJLee/MJAppTools), 快速查询(这里也可以通过[Cycript](http://www.cycript.org/)来找到)，代码如下：\n\n```\n// 终端\nMJAppTools -l\n\n// 显示\n【爱奇艺】 <com.qiyi.iphone>\n/private/var/mobile/Containers/Bundle/Application/C8575DD1-889E-4E70-AF66-4E4CC920F6AC/iQiYiPhoneVideo.app\n/private/var/mobile/Containers/Data/Application/CD9280DD-C4C3-4CF2-84E0-5F484596E211\n  arm_64 加壳\n```\n\n* 步骤3. 创建一个名叫**libReveal.plist**的文件，将刚才的AppIDcopy进plist中，如下:\n\n```\n{\n\tFilter = {\n\t\tBundles = (\n\t\t\t\"com.qiyi.iphone\"\n\t\t);\n\t};\n}\n```\n\n* 步骤4. 打开Reveal\n\n```\n//1. 找到\nHelpe -> Show Reveal Library in Finder -> iOS Library\n//2. 重命名\nRevealServer -> libReveal\n```\n\n* 步骤5. 将libReveal.plist 和 libReveal.dylib 同时上传到越狱机器以下路径（可以通过iFunBox）：\n\n```\nDevice/Library/MobileSubStrate/DynamicLibraries\n```\n\n* 步骤6. 此时打开Reveal和越狱机器上的爱奇艺App，结合[Cycript](http://www.cycript.org/)或者[mjcript](https://github.com/CoderMJLee/mjcript), 可以找到你想要修改的东西所属的类，这里如果我们需要修改播放的广告。\n\n* 步骤7. 通过Reveal可以找到启动页面相关的广告View是`QYStartADView`, 它所属的类是`QYStartADViewController`\n\n* 步骤8. 通过[Clutch](https://github.com/KJCracks/Clutch)或[dumpdecrypted](https://github.com/stefanesser/dumpdecrypted)脱壳，得到脱壳后的新App。我用的是Clutch,代码如下:\n\n```\n// 罗列手机上可以脱壳的App\nClutch -i\n// 脱壳指定App\nClutch -d x(爱奇异的前面的数字)\n// 返回\ncom.qiyi.iphone contains watchOS 2 compatible application. It's not possible to dump watchOS 2 apps with Clutch 2.0.4 at this moment.\nZipping iQiYiPhoneVideo.app\nASLR slide: 0x100004000\nDumping <QiYiUserNotification> (arm64)\nPatched cryptid (64bit segment)\nASLR slide: 0x1000dc000\nDumping <QYToday> (arm64)\nPatched cryptid (64bit segment)\nASLR slide: 0x1000bc000\nDumping <QYSiriShortCuts> (arm64)\nPatched cryptid (64bit segment)\nWriting new checksum\nWriting new checksum\nWriting new checksum\nobjc[4015]: Class ZipArchive is implemented in both /var/tmp/clutch/1C8BA028-6FC4-4975-B4E9-644D2935FB55/clutch and /private/var/mobile/Containers/Bundle/Application/C8575DD1-889E-4E70-AF66-4E4CC920F6AC/iQiYiPhoneVideo.app/Frameworks/QYUniversalFramework.framework/QYUniversalFramework. One of the two will be used. Which one is undefined.\nDumping <QYUniversalFramework> arm64\nASLR slide: 0x100054000\nDumping <iQiYiPhoneVideo> (arm64)\nPatched cryptid (64bit segment)\nSuccessfully dumped framework QYUniversalFramework!\nChild exited with status 0\nZipping QYUniversalFramework.framework\nZipping QYSiriShortCuts.appex\nZipping QYToday.appex\nZipping QiYiUserNotification.appex\nWriting new checksum\nDONE: /private/var/mobile/Documents/Dumped/com.qiyi.iphone-iOS9.0-(Clutch-2.0.4).ipa\nFinished dumping com.qiyi.iphone in 38.5 seconds\n```\n* 步骤9. copy出来已经脱壳了的App,然后找到包中的Mach-O文件，最后运用[class-dump](http://stevenygard.com/projects/class-dump/), 执行以下的命令得到相应的头文件：\n\n```\nclass-dump -H -o iqiHeaders iQiYiPhoneVideo.app\n```\n\n* 步骤10. 通过查看类`QYStartADView`的相关头文件，代码如下:\n\n```\n//\n//     Generated by class-dump 3.5 (64 bit).\n//\n//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.\n//\n\n#import \"UIView.h\"\n\n#import \"QYStartADViewControllerDelegate.h\"\n#import \"QYStartAdPlayerControllerDelegate.h\"\n\n@class AdsClient, CupidAd, NSString, NSTimer, QYStartADViewController, QYStartAdPlayerController, QYWebContainer, UILabel, UIWindow;\n\n@interface QYStartADView : UIView <QYStartAdPlayerControllerDelegate, QYStartADViewControllerDelegate>\n{\n    UIWindow *_window;\n    NSTimer *_adTimer;\n    float _iAdTime;\n    _Bool _shouldRun;\n    long long _addedTime;\n    float _adShowTime;\n    _Bool _isFullScreenAd;\n    int _type;\n    id <QYPhoneStartADViewDelegate> _delegate;\n    UILabel *_secords;\n    long long _duration;\n    double _logoBackHeight;\n    double _needToCut;\n    UIView *_adImageView;\n    QYWebContainer *_webView;\n    AdsClient *_adClient;\n    CupidAd *_adCupid;\n    QYStartAdPlayerController *_player;\n    QYStartADViewController *_startAdViewController;\n}\n\n@property(retain, nonatomic) QYStartADViewController *startAdViewController; // @synthesize startAdViewController=_startAdViewController;\n@property(retain, nonatomic) QYStartAdPlayerController *player; // @synthesize player=_player;\n@property(nonatomic) int type; // @synthesize type=_type;\n@property(retain, nonatomic) CupidAd *adCupid; // @synthesize adCupid=_adCupid;\n@property(retain, nonatomic) AdsClient *adClient; // @synthesize adClient=_adClient;\n@property(retain, nonatomic) QYWebContainer *webView; // @synthesize webView=_webView;\n@property(retain, nonatomic) UIView *adImageView; // @synthesize adImageView=_adImageView;\n@property(nonatomic) double needToCut; // @synthesize needToCut=_needToCut;\n@property(nonatomic) double logoBackHeight; // @synthesize logoBackHeight=_logoBackHeight;\n@property(nonatomic) long long duration; // @synthesize duration=_duration;\n@property(retain, nonatomic) UILabel *secords; // @synthesize secords=_secords;\n@property(nonatomic) _Bool isFullScreenAd; // @synthesize isFullScreenAd=_isFullScreenAd;\n@property(nonatomic) __weak id <QYPhoneStartADViewDelegate> delegate; // @synthesize delegate=_delegate;\n- (void).cxx_destruct;\n- (id)imageFromImage:(id)arg1 inRect:(struct CGRect)arg2;\n- (void)playToEnd;\n- (void)playError;\n- (void)h5WillJumpToPage;\n- (void)userInteractWithHtml;\n- (void)sendH5AdClickPingback;\n- (void)finishDisplayHtml;\n- (void)keyboardDidHide;\n- (id)labelWithFrame:(struct CGRect)arg1 backgroundColor:(id)arg2 textColor:(id)arg3 font:(id)arg4 text:(id)arg5 textAlignment:(long long)arg6;\n- (id)imageViewWithFrame:(struct CGRect)arg1 image:(id)arg2;\n- (void)delegateCallStartADViewDidEnd;\n- (void)showEnds;\n- (void)updateTime;\n- (void)updateUI:(id)arg1;\n- (void)finishAdShowForHtml;\n- (void)prepareForEndAd;\n- (void)secondChange;\n- (void)timerStart;\n- (void)showAdDetail;\n- (void)skipAd;\n- (id)createTouchScreenPromptView;\n- (id)createViewWithType:(int)arg1 withURL:(id)arg2;\n- (void)addBottomView;\n- (void)addTimeBg;\n- (id)initWithType:(int)arg1 withURL:(id)arg2 withDur:(long long)arg3 withAdData:(id)arg4 withADCupid:(id)arg5;\n- (void)dealloc;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n```\n\n> 这里的代码量不是很多，我们看到这个`- (id)initWithType:(int)arg1 withURL:(id)arg2 withDur:(long long)arg3 withAdData:(id)arg4 withADCupid:(id)arg5;`有可能就是一个实例化方法，我们可以覆写这个方法来达到取消启动广告的效果（这里只是一个猜测！）\n\n\n* 步骤11. 下面通过编写[theos](https://github.com/theos/theos/wiki/Installation-iOS), 来覆写这个实例化方法，假设你已经按照github上的教程安装好了，此时就可以按照下面的流程开始：\n* xxx.xm的相关语法的编写可以参考[语法](http://iphonedevwiki.net/index.php/Logos#File_Extensions_for_Logos)\n\n```\n/*------1-------*/\n// 在合适的位置执行，下面的命令\nnic.pl\n\n/*------2-------*/\n// 终端的显示\nNIC 2.0 - New Instance Creator\n------------------------------\n  [1.] iphone/activator_event\n  [2.] iphone/application_modern\n  [3.] iphone/application_swift\n  [4.] iphone/cydget\n  [5.] iphone/flipswitch_switch\n  [6.] iphone/framework\n  [7.] iphone/ios7_notification_center_widget\n  [8.] iphone/library\n  [9.] iphone/notification_center_widget\n  [10.] iphone/preference_bundle_modern\n  [11.] iphone/tool\n  [12.] iphone/tool_swift\n  [13.] iphone/tweak\n  [14.] iphone/xpc_service\nChoose a Template (required):\n\n/*------3-------*/\n// 这里我们选择13，然后回车, 这里唯一需要注意的就是这个AppID,必须要填写爱奇艺的AppID, 其他的可以随便填写、或者直接回车\nChoose a Template (required): 13\nProject Name (required): ghiqyTest\nPackage Name [com.yourcompany.ghiqytest]: com.ghcoder.ghiqyTest\nAuthor/Maintainer Name [龚欢]:\n[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.qiyi.iphone\n[iphone/tweak] List of applications to terminate upon installation (space-separated, '-' for none) [SpringBoard]:\nInstantiating iphone/tweak in ghiqytest/...\nDone.\n\n/*------4-------*/\n// 创建完成之后，会发现自动创建了一个名叫ghiqytest的文件夹，里面存在四个文件，依次是:control(相关的配置信息)、ghiqyTest.plist(你需要修改的应用的AppID)、Makefile(配置文件)、Tweak.xm(需要修改的相关类)\n// 下面是我对Tweak.xm修改的内容如下：\n\n%hook QYStartADView\n\n- (id)initWithType:(int)arg1 withURL:(id)arg2 withDur:(long long)arg3 withAdData:(id)arg4 withADCupid:(id)arg5 {\n\treturn nil;\n}\n\n%end\n\n/*------5-------*/\n// ssh到越狱手机，并且要在Makefile的开头加上下面两行配置\nexport THEOS_DEVICE_IP=127.0.0.1\nexport THEOS_DEVICE_PORT=10010\n\n/*------6-------*/\n// 如果一切正常的话，执行完成之后，越狱机器就会自动重启了\nmake clean &&  make package && make install\n```\n\n#### 2. 将这个修改过的App重签名\n* 步骤1. 要完成这个重签名，我们需要有如下几个文件 \n\n1. 我们刚才编写的xxx.xm文件，其实刚才在我们重启之后，它就生成一个动态库文件，这个文件存放在越狱机的如下路径中：(Device->Library->MobileSubstrate->DynamicLibraries->ghiqyTest.dylib).\n2. 在越狱机器中加载这个动态库的Framework（CydiaSubstrate) [路径如下Device->Library->Frameworks->CydiaSubstrate.framework->CydiaSubstrate]\n3. 已经脱壳了的App\n4. xxx.mobileprovision文件，这个是需要一年99美金才可以，可以通过创建一个空的Xcode项目，编译之后在Target的App中找到这个xxx.mobileprovision文件（或者可以去apple.developer.com后台去下载）\n\n* 步骤2. 然后将上面提到三个文件*ghiqyTest.dylib*、*CydiaSubstrate*、*xxx.mobileprovision*一起拷贝到已经脱壳了的App中。\n\n* 步骤3. 在脱壳了的App中找到**info.plist**文件，把里面的**UISupportedDevices**这一栏统一删除掉。\n* 步骤4. 此时我们需要查看一些动态库，以及我们的Mach-O文件依赖的库是否配置正确:\n\n```\n/*------1-------*/\n// 查看爱奇艺Mach-O依赖的动态库\notool -L iQiYiPhoneVideo\n\n// 终端显示\n\t/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)\n\t/usr/lib/libresolv.9.dylib (compatibility version 1.0.0, current version 1.0.0)\n\t/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.20.0)\n\t/usr/lib/libxml2.2.dylib (compatibility version 10.0.0, current version 10.9.0)\n\t/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)\n\t/System/Library/Frameworks/AVFoundation.framework/AVFoundation (compatibility version 1.0.0, current version 2.0.0)\n\t/System/Library/Frameworks/Accelerate.framework/Accelerate (compatibility version 1.0.0, current version 4.0.0)\n\t/System/Library/Frameworks/AdSupport.framework/AdSupport (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/AssetsLibrary.framework/AssetsLibrary (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/CFNetwork.framework/CFNetwork (compatibility version 1.0.0, current version 974.2.1)\n\t/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1556.0.0)\n\t/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics (compatibility version 64.0.0, current version 1245.8.0)\n\t/System/Library/Frameworks/CoreLocation.framework/CoreLocation (compatibility version 1.0.0, current version 2245.4.104)\n\t/System/Library/Frameworks/CoreMotion.framework/CoreMotion (compatibility version 1.0.0, current version 2245.4.104)\n\t/System/Library/Frameworks/CoreTelephony.framework/CoreTelephony (compatibility version 1.0.0, current version 0.0.0)\n\t/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1556.0.0)\n\t/System/Library/Frameworks/ImageIO.framework/ImageIO (compatibility version 1.0.0, current version 0.0.0)\n\t/System/Library/Frameworks/MapKit.framework/MapKit (compatibility version 1.0.0, current version 14.0.0)\n\t/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices (compatibility version 1.0.0, current version 932.2.0)\n\t/System/Library/Frameworks/OpenAL.framework/OpenAL (compatibility version 1.0.0, current version 1.0.0)\n\t@rpath/QYUniversalFramework.framework/QYUniversalFramework (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/QuartzCore.framework/QuartzCore (compatibility version 1.2.0, current version 1.11.0)\n\t/System/Library/Frameworks/SceneKit.framework/SceneKit (compatibility version 1.0.0, current version 470.0.0)\n\t/System/Library/Frameworks/Security.framework/Security (compatibility version 1.0.0, current version 58286.202.3)\n\t/System/Library/Frameworks/StoreKit.framework/StoreKit (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration (compatibility version 1.0.0, current version 963.200.27)\n\t/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0)\n\t/System/Library/Frameworks/WebKit.framework/WebKit (compatibility version 1.0.0, current version 606.1.36)\n\t/System/Library/Frameworks/Intents.framework/Intents (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/IntentsUI.framework/IntentsUI (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/ReplayKit.framework/ReplayKit (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/UserNotifications.framework/UserNotifications (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/Speech.framework/Speech (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/CoreData.framework/CoreData (compatibility version 1.0.0, current version 865.0.0)\n\t/System/Library/Frameworks/EventKit.framework/EventKit (compatibility version 1.0.0, current version 100.0.0)\n\t/System/Library/Frameworks/WatchConnectivity.framework/WatchConnectivity (compatibility version 1.0.0, current version 175.0.0)\n\t/System/Library/Frameworks/PassKit.framework/PassKit (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/GLKit.framework/GLKit (compatibility version 1.0.0, current version 103.2.0)\n\t/System/Library/Frameworks/Photos.framework/Photos (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/CoreSpotlight.framework/CoreSpotlight (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication (compatibility version 1.0.0, current version 425.202.1)\n\t/System/Library/Frameworks/VideoToolbox.framework/VideoToolbox (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/AVKit.framework/AVKit (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/MessageUI.framework/MessageUI (compatibility version 1.0.0, current version 3445.100.35)\n\t/usr/lib/libiconv.2.dylib (compatibility version 7.0.0, current version 7.0.0)\n\t/System/Library/Frameworks/CoreText.framework/CoreText (compatibility version 1.0.0, current version 1.0.0)\n\t/usr/lib/libbz2.1.0.dylib (compatibility version 1.0.0, current version 1.0.5)\n\t/System/Library/Frameworks/CoreMedia.framework/CoreMedia (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/MediaPlayer.framework/MediaPlayer (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox (compatibility version 1.0.0, current version 492.0.0)\n\t/usr/lib/libicucore.A.dylib (compatibility version 1.0.0, current version 62.1.0)\n\t/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)\n\t/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)\n\t/System/Library/Frameworks/CoreImage.framework/CoreImage (compatibility version 1.0.0, current version 5.0.0)\n\t/System/Library/Frameworks/CoreML.framework/CoreML (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/CoreVideo.framework/CoreVideo (compatibility version 1.2.0, current version 1.5.0)\n\t/System/Library/Frameworks/JavaScriptCore.framework/JavaScriptCore (compatibility version 1.0.0, current version 606.1.36)\n\t/System/Library/Frameworks/OpenGLES.framework/OpenGLES (compatibility version 1.0.0, current version 1.0.0)\n\t/System/Library/Frameworks/SpriteKit.framework/SpriteKit (compatibility version 1.0.0, current version 2.0.0)\n\t\n/*------2-------*/\n// 需要把我们刚才创建的动态库链接进来，执行如下的命令\ninsert_dylib @executable_path/ghiqyTest.dylib iQiYiPhoneVideo iQiYiPhoneVideo --all-yes\n\n/*------3-------*/\n// 再次执行第一步的命令，会发现最下多了一行，就代表链接成功\n@executable_path/ghiqyTest.dylib (compatibility version 0.0.0, current version 0.0.0)\n\n/*------4-------*/\n// 此时我们再看一下ghiqyTest.dylib, 这个动态库有没有依赖的其他动态库\notool -L ghiqyTest.dylib\n\n// 终端显示\nghiqyTest.dylib (architecture arm64):\n\t/Library/MobileSubstrate/DynamicLibraries/ghiqyTest.dylib (compatibility version 0.0.0, current version 0.0.0)\n\t/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)\n\t/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1560.10.0)\n\t/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1560.10.0)\n\t/Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate (compatibility version 0.0.0, current version 0.0.0)\n\t/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)\n\t/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)\n\t\n/*------5-------*/\n// 这里需要修改/Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate路径，执行下面的命令就可以修改了\ninstall_name_tool -change /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate @loader_path/CydiaSubstrate ghiqyTest.dylib\n\n// 再次执行第四部：就会发现之前路径修改了\nghiqyTest.dylib (architecture arm64):\n\t/Library/MobileSubstrate/DynamicLibraries/ghiqyTest.dylib (compatibility version 0.0.0, current version 0.0.0)\n\t/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)\n\t/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1560.10.0)\n\t/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1560.10.0)\n\t@loader_path/CydiaSubstrate (compatibility version 0.0.0, current version 0.0.0)\n\t/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)\n\t/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)\n```\n\n\n* 步骤5. 我们要先找到我们签名证书的Identity,通过如下的命令可以找到\n\n```\nsecurity find-identity -v -p codesigning\n\n// 终端显示\n1) E797391C5ABBC9FB40EE04252C5679A6FEC1B351 \"iPhone Developer: ******\"\n2) EF3725BCB7AB3C3F12AFC9C3A82C16B84A2925EC \"iPhone Developer: *******\" (CSSMERR_TP_CERT_REVOKED)\n     2 valid identities found\n```\n\n* 步骤6. 开始签名：\n\n```\n➜  iQiYiPhoneVideo.app codesign -fs E797391C5ABBC9FB40EE04252C5679A6FEC1B351 ghiqyTest.dylib\nghiqyTest.dylib: replacing existing signature\n➜  iQiYiPhoneVideo.app codesign -fs E797391C5ABBC9FB40EE04252C5679A6FEC1B351 CydiaSubstrate\nCydiaSubstrate: replacing existing signature\n```\n\n* 步骤7. 最后我们对App整体签名，这里可以使用一个方便工具[iOSAppSinger](https://github.com/DanTheMan827/ios-app-signer)\n* 步骤7.1 也可以通过codesign，来完成对App的整体签名:\n\n```\n/*------1-------*/\n// 先从xxx.mobileprovision导出xxx.entitlements\nsecurity cms -D -i embedded.mobileprovision > temp.plist\n/usr/libexec/PlistBuddy -x -c 'Print:Entitlements' temp.plist > entitlements.plist\n\n/*------2-------*/\n// 生成完成之后的entitlements.plist，配合codeSign进行重签名\ncodesign -fs E797391C5ABBC9FB40EE04252C5679A6FEC1B351 --entitlements entitlements.plist xxx.app\n\n/*------3-------*/\n// 生成之后的xxx.app,放到Payload的文件夹中，然后进行压缩，然后再修改后缀名为.ipa\n```\n\n### 3. 安装在未越狱手机上\n* 直接通过iFunbox安装在非越狱机器上。\n\n","tags":["Object-C、加密"],"categories":["日志"]},{"title":"Swift语法备忘录","url":"/2018/11/03/20181103/","content":"\n## for(xx;xx;xx) 在swift中的写法：-> stride(from:to:by:) 从起始位置开始，每次增加或者减少确定的数量，到终点为止（不包含终点为止）\n\n> Returns a sequence from a starting value to, but not including, an end value, stepping by the specified amount.\n\n```\nfor index in stride(from: 10, to: 1, by: -1) {\n    print(\"index:\\(index)\")\n}\n\n<!-- more -->\n\n// 终端打印\nindex:10\nindex:9\nindex:8\nindex:7\nindex:6\nindex:5\nindex:4\nindex:3\nindex:2\n```\n\n## 将一个String用一个Character/String分隔： \n\n```\nlet stringArray = string.components(separatedBy: \"xx\")\n```\n\n\n## 找到某个subString，并且remove掉(ps: 这里只能找到一处并且删除掉)：\n\n```\nvar conetent = \"Hello World\"\nlet range = conetent.range(of: \" \")!\nlet index = conetent.distance(from: conetent.startIndex, to: range.lowerBound)\nconetent = String(conetent[..<conetent.index(conetent.startIndex, offsetBy: index)]) + String(conetent[conetent.index(conetent.startIndex, offsetBy: index+1)..<conetent.endIndex])\n```\n\n## 替换某个字符\n\n```\nlet conetent = \"Hello World\"\nlet newContent = conetent.replacingOccurrences(of: \" \", with: \"&\")\n```\n\n","tags":["Swift"],"categories":["日志"]},{"title":"每日一刷LeetCode算法","url":"/2018/02/23/20180223/","content":"\n* 这道题是LeetCode上的第2题，难度为Midea的一到题目，这是一道关于链表的题目，原题如下：\n\n> You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n```\n//Example\n\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\nExplanation: 342 + 465 = 807.\n```\n\n<!-- more -->\n\n1. 看到这道题目我主要的想法就是利用递归循环去遍历链表，并且将数值相加起来，如果超多数值9，相应位置上的数值减10，并且进一位\n2. 循环的遍历条件是Input中两个NodeList只要有一个存在值，就会继续递归。\n\n### 如何创建链表\n\n* 这个问题我想了一会，最好的创建方式，就是入参就是就是一个Array的数据结构，能够返回一个ListNode?值，函数如下：\n\n```\nfunc createList(_ values: [Int]) -> ListNode? {\n    var head: ListNode? = nil\n    var trail: ListNode? = nil\n    values.forEach { (value) in\n        let node = ListNode(value)\n        if head == nil {\n            head = node\n        } else {\n            trail!.next = node\n        }\n        trail = node\n    }\n    return head\n}\n```\n\n### 如何递归：\n* 这里开始第一次提交的时候，错误了，就是入参在`[5][5]`的时候，我的返回值是`[0]`,但是应该是`[0,1]`,是因为我的循环条件忽略了`resultNode`值的判断。\n\n```\nfunc addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    \n    var n1 = l1\n    var n2 = l2\n    \n    var resultNode: ListNode?\n    var arr: [Int] = []\n\n    while n1?.val != nil || n2?.val != nil || resultNode?.val != nil {\n        \n        var temp1: Int = 0\n        var temp2: Int = 0\n        if let v1 = n1?.val { temp1 = v1 }\n        if let v2 = n2?.val { temp2 = v2 }\n        \n        var last: Int = temp1 + temp2\n        if let resultNode = resultNode {\n            last += resultNode.val\n        }\n   \n        if (last > 9) {\n            resultNode = ListNode(last - 10)\n            resultNode?.next = ListNode(1)\n        } else {\n            resultNode = ListNode(last)\n        }\n        arr.append(resultNode!.val)\n        n1 = n1?.next\n        n2 = n2?.next\n        resultNode = resultNode?.next\n    }\n    \n    return createList(arr)\n}\n    \n```\n\n\n\n\n","tags":["Swift、Algorithm"],"categories":["日志"]},{"title":"自定义创建UIViewController Transition的动画效果","url":"/2017/12/20/20171221/","content":"\n### 这篇文章翻译自raywenderlich上的最新一篇文章，原链接这里[https://www.raywenderlich.com/167198/make-uiviewcontroller-transition-animation-like-ping-app]\n\n<!-- more -->\n\n* 作者的目标就是开发一个这样的切换样式，主要是实现的是**主页面**与 **menu页面**切换。\n\n![ping](https://koenig-media.raywenderlich.com/uploads/2017/10/BasicPushPop.gif)\n\n* 这个教程中主要是用**UIViewController transition animation**来完成这个动画效果，在这个教程中你会学到下面的知识点：\n\n1. **shape layer**\n2. **masking**\n3. **UIViewControllerAnimatedTransitioning protocol**\n4. **UIPercentDrivenInteractiveTransition class** \n5. ...\n\n### 初始项目\n\n* 项目的起始代码在这里[https://www.raywenderlich.com/170144/custom-uiviewcontroller-transitions-getting-started]\n\n### 开始\n\n#### 1.情况介绍\n\n1. 首先我们要知道我们要做的这个动画效果主要是用在这种情况下： 从一个VC切换到其他的VC时候所发生的动画[这里的VC指的就是ViewController]。\n2. 在iOS中，我们可以通过将一系列的VC统一都放入到一个`UINavigationController`中，通过遵循`UIViewControllerAnimatedTransitioning`的代理来实现自定义的动画。\n3. 其实这里你可以通过使用 `UIView`/`UIKit Dynamics` 或者是一些更底层`Core Animation API`来实现上述的动画效果，但是我们这里主要使用的是`UIView`和`Core Animation APIS`来实现这些效果。\n\n#### 2.表象\n\n1. 这里的动画是从右上角开始，慢慢扩大，直到整个界面完整出现。\n2. 消失VC上的文字是从左边消失的。\n3. 出现的VC上的文字是从右边显示出来\n\n#### 3.开始搞\n\n1. 运行开始的代码，就会发现，现在是最简单的样式，两个VC通过`UINavigationController`来`push`和`pop`。\n2. 在`UINavigationController`的实例变量有一个`UINavigationControllerDelegate`的协议，这个协议有四个方法，能够确定VC以及VC的滑动方向。\n\n* 新建一个`TransitionCoordinator`类的文件，继承自`NSObject`,并且遵循`UINavigationControllerDelegate`的协议：\n\n```\nclass TransitionCoordinator: NSObject, UINavigationControllerDelegate {}\n```\n\n* 然后给这个类里面添加一个协议方法，方法名如下, 目前先返回`nil`，后面会来补充进去：\n* 这个方法主要确定了进入的VC/离开的VC,并且这个函数返回的是一个`animation`的对象。\n* 当`navigationController`想要知道这个`animation`的对象的时候，而这里你却返回了一个`nil`的对象，这样的话，系统就会用默认的`push`、`pop`的动画效果。\n\n```\nfunc navigationController(_ navigationController: UINavigationController,\n                      animationControllerFor operation: UINavigationControllerOperation,\n                      from fromVC: UIViewController,\n                      to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {\nreturn nil\n}\n```\n\n--\n\n* 这里我们需要为`UINavigationController`的代理指定一下，回到`Appdelegate`的文件里面：\n\n```\n// 在文件的Appdelegate.swift的文件头上声明一个变量\nlet transitionCoordinator = TransitionCoordinator()\n\n// 并且在didFinishLaunch...\nnav.isNavigationBarHidden = true\nnav.delegate = transitionCoordinator\n```\n\n* 在`TransitionCoordinator`这个类里面，我们需要返回的是一个遵循`UIViewControllerAnimatedTransitioning`协议的对象。遵循这个协议也是一件很简单的事情。遵循这个协议需要确定两个函数：\n\n1. 第一个函数是：返回了动画需要执行的时间。\n2. 第二个函数是：这个函数里面入参是一个`context`的对象，这个对象包含了在执行这个动画时候需要的信息。\n\n--\n\n* 在这里，我们新建了一个对象，这个对象名字为`CircularTransition`,继承自`NSObject`，同事还需要继承`UIViewControllerAnimatedTransitioning`协议的对象，实现下面的两个方法：\n\n```\nfunc transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) \n  -> TimeInterval {\n  return 0.5\n}\n\n// 这里先空着，后面会重点来写这里的代码\nfunc animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n  //make some magic happen\n  \n}\n```\n\n* 并且将之前的`TransitionCoordinator.swift`文件里面返回`nil`的修改为：\n\n```\nreturn CircularTransition()\n```\n\n* 这样你就已经完成了一件事情，告诉`UINavigationController`,现在所有`VC`之前的切换都需要去询问`UIViewControllerAnimatedTransitioning object`,这里也就是我们新建的那个对象`CircularTransition`\n\n\n* 首先在`CircularTransition.swift`的开头，我们需要定义一个协议，协议如下：\n\n```\nprotocol CircleTransitionable {\n  var triggerButton: UIButton { get }\n  var contentTextView: UITextView { get }\n  var mainView: UIView { get }\n}\n```\n* 首先定义了一个`triggerButton`,这将是我们VC中需要点击切换的按钮。\n* 定义了一个`contentTextView`我们需要动画移入移除的View。\n* `mainView`是显示的主内容。\n\n* 下面我们切换到`ColoredViewController.swift`,这个`ColoredViewController.swift`是`BlackViewController` `WhiteViewController`的父类,让这个VC的遵循这个协议，并且这个VC里面已经存在`triggerButton`和`contentTextView`，只需要添加下面的代码：\n\n```\nvar mainView: UIView {\n  return view\n}\n```\n\n--\n\n* 下面真正开始动手写动画的代码,切换到`CircularTransition.swift`里的`animateTransition(transitionContext:)`的函数，添加如下的代码：\n\n```\nguard let fromVC = transitionContext.viewController(forKey: .from) as? CircleTransitionable,\n  let toVC = transitionContext.viewController(forKey: .to) as? CircleTransitionable,\n  let snapshot = fromVC.mainView.snapshotView(afterScreenUpdates: false) else {\n    transitionContext.completeTransition(false)\n    return\n}\n```\n\n* 这里要确保你能获得所有的东西，通过`transitionContext`的对象，可以获取到切换的`viewcontrollers`,并且将这些vc修饰为`CircleTransitionable`,这样你就可以获得`main views`以及`text views`.\n* `snapshotView(afterScreenUpdates:)`能够直接返回`fromVC`的暂存二进制照片。这是一个视图的副本拷贝。\n* 在`else`的情况下，你调用了`transitionContext.completeTransition(false)`,你这里传递给`UIKit`一个false就是要告诉你没有完成动画，也不应该切换到下一个VC\n* 通过`context`来获取切换的容器视图内容：`let containerView = transitionContext.containerView`,这个view，就是在VC切换中的主内容视图。[1. 当你做动画的时候，其实操作的就是这个containerView对象。2. 从这个containerView中移除fromVC 的view, 3. 在containerView中添加toVC的view]\n\n--\n\n* **为了移动之前页面，而不会打乱之前的布局，这这里我们实际动画操作的是之前页面的副本**在函数`animateTransition(transitionContext:):`的结尾添加如下的方法：\n\n```\ncontainerView.addSubview(snapshot)\n```\n\n* 而你真正需要移除的当前的view，需要在下面调用如下的方法：\n\n```\nfromVC.mainView.removeFromSuperview()\n```\n\n--\n\n* 在下面添加如下的方法:\n\n```\nfunc animateOldTextOffscreen(fromView: UIView) {\n  // 1\n  UIView.animate(withDuration: 0.25, \n                 delay: 0.0, \n                 options: [.curveEaseIn], \n                 animations: {\n    // 2\n    fromView.center = CGPoint(x: fromView.center.x - 1300,\n                              y: fromView.center.y + 1500)\n    // 3\n    fromView.transform = CGAffineTransform(scaleX: 5.0, y: 5.0)\n  }, completion: nil)\n}\n```\n* 定义了一个0.25秒时间间隔的动画。\n* 移动view的center的坐标。\n* 并且将view的尺寸放大5倍。\n* 这将会导致text的视图放大、并且同时移除界面。\n\n--\n\n* 在`animateTransition(transitionContext:):`的底部添加如下的代码：\n\n```\nanimateOldTextOffscreen(fromView: snapshot)\n```\n\n--\n\n* 此时运行代码的时候，会发现可以正常移动了，但是在以后的时候背景色一直是个黑色背景。\n* 这个黑色的背景其实就是`containerView`的背景色，其实这里作者想动画的东西是文本，而不是整个view的动画，这里我们需要添加一个新的背景，并且这个新的背景我们不需要添加动画。切换到`CircularTransition.swift`里的`animateTransition(using:)`，在添加`snapshotView`作为子视图之前添加如下的代码：\n\n```\nlet backgroundView = UIView()\nbackgroundView.frame = toVC.mainView.frame\nbackgroundView.backgroundColor = fromVC.mainView.backgroundColor\ncontainerView.addSubview(backgroundView)\n```\n\n--\n\n* 以此在下面添加如下的代码,这个函数主要完成圆的动画效果:\n\n```\nfunc animate(toView: UIView, fromTriggerButton triggerButton: UIButton) {\n  \n}\n```\n\n* 并且在`animateTransition(using:)`中，在方法`animateOldTextOffscreen(fromView:snapshot):`之后添加如下的代码：\n\n```\ncontainerView.addSubview(toVC.mainView)\nanimate(toView: toVC.mainView, fromTriggerButton: fromVC.triggerButton)\n```\n\n--\n\n* 这里其实你已经大概的了解了动画的大体想法了，但是具体这个动画，我们还需要用到一个新的对象，这个对象是`CAShapeLayer`,`CAShapeLayer`是`CALayer`的一个特殊类，他不仅仅总是呈现正方形的图形，而是可以通过定义贝赛尔曲线路径，然后将路径丢给图层的路径，就可以实现自定义的图案了。\n* 在这种情况下，我们需要定义两种不同的贝赛尔曲线路径。\n* 在函数`animate(toView:triggerButton:):`里面添加如下的代码：\n\n```\n// 1\nlet rect = CGRect(x: triggerButton.frame.origin.x,\n                  y: triggerButton.frame.origin.y,\n                  width: triggerButton.frame.width,\n                  height: triggerButton.frame.width)\n// 2\nlet circleMaskPathInitial = UIBezierPath(ovalIn: rect)\n```\n* 这里创建了一个新的贝赛尔曲线，创建的是一个小小的圆，起始的位置，起始就是`triggerButton`的坐标。这也就是起始动画的圆的状态。\n* 下面在创建相应的动画结束状态，由于你看到只是一个圈圈内的东西，圈圈边缘以及外部的东西都是看不到的，因此添加如下的代码：\n\n```\n// 1\nlet fullHeight = toView.bounds.height\nlet extremePoint = CGPoint(x: triggerButton.center.x,\n                           y: triggerButton.center.y - fullHeight)\n// 2\nlet radius = sqrt((extremePoint.x*extremePoint.x) +\n                  (extremePoint.y*extremePoint.y))\n// 3\nlet circleMaskPathFinal = UIBezierPath(ovalIn: triggerButton.frame.insetBy(dx: -radius,\n                                                                           dy: -radius))\n```\n\n* 首先定义了界面的总高度。\n* 通过勾股定理来计算圆的半径。\n* 然后定义出新的贝赛尔曲线路径。**这里还用到一个新的api叫做insetBy，这里的作用就是设置边框的大小，当设置的值为负值的时候，原来的frame值就会变大**\n\n--\n\n* 现在已经获得了起始、终点的状态的贝塞尔曲线路径，所以在函数`animate(toView:triggerButton:)`中添加如下的代码：\n\n```\nlet maskLayer = CAShapeLayer()\nmaskLayer.path = circleMaskPathFinal.cgPath\ntoView.layer.mask = maskLayer\n```\n* 这里创建了一个`CAShapeLayer`的对象，并且将它的`path`的属性值设置为我们刚才创建的最终状态的贝塞尔曲线值，并且将这个`mask`的值赋值给`toView.layer.mask`。\n\n--\n\n#### CALayer Masking是如何生效的呢？\n\n* 当一个view的alpha为1的时候，将会显示mask图层下的东西。\n* 而当alpha为0的时候，就会隐藏mask下面的东西，这个就是图表解释：\n\n![](https://koenig-media.raywenderlich.com/uploads/2014/10/mask-diagram-700x381.png)\n\n\n--\n\n* 在函数`animate(toView:triggerButton:)`里创建了一个`CABasicAnimation`的对象,并且告诉它animation修改`path`的属性:\n\n```\nlet maskLayerAnimation = CABasicAnimation(keyPath: \"path\")\nmaskLayerAnimation.fromValue = circleMaskPathInitial.cgPath\nmaskLayerAnimation.toValue = circleMaskPathFinal.cgPath\nmaskLayerAnimation.duration = 0.15\nmaskLayerAnimation.delegate = self\n```\n\n* 然后到文件的最底下，创建如下的代码：\n\n```\nextension CircularTransition: CAAnimationDelegate {\n  func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {\n\n  }\n}\n```\n\n* 当回调到这个函数的时候，就代表这个动画已经运行成功，并且结束了。在这个回调中，你需要给这个`context`调用`completeTransition()`的方法`,需要在这个回调的方法中获得`context`的对象，你需要将这个对象设置为全局的，在`CircularTransition`头部，添加如下的代码：\n\n```\nweak var context: UIViewControllerContextTransitioning?\n```\n\n* 并且在函数`animateTransition(transitionContext:)`中的guard之后添加如下的代码：\n\n```\ncontext = transitionContext\n```\n\n* 最后还需要将这个动画效果添加这个`Layer`上：\n\n```\nmaskLayer.add(maskLayerAnimation, forKey: \"path\")\n```\n\n--\n\n#### 效果的完善\n\n* 在`CircularTransition`类里添加如下的方法：\n\n```\nfunc animateToTextView(toTextView: UIView, fromTriggerButton: UIButton) {\n  \tlet originalCenter = toTextView.center\n\ttoTextView.alpha = 0.0\n\ttoTextView.center = fromTriggerButton.center\n\ttoTextView.transform = CGAffineTransform(scaleX: 0.1, y: 0.1)\n\tUIView.animate(withDuration: 0.25, delay: 0.1, options: \t[.curveEaseOut], animations: {\n  \ttoTextView.transform = CGAffineTransform(scaleX: 1.0, y: \t1.0)\n  \t\ttoTextView.center = originalCenter\n  \t\ttoTextView.alpha = 1.0\n\t}, completion: nil)\n}\n```\n\n* 最后再`animateTransition(transitionContext:).`方法中添加如下的按钮：\n\n```\nanimateToTextView(toTextView: toVC.contentTextView, fromTriggerButton: fromVC.triggerButton)\n```\n\n\n \n\n","tags":["Swift、Animation"],"categories":["日志"]},{"title":"关于RxSwift信息量的一些问题(二)","url":"/2017/10/11/20171011/","content":"\n* 在之前的文章中，已经介绍了一些，过滤、筛选信号量的操作符，现在列举一些复杂操作符。\n\n---\n\n* 首先要说的一个操作符叫做`Scan`，看到在官方文档中，`Scan`是属于在`Transforming`，也就可以猜到，这个操作符，其实也是信号转换的部分。\n\n<!-- more -->\n\n* 先看一下官方的介绍\n\n> The Scan operator applies a function to the first item emitted by the source Observable and then emits the result of that function as its own first emission. It also feeds the result of the function back into the function along with the second item emitted by the source Observable in order to generate its second emission. It continues to feed back its own subsequent emissions along with the subsequent emissions from the source Observable in order to create the rest of its sequence.\n\n* 在看一下github上代码的：\n\n```\npublic func scan<A>(_ seed: A, accumulator: @escaping (A, E) throws -> A)\n    -> Observable<A> {\n    return Scan(source: self.asObservable(), seed: seed, accumulator: accumulator)\n}\n\n...\n\nfinal fileprivate class Scan<Element, Accumulate>: Producer<Accumulate> {\ntypealias Accumulator = (Accumulate, Element) throws -> Accumulate\n    \nfileprivate let _source: Observable<Element>\nfileprivate let _seed: Accumulate\nfileprivate let _accumulator: Accumulator\n    \ninit(source: Observable<Element>, seed: Accumulate, accumulator: @escaping Accumulator) {\n    _source = source\n    _seed = seed\n    _accumulator = accumulator\n}\n}\n```\n\n* 这就可以根据官方的介绍可以知道，什么是`Scan`\n* `Scan`操作符，需要接受两个参数，一个参数是泛型A, 第二个参数是`block`，`block`的参数类型以及返回值的类型是`(A, Element) -> A`.\n* 这里的`Element`，是在也不是随编的泛型，可以看源码中知道，`Scan`在实例化的时候，出入了三个参数，其中第一个参数，是讲自己转化为可订阅的对象`self.asObservable()`,在入参中`Observable<Element>`,这就说明了，这个`Element`的类型，和你起初的订阅的对象的订阅类型是同一个类型。\n* 看一下demo：\n\n```\n// 这里只是将字符打印出来\nlet bag = DisposeBag()\nlet subject = PublishSubject<String>()\n    \n_ = subject\n    .subscribe(onNext: {print($0)})\n    .addDisposableTo(bag)\n    \nsubject.onNext(\"gong\")\nsubject.onNext(\"h\")\n\n//终端输出\ngong\nh\n\n---\n\n// 这里是用来计算我输入字符长度的累加\nlet bag = DisposeBag()\nlet subject = PublishSubject<String>()\n    \n_ = subject\n    .scan(0) {(count: Int, content: String) in\n        return count + content.characters.count\n    }\n    .subscribe(onNext: {print($0)})\n    .addDisposableTo(bag)\n    \nsubject.onNext(\"gong\")\nsubject.onNext(\"h\")\n//终端输出\n4\n5\n\n---\n\n```\n\n* 你可以试试，看看能不能将Content的类型修改任意类型呢？答案是肯定不行的，之前在看源码的时候，我已经解释过为什么了，这里的`content`的类型必须要和我们制定定义`subject`的类型相同。\n\n---\n\n* `skpiWhile`之前一直没有绕清楚，今天还是打算看一下源码，这只我已经说了，这个是用来筛选信号的时候用的，之前一直不清楚为什么为true的时候，就会过滤信号呢？\n* 查看github上代码，可以看到在，关键的代码：\n\n```\nfunc on(_ event: Event<Element>) {\n    switch event {\n    case .next(let value):\n        if !_running {\n            do {\n                _running = try !_parent._predicate(value)\n            } catch let e {\n                forwardOn(.error(e))\n                dispose()\n                return\n            }\n        }\n\n        if _running {\n            forwardOn(.next(value))\n        }\n    case .error, .completed:\n        forwardOn(event)\n        dispose()\n    }\n}\n```\n\n* 看到代码就知道，除非是`.onError()/onCompleted()`事件，其他`.onNext()`的时间，都会先执行，你传入的`block`,看看你的返回值是什么？如果是true的话，就会执行`forwardOn()`的函数：\n\n```\nfinal func forwardOn(_ event: Event<O.E>) {\n    #if DEBUG\n        if AtomicIncrement(&_numberOfConcurrentCalls) > 1 {\n            rxFatalError(\"Warning: Recursive call or synchronization error!\")\n        }\n\n        defer {\n            _ = AtomicDecrement(&_numberOfConcurrentCalls)\n        }\n    #endif\n    if _disposed {\n        return\n    }\n    _observer.on(event)\n}\n```\n\n* 这里可以看到，他讲下一个值有递归传到同一个函数中了，这样就起到了过滤的效果。\n\n---\n\n* 还有一些关于信号转换的问题，如何转化为数组类型,这里我用到`toArray()`,Demo:\n* 这种转化是一次性的，并当你下次发送`.onNext()`的时候，他是不会转化，也就不会接受到`.onNext()`的回调.\n* 如果在调用`.onNext()`值之前，你已经转化为Array，在你下次转化的时候，就无法再转化了。\n\n```\nObservable.of(1,2,3,4)\n\t.toArray()\n    .subscribe(onNext: {\n        dump(type(of: $0))\n        dump($0)\n    })\n \n //终端输出\n- Swift.Array<Swift.Int> #0\n▿ 4 elements\n- 1\n- 2\n- 3\n- 4\n```\n\n--- \n\n* 操作符`map`的操作，也是接受一个block，这里直接上代码：\n\n```\nfunc on(_ event: Event<SourceType>) {\n    switch event {\n    case .next(let element):\n        do {\n            let mappedElement = try _transform(element)\n            forwardOn(.next(mappedElement))\n        }\n        ....\n}\n```\n\n* 这里可以看到我们出入的block 就像一个加工厂一样，会将接受到的`element`的参数，经过我们传入的block加工后，会返回一个新的值，然后又会回传给自己。这样每次接受到的就是新值了。\n\n---\n\n* 而操作符`mapWithIndex会回传回来两个参数，一个value值，一个是index值`，这里又是什么意思呢？看一下源代码：\n\n```\n\n....\n\nprivate var _index = 0\n\n...\n\n\nfunc on(_ event: Event<SourceType>) {\n    switch event {\n    case .next(let element):\n        do {\n            let mappedElement = try _selector(element, try incrementChecked(&_index))\n            forwardOn(.next(mappedElement))\n        }\n        ...\n    \nfunc incrementChecked(_ i: inout Int) throws -> Int {\n\tif i == Int.max {\n\t\tthrow RxError.overflow\n\t}\n\tdefer { i += 1 }\n\treturn i\n}\n        \n        ...\n        \n```\n\n* 很明显了，index初始值是从0开始，每次都会拿到指针，进行累加，然后回传回去，也就是我们所说的index了。\n\n--- \n\n* 下面一个比较难理解的操作符叫做`flatMap`,看官网上的介绍为是这样的：\n\n> transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable\n\n* 这句话其实非常绕，可能不理解的人可能一直读不懂。首先理解第一句话，`transform the items emitted by an Observable into Observables`: 我的理解是，由*一个*`可被订阅的对象`发出的多个值，通过我们传入的`block`,来变换为多个`可订阅的对象`\n\n```\nlet bag = DisposeBag()\nlet subject = PublishSubject<GHObject>()\n    \n_ = subject\n    .flatMap{\n        $0.gh_value.asObservable()\n    }\n    .subscribe(onNext: {\n        print(type(of: $0))\n        dump($0)\n    }).addDisposableTo(bag)\n    \nlet gh1 = GHObject(gh_value: Variable(10))\n    \nsubject.onNext(gh1)\ngh1.gh_value.value = 11\n\n...\nstruct GHObject {\n    var gh_value: Variable<Int>\n}\n\n//终端输出\n- 10\n- 11\n\n```\n\n* 那第二句话怎么理解呢？`then flatten the emissions from those into a single Observable`,通过上面的代码已经知道了，我们通过`flatMap`操作符，已经将`GHObject`->`Int`，如果我存在多个`GHObject`的对象，同事发出值，此时我们就可以看做是将多个`Int`的值发送了出来，至于是哪个`GHObject`发送出来的，我们不需要关心：\n\n```\nlet bag = DisposeBag()\nlet subject = PublishSubject<GHObject>()\n    \n_ = subject\n    .flatMap{\n        $0.gh_value.asObservable()\n    }\n    .subscribe(onNext: {\n        dump($0)\n    }).addDisposableTo(bag)\n    \nlet gh1 = GHObject(gh_value: Variable(10))\n    \nsubject.onNext(gh1)\ngh1.gh_value.value = 11\n    \nlet gh2 = GHObject(gh_value: Variable(100))\nsubject.onNext(gh2)\n    \ngh1.gh_value.value = 12\ngh2.gh_value.value = 101\ngh2.gh_value.value = 102\n\n//终端输出\n- 10\n- 11\n- 100\n- 12\n- 101\n- 102\n```\n\n* 至于和`flatMap`类似的一个操作符,我们叫做`flatMapLatest`,我是这么李操操作符的：`一点接受了一个新的GHObject发的gh_value值之后，之前旧的GHObject_value发出的gh_value我们都会统统过滤掉`，Demo:\n\n```\nlet bag = DisposeBag()\nlet subject = PublishSubject<GHObject>()\n    \n_ = subject\n    .flatMapLatest{\n        $0.gh_value.asObservable()\n    }\n    .subscribe(onNext: {\n        dump($0)\n    }).addDisposableTo(bag)\n    \nlet gh1 = GHObject(gh_value: Variable(10))\n    \nsubject.onNext(gh1)\ngh1.gh_value.value = 11\n    \nlet gh2 = GHObject(gh_value: Variable(100))\n\nsubject.onNext(gh2)\n    \ngh1.gh_value.value = 12\ngh2.gh_value.value = 101\ngh2.gh_value.value = 102\n    \ngh1.gh_value.value = 13\ngh1.gh_value.value = 14\ngh1.gh_value.value = 15\n\n//终端输出\n- 10\n- 11\n- 100\n- 101\n- 102\n```\n\n* 这个`flatMapLatest`听上去比较绕，但是一旦拿起笔画画，就会很清晰了。\n\n---\n\n* 在获取某些信号量的时候，我们需要在此之前获取其他的信号，这里我们可以用到`.startWith(_ elements: E ...)`，看一下github中的源码，就会发现了：\n\n```\npublic func startWith(_ elements: E ...)\n    -> Observable<E> {\n        return StartWith(source: self.asObservable(), elements: elements)\n}\n\n...\n\noverride func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {\n    for e in elements {\n        observer.on(.next(e))\n    }\n\n    return (sink: Disposables.create(), subscription: source.subscribe(observer))\n}\n\n...\n\n```\n\n* 看到这里，你应该也就知道了，这个startWith接受的是一个可变参数，在正在订阅到自己想要的数据之前，会先遍历打印之前的信号。看一下Demo:\n\n```\nlet bag = DisposeBag()\nlet subject = PublishSubject<String>()\n    \nsubject\n    .startWith(\"Step1\", \"Step2\", \"Step3\")\n    .subscribe(onNext: {\n        print($0)\n    }).addDisposableTo(bag)\n    \nsubject.onNext(\"Do somethingA\")\nprint(\"----\")\nsubject.onNext(\"Do somethingB\")\n\n//终端输出\nStep1\nStep2\nStep3\nDo somethingA\n----\nDo somethingB\n```\n\n* 可以看出，他不是每次订阅的时候，都会将startWith中的值打印一遍，只会打印一次。\n\n---\n\n* 串联链接多个事件的操作符，我们可以使用`concat`,调用方式有很多种，看一下源码：\n\n```\nextension ObservableType {\n\n    /**\n     Concatenates the second observable sequence to `self` upon successful termination of `self`.\n\n     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)\n\n     - parameter second: Second observable sequence.\n     - returns: An observable sequence that contains the elements of `self`, followed by those of the second sequence.\n     */\n    public func concat<O: ObservableConvertibleType>(_ second: O) -> Observable<E> where O.E == E {\n        return Observable.concat([self.asObservable(), second.asObservable()])\n    }\n}\n```\n\n* 看这种定义的方式，我们可以这样实现`concat`:\n\n```\nlet bag = DisposeBag()\n    \nlet subjectA = PublishSubject<String>()\nlet subjectB = PublishSubject<String>()\nlet subjectC = PublishSubject<String>()\n    \n_ = subjectA.concat(subjectB.concat(subjectC)).subscribe(onNext: {\n    print($0)\n}).addDisposableTo(bag)\n    \nsubjectA.onNext(\"A1\")\nsubjectA.onCompleted()\nsubjectB.onNext(\"B1\")\nsubjectB.onCompleted()\nsubjectC.onNext(\"C1\")\n\n//终端的输出\nA1\nB1\nC1\n```\n\n* 这里你可以将`subjectA.onCompleted()`注释掉，你会发现终端的输出只有`A1`,这也就解释了`串行队列`，只有在`subjectA`完成的时候，他才会订阅下一个时间。\n* 系统还给`Observable`写了个`extension`，这样在正在调用的时候，更加方便、直观。看源码：\n\n```\nextension Observable {\n    /**\n     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.\n\n     This operator has tail recursive optimizations that will prevent stack overflow.\n\n     Optimizations will be performed in cases equivalent to following:\n\n     [1, [2, [3, .....].concat()].concat].concat()\n\n     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)\n\n     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.\n     */\n    public static func concat<S: Sequence >(_ sequence: S) -> Observable<Element>\n        where S.Iterator.Element == Observable<Element> {\n            return Concat(sources: sequence, count: nil)\n    }\n\n    /**\n     Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully.\n\n     This operator has tail recursive optimizations that will prevent stack overflow.\n\n     Optimizations will be performed in cases equivalent to following:\n\n     [1, [2, [3, .....].concat()].concat].concat()\n\n     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)\n\n     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.\n     */\n    public static func concat<S: Collection >(_ collection: S) -> Observable<Element>\n        where S.Iterator.Element == Observable<Element> {\n            return Concat(sources: collection, count: collection.count.toIntMax())\n    }\n\n    /**\n     Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully.\n\n     This operator has tail recursive optimizations that will prevent stack overflow.\n\n     Optimizations will be performed in cases equivalent to following:\n\n     [1, [2, [3, .....].concat()].concat].concat()\n\n     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)\n\n     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.\n     */\n    public static func concat(_ sources: Observable<Element> ...) -> Observable<Element> {\n        return Concat(sources: sources, count: sources.count.toIntMax())\n    }\n}\n\n```\n\n* 这里可以接受自定义的、系统的集合类型，以及一个可变的类型，都是可以这样使用的。上面的代码就可以按照Demo所写的那样完成:\n\n```\nObservable.concat([subjectA, subjectB, subjectC])\n        .subscribe(onNext: {\n            print($0)\n        }).addDisposableTo(bag)\n        \nObservable.concat(subjectA, subjectB, subjectC)\n    .subscribe(onNext: {print($0)})\n    .addDisposableTo(bag)\n```\n\n---\n\n* 如果是并行操作时间的话，我们可以选用`.merge()`的操作符:\n\n```\nObservable.merge(subjectA, subjectB, subjectC)\n    .subscribe(onNext: {print($0)})\n    .addDisposableTo(bag)\n    \n    \nsubjectA.onNext(\"A1\")\n//subjectA.onCompleted()\nsubjectB.onNext(\"B1\")\n//subjectB.onCompleted()\nsubjectC.onNext(\"C1\")\n\n\n// 终端输出\nA1\nB1\nC1\n```\n\n* 这样可以看出来，及时在之前的时间不完成的情况下，事件的打印依旧。\n\n\n---\n\n* 为了方便控制并行的个数，我们也可以这样使用\n\n```\n Observable.of(subjectA, subjectB, subjectC)\n        .merge(maxConcurrent: 2)\n        .subscribe(onNext: {print($0)})\n        .addDisposableTo(bag)\n```\n\n---\n\n* 合并多个事件的操作符我们可以使用`combineLatest`,Demo：\n\n```\nlet subjectA = PublishSubject<String>()\nlet subjectB = PublishSubject<String>()\n    \nObservable.combineLatest(subjectA, subjectB) {\n    a, b in\n    \n    a + \",\" + b\n    \n}.subscribe(onNext: {\n    dump($0)\n}).addDisposableTo(bag)\n    \nsubjectA.onNext(\"A1\")\nsubjectB.onNext(\"B1\")\nsubjectA.onNext(\"A2\")\nsubjectB.onNext(\"B2\")\n\n//终端输出\n- \"A1,B1\"\n- \"A2,B1\"\n- \"A2,B2\"\n```\n\n* 如果是个时间的合并。类似下面：\n\n```\nlet subjectA = PublishSubject<String>()\nlet subjectB = PublishSubject<String>()\nlet subjectC = PublishSubject<String>()\n    \nObservable.combineLatest([subjectA, subjectB, subjectC]) {\n    events in\n    \n    events.joined(separator: \"--\")\n    \n}.subscribe(onNext: {\n    dump($0)\n}).addDisposableTo(bag)\n    \nsubjectA.onNext(\"A1\")\nsubjectB.onNext(\"B1\")\nsubjectA.onNext(\"A2\")\nsubjectB.onNext(\"B2\")\nsubjectC.onNext(\"C1\")\n//终端输出\n- \"A2--B2--C1\"\n```\n\n* `combineLatest`合并的时间中，必须至少都发生了一次事件发送。\n* 任一一个时间发生更新的时候，都会发生回调。\n* 每次获取的值，都是当前事件的最新的值。\n* `combineLatest`接受的合并事件也可以是不同的值类型 例如下面：\n\n```\nlet bag = DisposeBag()\n    \nlet subjectA = PublishSubject<String>()\nlet subjectB = PublishSubject<Int>()\n    \nObservable.combineLatest(subjectA, subjectB) {\n    a, b in\n    \n    a + \",\" + \"\\(b)\"\n    \n}.subscribe(onNext: {\n    dump($0)\n}).addDisposableTo(bag)\n    \nsubjectA.onNext(\"A1\")\nsubjectB.onNext(11)\nsubjectA.onNext(\"A2\")\nsubjectB.onNext(22)\n/、终端输出\n- \"A1,11\"\n- \"A2,11\"\n- \"A2,22\"\n```\n\n---\n\n* 每次只会合并多个最新的时间话，这里我可以使用`.zip()`的操作符:\n\n```\nlet bag = DisposeBag()\n    \nlet subjectA = PublishSubject<String>()\nlet subjectB = PublishSubject<Int>()\n//let subjectC = PublishSubject<String>()\n    \nObservable.zip(subjectA, subjectB) {\n    a, b in\n    \n    a + \",\" + \"\\(b)\"\n    \n}.subscribe(onNext: {\n    dump($0)\n}).addDisposableTo(bag)\n    \nsubjectA.onNext(\"A1\")\nsubjectB.onNext(11)\nsubjectA.onNext(\"A2\")\nsubjectB.onNext(22)\n\n//终端的输出\n- \"A1,11\"\n- \"A2,22\"\n```\n\n* 如果存在多个`observable`,并且存在一定的依赖关系，在某件事情发送的时候，会去获取另一时间的最新值:\n\n```\nlet bag = DisposeBag()\n    \nlet triggerSubject = PublishSubject<Void>()\nlet contentSubject = BehaviorSubject<String>(value: \"Default value\")\n\n    \n_ = triggerSubject.withLatestFrom(contentSubject)\n.subscribe(onNext: {\n    print($0)\n}).addDisposableTo(bag)\n    \ntriggerSubject.onNext(())\ncontentSubject.onNext(\"Input Extra Content\")\ntriggerSubject.onNext(())\n\n//终端输出\nDefault value\nInput Extra Content\n```\n\n* 在不同的`observable`中，我们可以随意切换任意的时间，使用操作符`.switchLatest()`,这样只能在指定的模式下，做指定的事件：\n\n```\nlet bag = DisposeBag()\n    \nlet reading = PublishSubject<String>()\nlet writing = PublishSubject<String>()\n    \nlet work = PublishSubject<Observable<String>>()\n\nwork.switchLatest()\n    .subscribe(onNext: {\n        print($0)\n    }).addDisposableTo(bag)\n\n    \nwork.onNext(reading)\nreading.onNext(\"Read 1\")\n    \nwork.onNext(writing)\nwriting.onNext(\"Write 1\")\n    \nreading.onNext(\"Read Extra\")\n    \nwork.onNext(reading)\nreading.onNext(\"Read 2\")\n```\n\n\n\n\n","tags":["Swift"],"categories":["日志"]},{"title":"关于RxSwift信息量的一些问题","url":"/2017/10/08/20171007/","content":"\n* 之前的文章中，介绍了RxSwift中，将之前传统的模式修改为更`Rx`的模式，在转换的过程中，我们会发现，其实`RxSwift`只是将之前分散处理的恭喜，收拢起来，之前我们或许关心的是`block的回调`、`代理方法`、`function()调用`，而现在我们或许只需要关心一件事情`信号量`，可想而知，伴随着项目的庞大、功能的复杂，整个项目中充斥着的都是这些信号，此时我们就要学会分析、过滤、转化信号。\n\n<!-- more -->\n\n* 先不去深究下面列举的每个操作符的源代码，在碰到一些特别难以理解的操作符，我们再去查看一下源代码\n\n---\n\n* 忽略信号的操作：\n* 1.先来看一下最最普通的订阅模式：\n\n```\nlet subject = PublishSubject<Int>()\nlet bag = DisposeBag()\n    \n_ = subject.subscribe(\n    onNext: { print($0) },\n    onCompleted: { print(\"Completed\") }\n).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n\n// 终端输入\n1\n2\n3\n4\nCompleted\n```\n\n* 2. 如果我们需要忽略所有的`.onNext()`的时间话，我们可以用`.ignoreElements()`操作符\n\n```\nlet subject = PublishSubject<Int>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .ignoreElements()\n    .subscribe(\n        onNext: { print($0) },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n\n//终端输出\nCompleted\n```\n\n* 3. 如果忽略前几个`.onNext()`事件信号量，我们可以使用`.skip()`操作符,例如`.skip(2)`如果不足2个的话，那就都跳过,直接`.onCompleted()`或者`.onError()`:\n\n```\n_ = subject\n    .skip(2)\n    .subscribe(\n        onNext: { print($0) },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n\n//终端输出\n3\n4\nCompleted\n```\n\n* 指定条件过滤数据，我们可以选用`.skipWhile()`，这里`.skipWhile()`接受的是一个`block`，理解起来可能会比较绕，但是看一下github上的解释：\n\n```\n/**\n Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.\n - seealso: [skipWhile operator on reactivex.io](http://reactivex.io/documentation/operators/skipwhile.html)\n - parameter predicate: A function to test each element for a condition.\n - returns: An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.\n */\npublic func skipWhile(_ predicate: @escaping (E) throws -> Bool) -> Observable<E> {\n    return SkipWhile(source: asObservable(), predicate: predicate)\n}\n```\n\n* 只要条件为`true`，我们就会绕过发出的信号，看一下Demo：\n\n```\nlet subject = PublishSubject<Int>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .skipWhile({ (item) -> Bool in\n        return item != 3\n    })\n    .subscribe(\n        onNext: { print($0) },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n\n//终端输出\n3\n4\nCompleted\n```\n\n* 依赖某个信号量的时候，我们可以选用`.skipUntil()`,这里的入参是例外一个信号量：\n\n```\nlet subject = PublishSubject<Int>()\nlet dependOnSubject = PublishSubject<Void>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .skipUntil(dependOnSubject)\n    .subscribe(\n        onNext: { print($0) },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\ndependOnSubject.onNext(())\nsubject.onNext(4)\nsubject.onCompleted()\n\n//终端输出\n4\nCompleted\n```\n\n* 忽略重复出现的相邻的信号量，我们可以使用`.distinctUntilChanged()`, demo:\n\n```\nlet subject = PublishSubject<Int>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .distinctUntilChanged()\n    .subscribe(\n        onNext: { print($0) },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(3)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onCompleted()\n\n//终端输出\n1\n2\n3\n4\n2\n3\nCompleted\n```\n\n---\n\n* 选择信号的操作\n* 选择指定第几个信号量的操作符，我们可以选用`.elementAt()`,当选择的个数超过了存在的信号量，此时就会报`.onError()`的错误，Demo：\n\n```\nlet subject = PublishSubject<Int>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .elementAt(2)\n    .subscribe(\n        onNext: { print($0) },\n        onError: {_ in print(\"Error\") },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n//终端的输出\n3\nCompleted\n```\n\n* 根据某些条件，筛选过滤出自己想要的数据，我们可以选用`.filter()`的操作符：\n\n```\nlet subject = PublishSubject<Int>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .filter({ (item) -> Bool in\n        item == 2\n    })\n    .subscribe(\n        onNext: { print($0) },\n        onError: {_ in print(\"Error\") },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n//终端输出\n2\nCompleted\n```\n\n* 获取指定数量的操作符，我们也可以选用`.take()`,当入参的数字大于已有的数据，就会把所有的`.onNext()`事件都打印出来:\n\n```\nlet subject = PublishSubject<Int>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .take(2)\n    .subscribe(\n        onNext: { print($0) },\n        onError: {_ in print(\"Error\") },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n//终端输出\n1\n2\nCompleted\n```\n\n* 还有一个比较绕的操作符，叫做`takeWhile()`,和`skipWhile()`类似，只要`block`中返回的是`true`的话，就会选取这儿元素，一旦false就结束\n\n```\nlet subject = PublishSubject<Int>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .takeWhile({ (item) -> Bool in\n        item != 2\n    })\n    .subscribe(\n        onNext: { print($0) },\n        onError: {_ in print(\"Error\") },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n//终端输入\n1\nCompleted\n```\n\n* 准备定位到第几个的话，可以选用下面的操作符`takeWhileWithIndex`, 它接受两个参数，一个index,一个value,同样为true，就会选取，为false，就立刻结束\n\n```\nlet subject = PublishSubject<Int>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .takeWhileWithIndex({ (item, index) -> Bool in\n        item != 2 && index != 3\n    })\n    .subscribe(\n        onNext: { print($0) },\n        onError: {_ in print(\"Error\") },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n//终端输出\n1\nCompleted\n```\n\n* 依赖于某个信号，来获取信号量，可以选用`.takeUntil()`,Demo\n\n```\nlet subject = PublishSubject<Int>()\nlet dependOnSubject = PublishSubject<Void>()\nlet bag = DisposeBag()\n    \n_ = subject\n    .takeUntil(dependOnSubject)\n    .subscribe(\n        onNext: { print($0) },\n        onError: {_ in print(\"Error\") },\n        onCompleted: { print(\"Completed\") }\n    ).addDisposableTo(bag)\n    \nsubject.onNext(1)\nsubject.onNext(2)\ndependOnSubject.onNext(())\nsubject.onNext(3)\nsubject.onNext(4)\nsubject.onCompleted()\n//终端输出\n1\n2\nCompleted\n```\n\n---\n\n* 为了同时订阅同个数据的不同信号量，节约开销，我们可以使用这个`.share()`\n\n```\nlet object = Observable.of(1,2,3,4,5).share()\n\n_ = object.subscribe({ print($0 )})\n_ = object.subscribe({ print($0 )})\n```\n\n\n\n","tags":["Swift"],"categories":["日志"]},{"title":"实际项目中从传统模式切换为RxSwift模式","url":"/2017/10/05/20171005/","content":"\n* 举一个简单的例子，来实现RxSwift的功能：\n\n* 列表Controller里面的代码:\n\n<!-- more -->\n\n```\nimport UIKit\n\nclass TestRxSwiftViewController: UIViewController, UITableViewDataSource {\n\n    var datas = [TestRxSwiftItemObject]()\n    @IBOutlet weak var ItemTableview: UITableView!\n\n    // MARK: -- Life Cycle\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        loadDatas()\n        ItemTableview.reloadData()\n    }\n\n    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n        if segue.identifier == \"testRx\" {\n            let detail: TestRxSwiftDetailViewController = segue.destination as! TestRxSwiftDetailViewController\n            if let index = ItemTableview.indexPath(for: sender as! UITableViewCell) {\n                detail.Item = datas[index.row]\n            }\n        }\n    }\n\n    // MARK: -- Private Methods\n\n    func loadDatas() {\n        for i in 1..<10 {\n            let itemObject = TestRxSwiftItemObject(name: \"Index-\\(i)\", isClicked: i % 2 == 0 ? true : false)\n            datas.append(itemObject)\n        }\n    }\n\n    // MARK: -- UITableView DataSource\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return datas.count\n    }\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"cell\", for: indexPath)\n\n        let itemObject = datas[indexPath.row]\n        cell.textLabel?.text = itemObject.name\n        cell.accessoryType   = itemObject.isClicked ? .checkmark : .none\n\n        return cell\n    }\n\n}\n\n```\n\n---\n\n* 详情Controller里面的代码：\n\n```\nclass TestRxSwiftDetailViewController: UIViewController {\n\n    @IBOutlet weak var content: UITextField!\n    @IBOutlet weak var isOn: UISwitch!\n\n    var Item: TestRxSwiftItemObject?\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        // Do any additional setup after loading the view.\n        if let Item = Item {\n            content.text = Item.name\n            isOn.isOn    = Item.isClicked\n        }\n\n    }\n}\n```\n\n---\n\n* 切换为RxSwift的模式\n* 1. 首先我们将我们在列表控制器里面的`Array`, 更换为可以订阅的变量，这里我们用`Variable`来代替:\n\n```\n//之前\nvar datas = [TestRxSwiftItemObject]()\n//之后\nvar datas = Variable<[TestRxSwiftItemObject]>([])\n```\n* 并且将所有的去数据中的对象的方法切换一下：\n\n```\n//之前\nlet itemObject = datas[indexPath.row]\n//之后\nlet itemObject = datas.value[indexPath.row]\n```\n\n* 然后我们只需要更加、删除数据，关于UI的切换，我们可以统一做处理，如下：\n* 以为之前我们已经将`data`，切换为`Variable`了，这样我们可以通过调用`asObservable()`就可以改为可定于的订阅的对象，并且可以接受到回调。\n\n```\n_ = datas.asObservable().subscribe(\n    onNext: { [weak self] todos in\n        self?.updateUI(todos: todos)\n    }\n).addDisposableTo(bag)\n\n\nfunc updateUI(todos: [TestRxSwiftItemObject]) {\n    title = todos.isEmpty ? \"Todos\" : \"\\(todos.count) Todos\"\n    addBtn.isEnabled = todos.filter { !$0.isClicked }.count < 6\n\n    ItemTableview.reloadData()\n}\n```\n\n* 关于的数据的传递，涉及到两点，第一个：我们如何从首页数据传递给第二个控制器呢？`通过公开的属性传递`：\n\n```\nlet detail: TestRxSwiftDetailViewController = segue.destination as! TestRxSwiftDetailViewController\nif let index = ItemTableview.indexPath(for: sender as! UITableViewCell) {\ndetail.Item = datas.value[index.row]\n```\n\n* 第二点我们如何将第二个控制器里面的属性回传给首页控制器呢？，我们在第二页控制器里公开出一个可以订阅的对象，这样我们只要在第二个控制前里面修改数据值，并且传递，就能再第一个控制器里面接收到回调了。这里有个两点：\n\n```\nfileprivate var itemSubject = PublishSubject<TestRxSwiftItemObject>()\nvar item: Observable<TestRxSwiftItemObject> {\n    return itemSubject.asObservable()\n}\n```\n* 首先定义的`fileprivate`,阻止了外部给这个变量发送数据。而仅仅只是给外部暴露了一个`item`的对像。\n* 而在对象内部，我们依旧可以通过`itemSubject`来发送数据，并且外部也能够接受到回调。\n* 点击保存，第二个页面`dismiss之前`，我执行如下的保存操作：\n\n```\nif let item = Item {\n    item.name = content.text!\n    item.isClicked = isOn.isOn\n\n    itemSubject.onNext(item)\n    itemSubject.onCompleted()\n}\n```\n* 这样在首页我们就可以这样接受到回调了：\n\n```\nlet detail: TestRxSwiftDetailViewController = segue.destination as! TestRxSwiftDetailViewController\nif let index = ItemTableview.indexPath(for: sender as! UITableViewCell) {\n    detail.Item = datas.value[index.row]\n    _ = detail.item.subscribe(\n        onNext: { [weak self] newTodo in\n            self?.datas.value[index.row] = newTodo\n        },\n        onDisposed: {\n            print(\"Finishing changing item content\")\n        }\n    )\n}\n```\n\n* 关于最后一点异步的回调操作，简单的来说，我们将之前返回值`Void`->`Observable<Void>`或者`URL`->`Observable<URL>`,Demo:\n\n```\nenum CustomError: Error {\n    case someOptionErrors\n    case urlIsNullError\n}\n\nfunc syncToSaveDatas() -> Observable<URL> {\n\n    return Observable.create { observer in\n\n        var testURL: URL?\n        var someOptions: Bool\n\n        testURL     = URL(string: \"\")\n        someOptions = true\n\n        // Error 1\n        guard someOptions else {\n            observer.onError(CustomError.someOptionErrors)\n            return Disposables.create()\n        }\n\n\n        if let testURL = testURL {\n            // success\n            observer.onNext(testURL)\n            observer.onCompleted()\n\n        } else {\n            // Error 2\n            observer.onError(CustomError.urlIsNullError)\n            return Disposables.create()\n        }\n\n        return Disposables.create()\n    }\n\n\n}\n\n@IBAction func saveDatas(_ sender: Any) {\n    _ = syncToSaveDatas().subscribe(\n        onNext: { url in\n            print(url)\n        },\n        onError: {\n            print(\"error is \\($0)\")\n        },\n        onCompleted: {\n            print(\"Success\")\n        }\n    )\n}\n```\n","tags":["Swift"],"categories":["日志"]},{"title":"学习RxSwift","url":"/2017/10/03/20171003/","content":"\n* 创建可以订阅的对象，在RxSwift中称之为`Observable`,我们可以通过系统介绍给我的方法来创建(我们称之为Operators)。\n\n<!-- more -->\n\n---\n\n* 这里我们通过`Create`的`Operators`的方法来创建，先看一下官网[http://reactivex.io/documentation/operators/create.html] 的介绍:\n\n> You can create an Observable from scratch by using the Create operator. You pass this operator a function that accepts the observer as its parameter. Write this function so that it behaves as an Observable — by calling the observer’s onNext, onError, and onCompleted methods appropriately.\n> A well-formed finite Observable must attempt to call either the observer’s onCompleted method exactly once or its onError method exactly once, and must not thereafter attempt to call any of the observer’s other methods.\n\n* 再看一下`github`上源码：\n\n```\nextension Observable {\n    // MARK: create\n    /**\n     Creates an observable sequence from a specified subscribe method implementation.\n     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)\n     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.\n     - returns: The observable sequence with the specified implementation for the `subscribe` method.\n     */\n    public static func create(_ subscribe: @escaping (AnyObserver<E>) -> Disposable) -> Observable<E> {\n        return AnonymousObservable(subscribe)\n    }\n}\n```\n\n* 按照官网的介绍，我们就可以通过`Create`来创建一个可被订阅的对象，这个对象的入参是一个block，任意对象的`Observer`,他可以发送`.onNext()/.onComplete()/.onError()`\n* 第二段的注释的意思，就是这个`Observer`可以发送`.onNext()`,但是这个对象一旦发送了一次`.onComplete()`或者`.onError()`,然后就不能尝试调用任何观察者的其他方法了。看一下Demo：\n\n```\n\nenum CustomeError: Error {\n    case somethingError\n}\n\n\tlet customOB = Observable<Int>.create { observer in\n\n\tobserver.onNext(1)\n\tobserver.onNext(2)\n\n\t//observer.onError(CustomeError.somethingError)\n\n\tobserver.onCompleted()\n\n\treturn  Disposables.create()\n\n}\n\nlet disposeBag1 = DisposeBag()\ncustomOB.subscribe(\n    onNext: { print($0) },\n    onError: { print($0) },\n    onCompleted: { print(\"onCompleted\") },\n    onDisposed: { print(\"onDisposed\") }\n).addDisposableTo(disposeBag1)\n\n```\n\n* 这创建的依旧是一个`Observer`的对象，也可以调用其他的`Operator`,这里为了方便的调试，我们可以使用`.debug()`。使用如下：\n\n```\nlet disposeBag1 = DisposeBag()\ncustomOB\n\t.debug()\n\t.subscribe(\n\t    onNext: { print($0) },\n\t    onError: { print($0) },\n\t    onCompleted: { print(\"onCompleted\") },\n\t    onDisposed: { print(\"onDisposed\") }\n\t).addDisposableTo(disposeBag1)\n\n\t// 控制台的打印信息如下：\n2017-10-03 13:58:23.488: ViewController.swift:35 (viewDidLoad()) -> subscribed\n2017-10-03 13:58:23.493: ViewController.swift:35 (viewDidLoad()) -> Event next(1)\n1\n2017-10-03 13:58:23.493: ViewController.swift:35 (viewDidLoad()) -> Event next(2)\n2\n2017-10-03 13:58:23.493: ViewController.swift:35 (viewDidLoad()) -> Event completed\nonCompleted\nonDisposed\n2017-10-03 13:58:23.493: ViewController.swift:35 (viewDidLoad()) -> isDisposed\n```\n\n* 在我们真是的项目中，我们可能需要不仅仅是一个订阅者或者发布者，我们需要的是一个不仅可以订阅、也可以发布的对象，在`RxSwift`中，我们称之为`Subjects`:\n\n---\n\n* 首选我们要说的`Subjects`对象叫做`PublishSubject`,看一下github上的源码：\n\n```\n/// Represents an object that is both an observable sequence as well as an observer.\n///\n/// Each notification is broadcasted to all subscribed observers.\npublic final class PublishSubject<Element>\n```\n\n* 再看官网上对`PublishSubject`对象的介绍：\n\n> PublishSubject emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.\n\n> Note that a PublishSubject may begin emitting items immediately upon creation (unless you have taken steps to prevent this), and so there is a risk that one or more items may be lost between the time the Subject is created and the observer subscribes to it. If you need to guarantee delivery of all items from the source Observable, you’ll need either to form that Observable with Create so that you can manually reintroduce “cold” Observable behavior (checking to see that all observers have subscribed before beginning to emit items), or switch to using a ReplaySubject instead.\n\n> If the source Observable terminates with an error, the PublishSubject will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.\n\n* *只有先订阅消息，再发送消息，才能接受到消息*\n* 首先可以看出来，这个对象是`Cold Sign`,这里所谓的`Cold`，就代表，当创建完这个对象的时候，并不会立刻发送数据，而只有在有订阅者订阅它的时候，它才会发送数据。\n* 而这里还有一点很重要的是，*PublishSubject只能够订阅在它之后发送的数据*，这一点也就是说，在这个订阅消息之前，不管我们发送了多少数据，在真正订阅之后，这些之前订阅的数据是不会发送的。\n* 并且在约到失败的时候，这个对象就将被终止，除了在回调的`.onError()`方法之外，以后所有的数据都将无法接受。看一下Demo：\n\n```\nlet subject = PublishSubject<String>()\n\nsubject.onNext(\"Test1\")\nsubject.onNext(\"Test2\")\n\nlet sub1 = subject.subscribe(\n    onNext: { print(\"1:) \\($0)\")}\n)\n\nsubject.onNext(\"Test3\")\n\nsubject.onNext(\"Test4\")\n\nsub1.dispose()\n\nsubject.onNext(\"Test5\")\n\nlet sub2 = subject.subscribe(\n    onNext: { print(\"2:) \\($0)\")}\n)\n\nsubject.onNext(\"Test6\")\nsubject.onNext(\"Test7\")\n\nsub2.dispose()\n\n// 终端输出为\n1:) Test3\n1:) Test4\n2:) Test6\n2:) Test7\n```\n\n---\n\n* 第二种同时即可以订阅，也可以发送消息的对象，我们这里叫做`BehaviorSubject`。这里我们先看一下github中代码:\n\n```\n/// Represents a value that changes over time.\n///\n/// Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.\npublic final class BehaviorSubject<Element>\n```\n\n* 再看一下官网上的介绍：\n\n> When an observer subscribes to a BehaviorSubject, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).\n>\n> However, if the source Observable terminates with an error, the BehaviorSubject will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.\n\n* 看到注释以及代码的意思，这种`Subject`的对象的特点就是，*订阅这种对象，它就可以接收到最近的一次值或者是初始化的默认值*\n* 同样，这个`Subject`的对象，，一旦接受到`.onError()`或者`.onComplete()`, 这个对象将不会再发送任何值了。看一下Demo：\n\n```\nlet subject = BehaviorSubject<String>(value: \"Default Value\")\n\nlet sub1 = subject.subscribe(\n    onNext: { print(\"From1:\\($0)\") }\n)\n\nsubject.onNext(\"Test1\")\n\nsub1.dispose()\n\nlet sub2 = subject.subscribe(\n    onNext: {print(\"From2:\\($0)\")}\n)\n\nsubject.onNext(\"Test2\")\nsubject.onNext(\"Test3\")\n\nsub2.dispose()\n\n// 终端输出\nFrom1:Default Value\nFrom1:Test1\n---\nFrom2:Test1\nFrom2:Test2\nFrom2:Test3\n```\n\n---\n\n* 这里可以通过`BehaviorSubject`可以查看最近一次发送数据，如果是第一次，就会接受到默认的数据，但是如果我们想要接受指定数目的历史数据，我们可以使用另外一种subject，我们叫做：`ReplaySubject`.\n* 看一下github上代码的：\n\n```\n/// Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.\npublic class ReplaySubject<Element>\n```\n\n> ReplaySubject emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.\n\n> There are also versions of ReplaySubject that will throw away old items once the replay buffer threatens to grow beyond a certain size, or when a specified timespan has passed since the items were originally emitted.\n\n> If you use a ReplaySubject as an observer, take care not to call its onNext method (or its other on methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates the Observable contract and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.\n\n* *ReplaySubject对象不能初始化默认值、并且每次打印历史数据的值是可以控制的*，看一下Demo：\n\n```\nlet subject = ReplaySubject<String>.create(bufferSize: 2)\n\nlet sub1 = subject.subscribe(\n    onNext: { print(\"From 1:| \\($0)\")}\n)\n\nsubject.onNext(\"Test1\")\nsubject.onNext(\"Test2\")\nsubject.onNext(\"Test3\")\n\nsub1.dispose()\n\nlet sub2 = subject.subscribe(\n    onNext: { print(\"From 2:| \\($0)\")}\n)\n\nsubject.onNext(\"Test4\")\n\nsub2.dispose()\n\n// 终端输出\nFrom 1:| Test1\nFrom 1:| Test2\nFrom 1:| Test3\nFrom 2:| Test2\nFrom 2:| Test3\nFrom 2:| Test4\n```\n\n---\n\n* 第三种`Subjects`, 我们叫做`Variable`, 看一下github上的注释:\n\n```\n/// Variable is a wrapper for `BehaviorSubject`.\n///\n/// Unlike `BehaviorSubject` it can't terminate with error, and when variable is deallocated\n/// it will complete its observable sequence (`asObservable`).\npublic final class Variable<Element> {\n```\n\n* 特点：*1.这个对象是对BehaviorSubject的上层封装。2.对象不能通过发送Error而终止对象发送数据。3.通过调用asObservable，可以转化为Observer对象。* Demo:\n\n```\nlet subject = Variable(\"Test1\")\n\nlet _ = subject.asObservable().subscribe(\n    onNext: {print(\"1:\\($0)\")}\n)\n\nsubject.value = \"Changed\"\n\nprint(subject.value)\n\n// 终端输出\n1:Test1\n1:Changed\nChanged\n```\n","tags":["Swift"],"categories":["日志"]},{"title":"学习Swift Tips(三)","url":"/2017/09/14/20170914/","content":"\n* `final`修饰的`class`/`func`/`var`,表示内容不允许进行继承或者重写\n\n---\n\n* `lazy`简单赋值：`lazy var str1: String = \"Hello\"`\n* `lazy`计算赋值：\n\n<!-- more -->\n\n```\n  lazy var str: String = {\n\n        let str = \"Hello\"\n        print(\"只有首次访问输出\")\n        return str\n\n    }()\n```\n\n* `lazy`用在一些`map`/`filter`：\n\n```\nlet result = data.lazy.map {\n    (i: Int) -> Int in\n\n    print(\"正在处理 \\(i)\")\n\n    return i * 2\n}\n```\n\n---\n\n* Swift 中的镜像以及反射的问题：我们可以通过`Mirror`来实现：\n\n```\nlet xiaoming = Person(name: \"XiaoMing\", age: 16)\nlet r = Mirror(reflecting: xiaoming)\n\nif let name = valueFrom(xiaoming, key: \"name\") as? String {\n    print(\"通过key 得到值:\\(name)\")\n}\n\ndump(xiaoming)\n\nprint(\"xiaoming 是\\(r.displayStyle!)\")\n\nprint(\"属性个数:\\(r.children.count)\")\n\nfor child in r.children {\n    print(\"属性名:\\(String(describing: child.label)),值:\\(child.value)\")\n}\n\nfunc valueFrom(_ object: Any, key: String) -> Any? {\n\n    let mirror = Mirror(reflecting: object)\n\n    for child in mirror.children {\n\n        let (targetKey, targetMirror) = (child.label, child.value)\n        if key == targetKey {\n            return targetMirror\n        }\n    }\n    return nil\n}\n```\n\n---\n\n* 隐式解包并不能确保属性一定有值，或者一定安全，而是在获取属性值的时候，自动强制解包，如果该值是`nil`的话，在调用的时候，也是会crash的。\n\n---\n\n* optional定义其实就是个枚举：\n\n```\nlet aNil: String? = nil\n\nlet anotherNil: String?? = aNil\nlet literalNil: String?? = nil\n\nif let _ = anotherNil {\n    print(\"anotherNil\")\n}\n\nif let _ = literalNil {\n    print(\"literalNil\")\n}\n```\n\n* 打印`optional`可以通过`fr v -R xxx`\n\n---\n\n* `map`的使用，我见的最多的就是在数组等集合中的`map`使用，先来看一下`map`的定义:\n\n```\n/// Returns an array containing the results of mapping the given closure\n/// over the sequence's elements.\n///\n/// In this example, `map` is used first to convert the names in the array\n/// to lowercase strings and then to count their characters.\n///\n///     let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\n///     let lowercaseNames = cast.map { $0.lowercaseString }\n///     // 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\n///     let letterCounts = cast.map { $0.characters.count }\n///     // 'letterCounts' == [6, 6, 3, 4]\n///\n/// - Parameter transform: A mapping closure. `transform` accepts an\n///   element of this sequence as its parameter and returns a transformed\n///   value of the same or of a different type.\n/// - Returns: An array containing the transformed elements of this\n///   sequence.\npublic func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]\n```\n\n* 清晰明了，这里定义的泛型为T, 函数内部的block，将另外一种泛型Element转化为T，最后还是生成一个[T]类型的数组。\n* 除了数组的map外，这里作者还说了一下`Optional`的`map`行数，效果一样：\n\n```\n/// Evaluates the given closure when this `Optional` instance is not `nil`,\n/// passing the unwrapped value as a parameter.\n///\n/// Use the `map` method with a closure that returns a nonoptional value.\n/// This example performs an arithmetic operation on an\n/// optional integer.\n///\n///     let possibleNumber: Int? = Int(\"42\")\n///     let possibleSquare = possibleNumber.map { $0 * $0 }\n///     print(possibleSquare)\n///     // Prints \"Optional(1746)\"\n///\n///     let noNumber: Int? = nil\n///     let noSquare = noNumber.map { $0 * $0 }\n///     print(noSquare)\n///     // Prints \"nil\"\n///\n/// - Parameter transform: A closure that takes the unwrapped value\n///   of the instance.\n/// - Returns: The result of the given closure. If this instance is `nil`,\n///   returns `nil`.\npublic func map<U>(_ transform: (Wrapped) throws -> U) rethrows -> U?\n\n// 例子如下：\nlet num: Int? = 3\nlet result = num.map {\n    $0 * 2\n}\n\nprint(result) // Optional(6)\n```\n\n---\n\n * `protocol`的`extension`的功能，为协议完成了方法的默认实现。这也，即使遵循了协议，你也可以不用写任何实现的代码。\n * 如果类型推断是实际的类型： 如果类型中没有实现，就会调用拓展中的方法实现。\n * 如果类型推断的是协议：1. 如果在协议中定义过，如果类型中没有实现，那就调用拓展中的实现。 2.如果在协议中没用定义过的话，拓展中的方法默认会被调用。\n\n---\n\n * `where`字段的使用，目前已经不能再`if`/`guard`中使用`where`,但是在`swich`/`foreach`/`for`循环中，我们还是可以使用的。\n\n---\n\n * 对于如果需要在`enum`中循环需要嵌套定义的话，这里我需要用的`indirect`,例如这样我们就可以这样定义一个单向连边的结构了：\n\n ```\n indirect enum LinkedList<Element: Comparable> {\n\n    case empty\n    case node(Element, LinkedList<Element>)\n\n    // 删除链表中某个元素\n func removing(_ element: Element) -> LinkedList<Element> {\n    guard case let .node(value, next) = self else { return .empty }\n\n    return value == element ? next : LinkedList.node(value, next.removing(element))\n\t}    \n\n }\n\n   let linkedList = LinkedList.node(1, .node(2, .node(3, .node(4, .empty))))\n   let result = linkedList.removing(2)\n   print(result)\n ```\n\n---\n\n * 在`Object-c`中，返回`SEL`，我们会直接调用`@selector`，但是在`Swift`中我们已经不能这样调用了，我们需要用到一个字段`#selector`,使用方法类似：\n\n ```\n    func callMe() {}\n\n    func callMeWithParam(obj: AnyObject!) {}\n\n    func turn(by angle: Int, speed: Int) {}\n\n   let someMethod = #selector(callMe)\n   let anotherMethod = #selector(callMeWithParam)\n\n   let method = #selector(turn)\n\n   // 如果名字相同，我们这里需要定义类型：\n\n   let method11 = #selector(comonFunc as () ->())\n   let method22 = #selector(commonFunc(input:) as (Int) -> Int)\n\n\n\n    func comonFunc() {}\n\n    func commonFunc(input: Int) -> Int {\n        return input\n    }\n\n ```\n\n---\n\n* 实例化方法的动态调用：1.通过类获取方法，2.再传入实例得到方法，3.在根据情况传入参数\n\n```\nclass MyClass {\n    func method(number: Int) -> Int {\n        return number + 1\n    }\n\n    class func method(number: Int) -> Int {\n        return number\n    }\n}\n\n\nlet f = MyClass.method\nlet object = MyClass()\nlet result = f(object)(1)\nprint(result)\n\n```\n\n* 如果存在相同名字的函数，可以显示定义类型来区分:\n\n```\nlet f1 = MyClass.method\n\nlet f2: (Int) -> Int = MyClass.method\n\nlet f3: (MyClass) -> (Int) -> Int = MyClass.method\n\n```\n\n---\n\n* 单例：\n\n```\nclass Manager {\n\tstatic let shared = Manager()\n\tprivate init() {}\n}\n```\n\n---\n\n* 自定义编译符号，在`Build Settings`中，找到`Swift Compiler - Custom Flag`,并且在`Other Swift Flags`中加上`-D FREE_VERSION`\n\n---\n\n* 编译符号： `// MARK:`、`// TODO:`、`// FIXME:`\n\n---\n\n* app入口文件，这里默认创建app的时候，项目会自动为我们创建main的文件，在`swift`中，系统自动创建`@UIApplicationMain`,代表系统会自动将这个类标记为启动文件，但是这里我们可以通过如下的方法，可以将启动的文件指定为我们自定义的类，也可以将事件的接受者指定为我们想要的文件类：\n\n```\n// 创建一个main.swift 的文件\nimport UIKit\n\nclass MyApplication: UIApplication {\n    override func sendEvent(_ event: UIEvent) {\n        super.sendEvent(event)\n        print(\"Event sent: \\(event)\")\n    }\n}\n\n\nUIApplicationMain(\n    CommandLine.argc,\n    UnsafeMutableRawPointer(CommandLine.unsafeArgv)\n        .bindMemory(\n            to: UnsafeMutablePointer<Int8>.self,\n            capacity: Int(CommandLine.argc)),\n    nil,\n    NSStringFromClass(AppDelegate.self)\n)\n```\n\n---\n\n* 在`Swift`中的协议默认都是必须要实现的，但是如果用在`Object-c`中，协议的方法是可选的，我们可以这样实现：\n\n```\n@objc protocol OptionalProtocol {\n    @objc optional func optionalMethod()\n}\n```\n\n* 但是有了`Protocol Extension`，我也可以以`Swift`的方式来实现,对于`OC`中可选的协议方法，我们可以通过写protocol extension 来实现可选的功能。\n\n---\n\n\n* `Swift`中的`unowned`和以前的`unsafe_unretained`: 即使它原来引用的内容已经被释放了，它仍然会保持对被释放对象的一个无效引用，它不是optional值，也不能被指向nil,如果调用属性或者方法的时候就会crash。作者建议:\n* 如果确定在访问的时候，不会被释放的话，就使用`unowned`，如果存在释放的可能，那就用`weak`\n\n---\n\n* 在`swift`中，`Int`/`Bool`/`String`/`Array`/`Dictionary`都是值类型。\n* 这些类型只是在简单的赋值的时候，在物理内存上都是同一个东西。\n* 而当发生一个数据改变的时候，他们的内存地址才会发生变化。\n* 值类型在赋值的时候，会将储存其中的值类型一并进行复制，而对其中的引用类型，则只是复制了一份引用。\n\n```\nlet myObject = MyObject()\nlet a = [myObject]\nvar b = a\n\nb.append(myObject)\n\nmyObject.number = 100\n\nprint(b[0].number) //100\nprint(b[1].number) //100\n```\n\n* 处理大量数据并且频繁操作其中的元素的时候，我们需要使用`NSMutableArray`、`NSMutableDictionary`会更好。\n* 对于容器内条目少、容器本身数目多的情况下，我们需要使用`Array`、`Dictionary`\n\n---\n\n* `swift`版本配合`range`的使用：\n\n```\nlet levels = \"ABCDE\"\n\n\nlet nsRange = NSMakeRange(1, 4)\nprint((levels as NSString).replacingCharacters(in: nsRange, with: \"AAAA\"))\n\nlet indexPositionOne = levels.characters.index(levels.startIndex, offsetBy: 1)\nlet swiftRange = indexPositionOne ..< levels.characters.index(levels.startIndex, offsetBy: 5)\n\nprint(levels.replacingCharacters(in: swiftRange, with: \"AAAA\"))\n```\n\n---\n","tags":["Swift"],"categories":["日志"]},{"title":"学习Swift Tips(二)","url":"/2017/09/08/20170908/","content":"\n* 在介绍（Tuple）的时候，说了交换输入的方法书写，在Object-C中，有很多方法，我们传入的是指针，这个问题主要的来源就是因为受制约C语言，单一返回，有了Tuple的时候，我们就可以方便的调用了。\n\n```\nlet rect = CGRect(x: 0, y: 0, width: 100, height: 100)\nlet (small, large) = rect.divided(atDistance: 20, from: .minXEdge)\n```\n\n<!-- more -->\n\n---\n\n* 在写swift的时候，我们常常需要和Optional打交道，这时候我们就需要常常用到解包，这里就提到了一个快速解包的方式`??`,首先看一下如何使用：\n\n```\nvar level: Int?\nvar startLevel = 1\n\nvar currentLevel = level ?? startLevel\n```\n\n* 这里很简单，但是还是要说一下，这里的`??`判断左边的值，如果是非nil的`optional`的值，那就直接返回左边的value值，否则就返回右边的值,但是细细往下看一下源码的定义会发现：\n\n```\npublic func ??<T>(optional: T?, defaultValue: @autoclosure () throws -> T) rethrows -> T\npublic func ??<T>(optional: T?, defaultValue: @autoclosure () throws -> T?) rethrows -> T?\n```\n\n* 看到这里，我就有点疑惑了，这个`??`其实就是一个函数，那么问题来了，`函数的调用方式为什么那么另类呢？`,按照我们的理解，这个函数的调用方式不应该是这样的吗？`??(optional, xxx)`,但是发现这样写，会报错，所以这里我就决定把函数的定义直接copy下来，然后自己去实现，带入如下：\n\n```\nfunc th<T>(_ optional: T?, _ defaultValue: @autoclosure () throws -> T) rethrows -> T {\n    if let optional = optional {\n        return optional\n    }\n    return try defaultValue()\n}\n\n\nvar level: Int?\nvar startLevel = 1\n\nvar test = th(level, startLevel)\n```\n\n* 看到这里我就开始猜测了，这或许是`swift`为了方便的我们的调用，所以它又定义了一个语法糖吧！\n\n---\n\n* @autoclosure 符号的意思，就是直接将：入参T 转化为 ()->T\n\n---\n\n* @escaping 符号的意思就是说明，这个参数是异步的，不是属于这个局部的函数，可以在这个函数执行完成之后再执行这里的回调，不加任何参数的block默认就是同步的，函数执行完成之前，这个block就会被收回。\n\n---\n\n* optional Chaining 如果某个属性是nil的话，会提前返回回来。\n\n---\n\n* 重载符号的做法，用的比较少：\n\n```\nprecedencegroup DotProductPrecedence {\n    associativity: none\n    higherThan: MultiplicationPrecedence\n}\n\ninfix operator +*: DotProductPrecedence\n\nfunc +*(left: Vector2D, right: Vector2D) -> Double {\n    return left.x * right.x + left.y * right.y\n}\n```\n\n---\n\n* 外部传入的参数，如果需要在函数内部修改的话，需要在参数前面加上`inout`，这样传入参数的时候，就需要将之前传入的值改为地址，类似:\n\n```\n func incrementor(variable: inout Int) -> Int {\n        variable += 1\n        return variable\n    }\n```\n\n---\n\n* 字面量的作用，我就觉得很鸡肋，但是还是看一下，说白了，字面量的意思就是说：`可同直接实例化的时候，传入一个String、Int、Bool, 而返回的确实我们自定义的类型`，例如：\n\n```\nclass Person: ExpressibleByStringLiteral {\n\n    let name: String\n\n    init(name value: String) {\n        self.name = value\n    }\n\n    required convenience init(stringLiteral value: String) {\n        self.init(name: value)\n    }\n\n    required convenience init(extendedGraphemeClusterLiteral value: String) {\n        self.init(name: value)\n    }\n\n    required convenience init(unicodeScalarLiteral value: String) {\n        self.init(name: value)\n    }\n\n}\n\n\n let p: Person = \"xiaoming\"\n print(p.name)\n```\n\n---\n\n* 数组下标说实话，还是蛮不错的内容，用的好的话，可以节省很多的时间，通过对下面两个方法写一下拓展，就可以实现自定义的下标功能：\n\n```\n public subscript(index: Int) -> Element\n\n public subscript(bounds: Range<Int>) -> ArraySlice<Element>\n```\n* onvcate 的例子中举出了下面的例子，方便我们通过下标来获取数组的数据：\n\n```\nvar arr = [1,2,3,4,5,6]\nprint(arr[[0,2,3]])\narr[[0,2,3]] = [-1, -3, -4]\nprint(arr)\n\n\nextension Array {\n\n    subscript(input: [Int]) -> ArraySlice<Element> {\n        get{\n            var result = ArraySlice<Element>()\n            for i in input {\n                assert(i < self.count, \"Index out of range\")\n                result.append(self[i])\n            }\n            return result\n        }\n        set{\n            for(index,i) in input.enumerated() {\n                assert(i < self.count, \"Index out of range\")\n                self[i] = newValue[index]\n            }\n        }\n    }\n}\n```\n\n* 下面作者也说了，这个方式调用起来不是很优雅，然后就有了下面的拓展，是我自己写的：\n\n```\nextension Array {\n\n    subscript(first: Int, second: Int, other: Int...) -> ArraySlice<Element> {\n        get{\n            var result = ArraySlice<Element>()\n\n            if first < self.count {\n                result.append(self[first])\n            }\n\n            if second < self.count {\n                result.append(self[second])\n            }\n\n            for i in other {\n                assert(i < self.count, \"Index out of range\")\n                result.append(self[i])\n            }\n\n            return result\n        }\n        set{\n            var tempDatas = other.count > 0 ? other : [Int]()\n            if (first < self.count) {\n                tempDatas.append(first)\n            }\n            if (second < self.count) {\n                tempDatas.append(second)\n            }\n            for(index,i) in tempDatas.enumerated() {\n                assert(i < self.count, \"Index out of range\")\n                self[i] = newValue[index]\n            }\n        }\n    }\n\n}\n\nvar t = [1,2,3,4,5]\nprint( t[0,2,3,4])\nt[0,2,3,4] = [99,99,99,99]\nprint(t)\n\n```\n\n---\n\n* 函数作为一等公民，就是你可以把函数作为参数，返回值，或者可以在函数中定义任意多个函数，这样也可以控制代码的访问权限的问题。\n\n---\n\n* 在不同的target(一个叫`GG`,一个叫`HH`)中，调用同一个类的，同一个方法，例如我们定义了一个`My`的类，里面定义了一个`hello`的类方法:\n\n```\n\nGG.My.hello()\nHH.My.hello()\n\n```\n\n---\n\n* typealias 除了用在给变量、实例、属性定义别名外，还可以用在协议上，我认为这样的用户很大:\n\n\n```\nprotocol Cat {}\nprotocol Dog {}\ntypealias Pat = Cat & Dog\n\nclass ViewController: UIViewController, Pat {}\n```\n\n---\n\n* 如果想对协议添加限定的话，我们就可以定义一个`associatedtype xx`,这样在遵循了协议的时候，就需要制定我们type的类型，这就和之前看官方`Array`定义的效果医院，需要我们制定类型，这样就能够更好的限制遵循协议的对象。\n\n```\nprotocol Animal {\n    associatedtype F\n    func eat(_ food: F)\n}\n\nstruct Meat: Food {}\nstruct Crass: Food {}\n\nstruct Tiger: Animal {\n    typealias F = Meat\n    func eat(_ food: Meat) {\n        print(\"eat \\(food)\")\n    }\n}\n```\n\n* 但是一旦我们这样限制了协议之后，在进行独立判断的时候，我们就不能像之前那样直接进行判断了，例如：\n\n```\nfunc isDangerous(animal: Animal) -> Bool {\n    if animal is Tiger {\n        return true\n    } else {\n        return false\n    }\n}\n```\n\n* 这里错误的原因，是因为我们没有在编译的时候，限制协议中的type类型，在这种情况下，我们只能按照泛型的类型来书写了：\n\n```\nfunc isDangerous<T: Animal>(animal: T) -> Bool {\n    if animal is Tiger {\n        return true\n    }\n    else {\n        return false\n    }\n}\n```\n\n---\n\n* 可变参数的调用，不限制在指定哪个位置，接受可变参数的函数内部，把可变参数看作是对应数据的数组，但是每个函数只能接受一个可变参数，并且可变参数的类型必须是一致的。\n\n---\n\n* 方法的调用顺序问题:\n\n```\nclass Cat {\n    var name: String\n    init() {\n        name = \"cat\"\n    }\n}\n\nclass Tiger: Cat {\n    let power: Int\n    override init() {\n        power = 10\n        super.init()\n        name = \"gh\"\n    }\n}\n```\n\n* 类在初始化的时候，必须要保证该类的所有成员都完成了初始化。\n* 存在继承关系的类，必须要确保当前子类实例的所有成员完成初始化后才会调用父类的初始化。\n* 可以显示的调用`super.init()`，如果不显示的调用的`super.init()`的时候，当我们完成子类的实例化方法的时候，就会自己调用`super.init()`,当然如果存在复写的情况的话，还是需要显示的调用的。\n\n---\n\n* Designated、Convenience、Required 使用注意点：\n\n1. Swift的`init`只能被调用一次，而且是线程安全的，可以对let属性变量进行赋值。\n2. 在`init`前面加了`convenience`的初始化方法必须调用同一个类的`init`的方法。\n3. `convenience`的实例化方法不能被重写，并且也不能够被子类通过`super`的方式调用。\n4. 只要子类重写了`convenience`方法所需的`init`的方法后，子类就可以使用`convenience`的初始化方法。\n5. 当子类含有异于父类的初始化方法时（初始化方法参数类型和数量异于父类），子类必须要实现父类的required初始化方法，并且也要使用required修饰符而不是override。\n6. 当子类没有初始化方法时，可以不用实现父类的required初始化方法。\n\n---\n\n* 对于可以返回nil的初始化方法，我们需要在`init?(xxx)`，加入`?`\n\n---\n\n* 如果想在protocol 里定义一个类型域上的方法或者计算属性，我们需要在定义的时候用`static`进行定义。\n\n---\n\n* 在Swift中的集合类型，在定义中可以看出，我们可以将同一种类型的数据存放在集合中，但是如果类型不同呢？我们应该怎么办呢？\n\n```\n// Any 类型可以隐式转化\nlet mixed: [CustomStringConvertible] = [1, \"two\", false]\n\n// 转化为[NSObject]\nlet objectArray = [1 as NSObject, \"two\" as NSObject, false as NSObject]\n\nlet any = mixed[2]\n\nlet nsObject = objectArray[2]\n```\n\n* 这样存储是没啥问题的，但是也会存在一个问题，那就是可能数据会部分丢失，这其实也是不建议的，因为既然你能存放在同一个集合中，那这些元素，就应该存在一定的共同点。\n\n```\nenum IntOrString {\n    case IntValue(Int)\n    case StringValue(String)\n    case BoolValue(Bool)\n}\n\nlet mixed = [IntOrString.IntValue(1), IntOrString.StringValue(\"two\"), IntOrString.BoolValue(false)]\n```\n\n---\n\n* 默认参数可以在任意的位置:\n\n```\nfunc sayHello1(str1: String = \"Hello\", str2: String, str3: String) {\n    print(str1 + str2 + str3)\n}\n\nfunc sayHello2(str1: String, str2: String, str3: String = \"World\") {\n    print(str1 + str2 + str3)\n}\n\nsayHello1(str2: \" \", str3: \"World\")\nsayHello2(str1: \"Hello\", str2: \" \")\n```\n\n---\n\n* swift 中没有专门的用来正则匹配的东西，但是围绕`NSRegularExpression`也是可以在swift上做一下拓展:\n\n```\n\nstruct RegexHelper {\n    let regex: NSRegularExpression\n\n    init(_ pattern: String) throws {\n        try regex = NSRegularExpression(pattern: pattern, options: .caseInsensitive)\n    }\n\n    func match(_ input: String) -> Bool {\n        let matches = regex.matches(in: input,\n                                    options: [],\n                                    range: NSMakeRange(0, input.utf16.count))\n        return matches.count > 0\n    }\n}\n\n\nlet mailPattern = \"^([a-z0-9\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$\"\n\nlet matcher: RegexHelper\ndo {\n    matcher = try RegexHelper(mailPattern)\n\n    let maybeMailAddress = \"onev@onevcat.com\"\n\n    if matcher.match(maybeMailAddress) {\n        print(\"有效的邮箱地址\")\n    }\n} catch {\n    print(error)\n}\n\n```\n\n---\n\n* `...`(闭区间)和`..<`(开区间)，除了可以生成一个数字类型的范围外，还是可以生成字符串和ASCII编码：\n\n```\nlet interval = \"a\"...\"z\"\nlet xx = \\0...~\n```\n\n---\n\n* 任意的类型有：`Any/AnyObject/AnyClass`, 而 `typealias AnyClass = AnyObject.Type`, `.self`用在类型后面取得类型本身，用在某实例后面表示取得实例本事\n* 通过`AnyObject.Type`获取得到的是一个元类型， 也就是`AnyClass`,这时候我们需要调用`.self`来获取元类。\n\n---\n\n* 在协议中返回值，我们可以返回`Self`,这个类型的意思是，遵循这个协议的类调用这个方法可以返回一个同样遵循该协议并且相同的类：\n\n```\nprotocol Copyable {\n    func copy() -> Self\n}\n\nclass MyClass: Copyable {\n    var num = 1\n\n    func copy() -> Self {\n        let result = type(of: self).init()\n        result.num = num\n        return result\n    }\n\n    required init() {\n\n    }\n}\n```\n\n* 这样书写之后，不管是`MyClass`还是`MyClass`的子类都可以同样适用该协议方法。\n* 并且需要使用`required`来定义初始化方法，确保该类及其子类都能响应这个初始化方法。\n\n---\n\n* swift 是不支持动态派发的，所以他不会根据继承的关系，在运行时改变方法的执行：\n\n```\nclass Pet {}\n\nclass Cat: Pet {}\n\nclass Dog: Pet {}\n\nfunc printPet(_ pet: Pet) {\n    print(\"Pet\")\n}\n\nfunc printPet(_ cat: Cat) {\n    print(\"Meow\")\n}\n\nfunc printPet(_ dog: Dog) {\n    print(\"Bark\")\n}\n\nfunc printThem(_ pet: Pet, _ cat: Cat) {\n    printPet(pet) // Pet\n    printPet(cat) // Meow\n}\n\nprintThem(Dog(), Cat())\n```\n\n* 虽然我这里传入的是`Dog()`的实例，但是在函数内部，我们定义的确实它的父类，所以在实际调用的时候，不管你传入的是什么，在编译的时候，就已经决定了，函数调用的入参是`pet`，如果想要区分的话，只能通过类型的判断去执行：\n\n```\nfunc printThem(_ pet: Pet, _ cat: Cat) {\n    if let aCat = pet as? Cat {\n        printPet(aCat)\n    } else if let aDog = pet as? Dog {\n        printPet(aDog)\n    }\n\n    printPet(cat)\n\n}\n\n```\n\n---\n\n* 属性的监听在`willSet`是将`date`->`newValue`, 而`didSet`是从`oldValue`->`date`。\n* 基本上在同一个类中对同一个属性值，不可能存在`set`/`willSet`/`didSet`, 但是如果复写父类的属性值的时候，我们就可以同时实现三个属性值：\n\n```\nclass A {\n    var number: Int {\n        get {\n            print(\"get\")\n            return 1\n        }\n        set {\n            print(\"set\")\n        }\n    }\n}\n\nclass B: A {\n    override var number: Int {\n        willSet { print(\"willset\") }\n        didSet  { print(\"didSet\") }\n    }\n}\n\n\nlet b = B()\nb.number = 0\n\n// 输出\n// get\n// willSet\n// set\n// didSet\n```\n\n* 这里首先打印`get`,是因为这里实现了`didSet`,在`didSet`中用到了`oldValue`, 而这个值需要在整个set动作之前进行获取并存储代用。\n","tags":["Swift"],"categories":["日志"]},{"title":"学习Masonry Autolayout布局实例","url":"/2017/09/07/20170907/","content":"\n#### 最近看到很多人都在转一篇博客，博客的链接为：[http://tutuge.me/2015/05/23/autolayout-example-with-masonry/], 其实文章的知识点不是很多，重点就是讲如何运用Masonry来实现一些东西，但是不得不承认这篇文章很使用，我在平时开发的时候，很多细节的地方，我也没有注意到，然后看了一下他的四篇博客，记录一下：\n\n* 第一部分重点讲的是两个属性: `Content Compression Resistance`、`Content Hugging`,这里我觉得作者的解释还是形象的：\n\n<!-- more -->\n\n```\nContent Compression Resistance = 不许挤我\n值越高，内容越不容易被压缩\n当内容放不下的时候，优先挤压那些优先级低的元素\n\nContent Hugging = 抱紧\n子元素设置的属性值越高，子元素越不会随着父视图的变化而变化\n\n//设置label1的content hugging 为1000\n[_label1 setContentHuggingPriority:UILayoutPriorityRequired\n                               forAxis:UILayoutConstraintAxisHorizontal];\n\n//设置label1的content compression 为1000\n[_label1 setContentCompressionResistancePriority:UILayoutPriorityRequired\n                                             forAxis:UILayoutConstraintAxisHorizontal];\n```\n\n* 居中显示四个元素:\n\n```\n   UIView __block *lastView = nil;\n    MASConstraint __block *widthConstraint = nil;\n    NSUInteger arrayCount = _imageViews.count;\n    [_imageViews enumerateObjectsUsingBlock:^(UIView *view, NSUInteger idx, BOOL *stop) {\n        [view mas_makeConstraints:^(MASConstraintMaker *make) {\n            //宽高固定\n            widthConstraint = make.width.equalTo(@(imageViewSize.width));\n            make.height.equalTo(@(imageViewSize.height));\n            //左边约束\n            make.left.equalTo(lastView ? lastView.mas_right : view.superview.mas_left);\n            //垂直中心对齐\n            make.centerY.equalTo(view.superview.mas_centerY);\n            //设置最右边的imageView的右边与父view的最有对齐\n            if (idx == arrayCount - 1) {\n                make.right.equalTo(view.superview.mas_right);\n            }\n\n            [_widthConstraints addObject:widthConstraint];\n            lastView = view;\n        }];\n    }];\n\n    ...\n\n    // 隐藏元素的时候，就可以直接来修改约束\n\n        if (sender.on) {\n        width.equalTo(@(IMAGE_SIZE));\n    } else {\n        width.equalTo(@0);\n    }\n```\n\n* a视图是b视图的倍数关系的：\n\n```\nmake.width.equalTo(_containerView.mas_width).multipliedBy(0.5);\n```\n\n* `UITableViewCell`高度的问题：\n\n* 首先如果是在`iOS8以及以后的版本的话`，那就不需要考虑这个问题了，直接使用新特性\n\n```\n_tableView.estimatedRowHeight = 80.0f;\n\n...\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n\n\n#ifdef IOS_8_NEW_FEATURE_SELF_SIZING\n    // iOS 8 的Self-sizing特性\n    return UITableViewAutomaticDimension;\n}\n```\n\n * 如果是在旧版本`iOS7上的话`:\n\n\n ```\n // 根据当前数据，计算Cell的高度，注意+1\ndataEntity.cellHeight = [_templateCell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height + 0.5f;\n\n\n    // 计算UILabel的preferredMaxLayoutWidth值，多行时必须设置这个值，否则系统无法决定Label的宽度\n    CGFloat preferredMaxWidth = [UIScreen mainScreen].bounds.size.width - 44 - 4 * 3; // 44 = avatar宽度，4 * 3为padding\n\n    // Content - 多行\n    _contentLabel.preferredMaxLayoutWidth = preferredMaxWidth; // 多行时必须设置\n\n ```\n\n * 为了避免在转屏的时候，Header、Bottom差一截的问题，这里我们头，尾视图不需要根据父视图来设定约束，而是根据`topLayoutGuide`、`bottomLayoutGuide`来设定:\n\n ```\n     [_topView mas_updateConstraints:^(MASConstraintMaker *make) {\n        // 直接利用其length属性，避免iOS、SDK版本升级后topLayoutGuide不再是UIView\n        make.top.equalTo(self.view.mas_top).with.offset(self.topLayoutGuide.length);\n    }];\n\n    // 根据新的length值更新约束\n    [_bottomView mas_updateConstraints:^(MASConstraintMaker *make) {\n        // 直接利用其length属性，避免iOS、SDK版本升级后topLayoutGuide不再是UIView\n        make.bottom.equalTo(self.view.mas_bottom).with.offset(-(self.bottomLayoutGuide.length));\n    }];\n ```\n\n * 自定义`baseline`的属性值：\n\n ```\n // 返回自定义的baseline的view\n- (UIView *)viewForBaselineLayout {\n    return _baseView;\n}\n ```\n\n * 可拉伸的`UITableView`\n\n ```\n _tableView.contentInset = UIEdgeInsetsMake(ParallaxHeaderHeight, 0, 0, 0);\n\n ...\n\n - (void)initView {\n    _parallaxHeaderView = [UIImageView new];\n    [self.view insertSubview:_parallaxHeaderView belowSubview:_tableView];\n    _parallaxHeaderView.contentMode = UIViewContentModeScaleAspectFill;\n    _parallaxHeaderView.image = [UIImage imageNamed:@\"parallax_header_back\"];\n\n    [_parallaxHeaderView mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.left.and.right.equalTo(self.view);\n        make.top.equalTo(self.mas_topLayoutGuideBottom);\n        _parallaxHeaderHeightConstraint = make.height.equalTo(@(ParallaxHeaderHeight));\n    }];\n\n    // Add KVO\n    [_tableView addObserver:self forKeyPath:@\"contentOffset\" options:NSKeyValueObservingOptionNew context:nil];\n}\n\n ```\n\n* KVO的回调\n\n```\n// 方法2：利用KVO\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object\n                        change:(NSDictionary<NSString *,id> *)change\n                       context:(void *)context {\n    if ([keyPath isEqualToString:@\"contentOffset\"]) {\n        CGPoint contentOffset = ((NSValue *)change[NSKeyValueChangeNewKey]).CGPointValue;\n        if (contentOffset.y < -ParallaxHeaderHeight) {\n            _parallaxHeaderHeightConstraint.equalTo(@(-contentOffset.y));\n        }\n    }\n}\n\n```\n","tags":["Object-C"],"categories":["日志"]},{"title":"学习Swift Tips","url":"/2017/09/01/20170901/","content":"\n### onvcate的《Swift开发者必备的Tips》之前刚出的时候，我就翻阅过，后来Swift的版本一直在改，我也就懒得去看了,现在Swift的ABI基本都稳定了，我在回顾复习一下这本书，记录一下要点：\n\n#### 协议中的read-only的属性值：\n\n* 在protocol中给在方法前面添加`mutating`，可以修改`Struct`、`Enum`中的属性值, 在`Class`中本来就可以修改，所以可以直接忽视`mutating`。\n* 首先我们来想一下，怎么在`protocol`中定义一个只读的属性值:\n\n<!-- more -->\n\n```\nprotocol Vehicle {\n    var number: Int { get }\n}\n\nstruct MyCar: Vehicle {\n    var number: Int\n}\n\nvar car = MyCar(number: 3)\ncar.number\n\ncar.number = 10\n\ncar.number\n```\n* 当我写完这段代码的时候，我发现，我定义的只读属性`number`,但是这里为什么？我还可以设置呢？我google了一下：[https://stackoverflow.com/questions/31358518/read-only-properties-of-protocols-in-swift]\n\n> There's no way to specify in a protocol that you must have a read-only property. Your protocol asks for a car.number property, and allows but does not require a setter.\n\n* 这里我的理解就是，当你实例化一个`car`的对象，并且调用car.xxx某个属性值的时候，你并没有限制他的xxx属性值是只读的。所以我们只需要修改car的那行代码：\n\n```\nvar car: Vehicle = MyCar(number: 3)\n\ncar.number\n\ncar.number = 10 // error:  'number' is a get-only property\n\ncar.number\n```\n\n---\n\n* 那么我现在在协议中定义一个新的方法，这个方法做什么呢？就是修改协议里面的变量值，代码如下：\n\n```\nprotocol Vehicle {\n    var number: Int { get }\n\n    mutating func changeNumber()\n}\n\nstruct MyCar: Vehicle {\n\n    var number: Int\n\n    mutating func changeNumber() {\n        number = 99\n    }\n}\n\nvar car: Vehicle = MyCar(number: 12)\n\ncar.number\n\ncar.changeNumber()\n\ncar.number\n```\n\n* 惊奇的发现，居然可以修改这个只读的属性值了？？我又懵逼了。查看了官方的`Demo`[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html]\n* 这里的属性值我只是简单的定义了下，没有通过computed value来定义值，按照官方的demo，我们直接修改代码如下：\n\n```\nprotocol Vehicle {\n    var number: Int { get }\n\n    mutating func changeNumber()\n}\n\nstruct MyCar: Vehicle {\n\n    var customInt: Int\n\n    var number: Int {\n        get {\n            return customInt\n        }\n    }\n\n    mutating func changeNumber() {\n//        number = 99\n    }\n}\n\nvar car: Vehicle = MyCar(customInt: 12)\n\ncar.number\n\ncar.changeNumber()\n\ncar.number\n```\n\n* 这样一旦我调用ChangeNumber的方法的时候，你就会发现报错了。\n\n---\n\n\n* 下面说了`for in`的使用，大家应该都知道，`for in`的循环，我们都可以使用在集合类型的上面，但是在swift中我其实是可以将`for in`用在我们自定义的类型上面。在Apple的官方文档上也给了一个说明：[https://developer.apple.com/documentation/swift/iteratorprotocol]\n* 首先能使用`for in`来枚举的对象，必须遵循`Sequence`,看里面的源码会发现里面除了很多的方法就只剩两个属性值的设置：\n\n```\n   /// A type that provides the sequence's iteration interface and\n    /// encapsulates its iteration state.\n    associatedtype Iterator : IteratorProtocol\n\n    /// A type that represents a subsequence of some of the sequence's elements.\n    associatedtype SubSequence\n\n        /// Returns an iterator over the elements of this sequence.\n    public func makeIterator() -> Self.Iterator\n```\n\n* 按照官方的意思，我们这里其他不需要去实现，这里就实现了一个`public func makeIterator() -> Self.Iterator`这个方法，可以看出这个方法返回的是一个迭代器，而这个迭代器必须要实现`IteratorProtocol`的协议：\n\n```\npublic protocol IteratorProtocol {\n\n    /// The type of element traversed by the iterator.\n    associatedtype Element\n\n    /// Advances to the next element and returns it, or `nil` if no next element\n    /// exists.\n    ///\n    /// Repeatedly calling this method returns, in order, all the elements of the\n    /// underlying sequence. As soon as the sequence has run out of elements, all\n    /// subsequent calls return `nil`.\n    ///\n    /// You must not call this method if any other copy of this iterator has been\n    /// advanced with a call to its `next()` method.\n    ///\n    /// The following example shows how an iterator can be used explicitly to\n    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and\n    /// then call the iterator's `next()` method until it returns `nil`.\n    ///\n    ///     let numbers = [2, 3, 5, 7]\n    ///     var numbersIterator = numbers.makeIterator()\n    ///\n    ///     while let num = numbersIterator.next() {\n    ///         print(num)\n    ///     }\n    ///     // Prints \"2\"\n    ///     // Prints \"3\"\n    ///     // Prints \"5\"\n    ///     // Prints \"7\"\n    ///\n    /// - Returns: The next element in the underlying sequence, if a next element\n    ///   exists; otherwise, `nil`.\n    public mutating func next() -> Self.Element?\n}\n```\n\n* 上面的注释也说明了一些，这里其实就是一个`迭代器模式`，不断的调用next()的方法，知道返回nil，官方的例子上面没有用到`Element`,就只是将返回的类型定义为`Int?`,只是用了`next`的方法：\n* 并且之前我们也看到了`CountdownIterator`的实例化方法，将自己这个结构体传入了进去,所以这里就定义了一个内部变量`countdown`:\n\n```\nstruct Coundown: Sequence {\n\n    let start: Int\n\n    func makeIterator() -> CoundownIterator {\n        return CoundownIterator(self)\n    }\n\n}\n\nstruct CoundownIterator: IteratorProtocol {\n\n    let countdown: Coundown\n    var times = 0\n\n    init(_ countdown: Coundown) {\n        self.countdown = countdown\n    }\n\n    mutating func next() -> Int? {\n\n        let nextNumber = countdown.start - times\n        guard nextNumber > 0 else { return nil }\n\n        times += 1\n        return nextNumber\n\n    }\n\n}\n\nlet threeTwoOne = Coundown(start: 3)\nfor count in threeTwoOne {\n    print(\"\\(count)...\")\n}\n```\n\n* 上面的例子还是通俗易懂的，但是唯一的缺点就是有些属性没用，可能他觉得没必要吧，看一下onevcate的例子：\n\n```\nimport UIKit\n\nstruct ReverseSequence<T>: Sequence {\n\n    var array: [T]\n\n    init(array: [T]) {\n        self.array = array\n    }\n\n    typealias Iterator = ReverseItrator<T>\n\n    func makeIterator() -> ReverseItrator<T> {\n        return ReverseItrator(array: self.array)\n    }\n\n}\n\nstruct ReverseItrator<T>: IteratorProtocol {\n\n    typealias Element = T\n\n    var array: [Element]\n    var currentIndex = 0\n\n    init(array: [T]) {\n        self.array = array\n        currentIndex = array.count - 1\n    }\n\n    mutating func next() -> T? {\n        if currentIndex < 0 {\n            return nil\n        } else {\n            let element = self.array[currentIndex]\n            currentIndex -= 1\n            return element\n        }\n    }\n}\n\nlet arr = [0,1,2,3,4]\n\nfor i in ReverseSequence(array: arr) {\n    print(\"Index: \\(i) is \\(arr[i])\")\n}\n```\n\n* 其实这里会发现`typealias Iterator = ReverseItrator<T>`, `typealias Element = T`写了这些之后，相应协议中的返回值就是自动生成，但是如果你想代码简洁，其实可以忽略这些属性值，直接设置也是可以的。\n","tags":["Swift"],"categories":["日志"]},{"title":"学习YYText(一)","url":"/2017/08/30/20170830/","content":"\n#### YY系列的很多代码都写的很棒，最近很多地方都用到富文本，所以决定用`YYText`,用之前看了一下里面的代码，觉得还是有很多地方要学习的。代码量非常大，所以可能要分几篇博客分别去写，简单的逻辑就不写了。\n\n* 看`demo`里面，第一行的代码，关于的测试部分就写的很简单，但是深究下去，还是有很多值得学习的地方的：\n\n```\n// 这里的self只是一个传入的ViewController的实例\n[YYTextExampleHelper addDebugOptionToViewController:self];\n```\n\n<!-- more -->\n\n* 这里传入的vc只是用来设置navigationItem的，这里是设置的一个UISwicher的UI控件，这里存在一个方法：\n\n```\n  [switcher addBlockForControlEvents:UIControlEventValueChanged block:^(UISwitch *sender) {\n        [self setDebug:sender.isOn];\n    }];\n```\n\n* 仔细一看就会发现问题，UISwich的实例变量可以直接调用`addBlockForControlEvents`的方法，传入了`Event`和`block`:\n\n```\n@implementation UIControl (YYAdd)\n\n...\n\n- (void)addBlockForControlEvents:(UIControlEvents)controlEvents\n                           block:(void (^)(id sender))block {\n    _YYUIControlBlockTarget *target = [[_YYUIControlBlockTarget alloc]\n                                       initWithBlock:block events:controlEvents];\n    [self addTarget:target action:@selector(invoke:) forControlEvents:controlEvents];\n    NSMutableArray *targets = [self _yy_allUIControlBlockTargets];\n    [targets addObject:target];\n}\n\n...\n\n- (NSMutableArray *)_yy_allUIControlBlockTargets {\n    NSMutableArray *targets = objc_getAssociatedObject(self, &block_key);\n    if (!targets) {\n        targets = [NSMutableArray array];\n        objc_setAssociatedObject(self, &block_key, targets, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    }\n    return targets;\n}\n\n...\n\n@interface _YYUIControlBlockTarget : NSObject\n\n@property (nonatomic, copy) void (^block)(id sender);\n@property (nonatomic, assign) UIControlEvents events;\n\n- (id)initWithBlock:(void (^)(id sender))block events:(UIControlEvents)events;\n- (void)invoke:(id)sender;\n\n@end\n\n@implementation _YYUIControlBlockTarget\n\n- (id)initWithBlock:(void (^)(id sender))block events:(UIControlEvents)events {\n    self = [super init];\n    if (self) {\n        _block = [block copy];\n        _events = events;\n    }\n    return self;\n}\n\n- (void)invoke:(id)sender {\n    if (_block) _block(sender);\n}\n\n@end\n\n...\n\n\n\n@end\n\n```\n\n* 这里点到源码里面可以看到，YY作者写了一个`UIControl`的category，来作了拓展，提供了`addBlockForControlEvents`这个方法，这也就解释了上面可以调用这个方法。\n* 发现作者拿到`UIControlEvents`和`block`，直接生成了一个`_YYUIControlBlockTarget`实例。发现生成的这个实例，也做什么特别的事情，就是把block copy保存下来，events也保存下来。\n* 然后它还是调用了系统的`addTarget:action:forControlEvents`，直接调用`invoke:`的方法，其实就是调用了我传入进来的`block`。\n* 下面可以看到作者通过`runtime`给这个category生成了一个`NSMutableArry`的属性值，并且把我的target对象保存起来。\n* 其实通过看源码就可以发现作者这么写这个category，就做了两件事情，第一可以用block, 第二可以方便直接remove掉相关对象上事件。\n\n\n----\n\n\n* 在事件成功触发的时候，就会调用下面的方法：\n\n```\n+ (void)setDebug:(BOOL)debug {\n    YYTextDebugOption *debugOptions = [YYTextDebugOption new];\n    if (debug) {\n        debugOptions.baselineColor = [UIColor redColor];\n        debugOptions.CTFrameBorderColor = [UIColor redColor];\n        debugOptions.CTLineFillColor = [UIColor colorWithRed:0.000 green:0.463 blue:1.000 alpha:0.180];\n        debugOptions.CGGlyphBorderColor = [UIColor colorWithRed:1.000 green:0.524 blue:0.000 alpha:0.200];\n    } else {\n        [debugOptions clear];\n    }\n    [YYTextDebugOption setSharedDebugOption:debugOptions];\n    DebugEnabled = debug;\n}\n\n...\n\n@interface YYTextDebugOption : NSObject <NSCopying>\n\n/**\n Set a debug option as shared debug option.\n This method must be called on main thread.\n\n @discussion When call this method, the new option will set to all debug target\n which is added by `addDebugTarget:`.\n\n @param option  A new debug option (nil is valid).\n */\n+ (void)setSharedDebugOption:(nullable YYTextDebugOption *)option;\n\n...\n\n```\n\n* 在这个类方法中主要涉及到的一个对象为`YYTextDebugOption`,这个对象只是一个继承自NSObject的对象，这里没毛病。\n* 生成实例对象之后，我们需要设置不同的值，然后还是通过自己的类方法，将上面的生成的这个对象通过参数出入进去。\n\n* 在`YYTextDebugOption`里面：\n\n```\n...\n+ (void)setSharedDebugOption:(YYTextDebugOption *)option {\n    NSAssert([NSThread isMainThread], @\"This method must be called on the main thread\");\n    _setSharedDebugOption(option);\n}\n...\n\nstatic void _setSharedDebugOption(YYTextDebugOption *option) {\n    _initSharedDebug();\n    pthread_mutex_lock(&_sharedDebugLock);\n    _sharedDebugOption = option.copy;\n    CFSetApplyFunction(_sharedDebugTargets, _sharedDebugSetFunction, NULL);\n    pthread_mutex_unlock(&_sharedDebugLock);\n}\n\n....\n\nstatic void _initSharedDebug() {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        pthread_mutex_init(&_sharedDebugLock, NULL);\n        CFSetCallBacks callbacks = kCFTypeSetCallBacks;\n        callbacks.retain = _sharedDebugSetRetain;\n        callbacks.release = _sharedDebugSetRelease;\n        _sharedDebugTargets = CFSetCreateMutable(CFAllocatorGetDefault(), 0, &callbacks);\n    });\n}\n\n```\n\n\n* 这里首页确保了设置的的时候，必须是要主线程去调用，其实这里这样写，和后面通过锁来存储对象效果是一致的。\n* 这里发现作者都是些的c函数，这里我不太确定，为什么不用oc呢？\n* 这里作者写了一个单例，并且初始化了`pthread_mutex_init(&_sharedDebugLock, NULL);`锁的值\n\n```\n\n//1：pthread_mutex_init(pthread_mutex_t * mutex,const pthread_mutexattr_t *attr);\n初始化锁变量mutex。attr为锁属性，NULL值为默认属性。\n//2：pthread_mutex_lock(pthread_mutex_t *mutex);加锁\n//3：pthread_mutex_tylock(pthread_mutex_t *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。\n//4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁\n//5：pthread_mutex_destroy(pthread_mutex_t *mutex);使用完后释放\n\n...\n__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)\nint pthread_mutex_init(pthread_mutex_t * __restrict,\n\t\tconst pthread_mutexattr_t * _Nullable __restrict);\n...\n\n```\n* 看代码可以发现，这里需要传入两个值，第一个值是用来表示这个锁的标记，同样第二只默认为Null\n\n```\n     CFSetCallBacks callbacks = kCFTypeSetCallBacks;\n        callbacks.retain = _sharedDebugSetRetain;\n        callbacks.release = _sharedDebugSetRelease;\n        _sharedDebugTargets = CFSetCreateMutable(CFAllocatorGetDefault(), 0, &callbacks);\n```\n\n* 这里的几行代码，其实是通过c的方法是，来生成一个容器属性，类似`NSArray,NSDictionary,NSSet`,通过源码就可以发现其实就是一个结构体，结构体里面定义的属性值，就是我们需要定义这个容器变量的值，可以猜出来，`release`/`retain`是设置对象的内存管理的，`equal`/`hash`是对象存储的方式，当然啦，通过c生成的函数，我们可以转化为`Foundation`的属性值,可以通过类似这样的方式来生成` return (NSMutableSet *)CFBridgingRelease(CFSetCreateMutable(0, 0, &callbacks));`\n\n```\ntypedef struct {\n    CFIndex\t\t\t\tversion;\n    CFSetRetainCallBack\t\t\tretain;\n    CFSetReleaseCallBack\t\trelease;\n    CFSetCopyDescriptionCallBack\tcopyDescription;\n    CFSetEqualCallBack\t\t\tequal;\n    CFSetHashCallBack\t\t\thash;\n} CFSetCallBacks;\n```\n* 通过代码可以看出来，其实作者就是想保证，始终只有一个`YYTextDebugOption *option`的存在。通过获取这个`option`的值，就知道你的设置了。\n\n---\n\n* 关键设置`Text`的相关代码：\n\n```\n NSMutableAttributedString *text = [NSMutableAttributedString new];\n\n    {\n        NSMutableAttributedString *one = [[NSMutableAttributedString alloc] initWithString:@\"Shadow\"];\n        one.yy_font = [UIFont boldSystemFontOfSize:30];\n        one.yy_color = [UIColor whiteColor];\n        YYTextShadow *shadow = [YYTextShadow new];\n        shadow.color = [UIColor colorWithWhite:0.000 alpha:0.490];\n        shadow.offset = CGSizeMake(0, 1);\n        shadow.radius = 5;\n        one.yy_textShadow = shadow;\n        [text appendAttributedString:one];\n        [text appendAttributedString:[self padding]];\n    }\n```\n\n* 这里设置`yy_font`、`yy_color`的时候，用法和我们之前设置label的属性设置一模一样，这里点进去可以发现，这里是因为作者写了一个`NSMutableAttributedString`的一个`category`，和之前的做法一样,在setter值的时候，作者覆写了setter的值方法，统一都调用了一个同一个的方法：\n\n```\n...\n- (void)yy_setFont:(UIFont *)font range:(NSRange)range {\n    /*\n     In iOS7 and later, UIFont is toll-free bridged to CTFontRef,\n     although Apple does not mention it in documentation.\n\n     In iOS6, UIFont is a wrapper for CTFontRef, so CoreText can alse use UIfont,\n     but UILabel/UITextView cannot use CTFontRef.\n\n     We use UIFont for both CoreText and UIKit.\n     */\n    [self yy_setAttribute:NSFontAttributeName value:font range:range];\n}\n\n...\n\n- (void)yy_setColor:(UIColor *)color range:(NSRange)range {\n    [self yy_setAttribute:(id)kCTForegroundColorAttributeName value:(id)color.CGColor range:range];\n    [self yy_setAttribute:NSForegroundColorAttributeName value:color range:range];\n}\n\n\n...\n\n- (void)yy_setAttribute:(NSString *)name value:(id)value range:(NSRange)range {\n    if (!name || [NSNull isEqual:name]) return;\n    if (value && ![NSNull isEqual:value]) [self addAttribute:name value:value range:range];\n    else [self removeAttribute:name range:range];\n}\n\n...\n```\n\n* 这里其实已经很明显了，所有的设置属性的时候，都是调用的这个方法，如果存在这个值，就设置上去，没有，就去除掉。\n* 这里在设置颜色的时候，连着设置了两个属性，我查了一下，但是网上都没有说的很清楚，应该是`就是为了某些版本的兼容问题的吧，看一下matt大神的解释吧：` [https://github.com/TTTAttributedLabel/TTTAttributedLabel/pull/416]\n\n\n> Unfortunately, this patch appears to actually degrade support for iOS 8, as NS text attributes do not seem to apply in Core Text rendering for whatever reason.\n\n> As inconvenient as they are, everything works in iOS 4 – 8 if kCT. Am I missing something? This feels like more of a \"if it ain't broke, don't fix it\" type of situation...\n\n\n* 关键这里的shadow让人看的很懵逼，因为看代码就可以知道，作者这里自定义了一个继承了`NSObject`的`Shadow`对象` YYTextShadow *shadow = [YYTextShadow new];`,同样它和设置font，color一样，都是最终调用到了`- (void)yy_setAttribute:(NSString *)name value:(id)value range:(NSRange)range {}`,**前面我好理解，他都是设置的系统的设置，所以你不管设置font，color其实最终都是走到系统的设置上去了，但是这里设置的对象，key都是自定义的，这里系统是怎么认识的呢？开始看到这里的时候，我就有点不是很理解了，但是当我看到下面的时候我就明白了。**\n\n```\n   YYLabel *label = [YYLabel new];\n    label.attributedText = text;\n    label.width = self.view.width;\n    label.height = self.view.height - (kiOS7Later ? 64 : 44);\n    label.top = (kiOS7Later ? 64 : 0);\n    label.textAlignment = NSTextAlignmentCenter;\n    label.textVerticalAlignment = YYTextVerticalAlignmentCenter;\n    label.numberOfLines = 0;\n    label.backgroundColor = [UIColor colorWithWhite:0.933 alpha:1.000];\n    [self.view addSubview:label];\n```\n\n* 首先这里定义一个新的属性值，叫做`YYLabel`,点进去可以发现，这个`YYLabel`的对象继承的是`UIView`的,这里作者要做的应该就是写一个变化的`UILabel`:\n\n```\n/**\n The YYLabel class implements a read-only text view.\n\n @discussion The API and behavior is similar to UILabel, but provides more features:\n\n * It supports asynchronous layout and rendering (to avoid blocking UI thread).\n * It extends the CoreText attributes to support more text effects.\n * It allows to add UIImage, UIView and CALayer as text attachments.\n * It allows to add 'highlight' link to some range of text to allow user interact with.\n * It allows to add container path and exclusion paths to control text container's shape.\n * It supports vertical form layout to display CJK text.\n\n See NSAttributedString+YYText.h for more convenience methods to set the attributes.\n See YYTextAttribute.h and YYTextLayout.h for more information.\n */\n@interface YYLabel : UIView <NSCoding>\n```\n* 可以看到YYLabel除了UILabel提供的那些东西外，我们还提供很多牛逼的功能，这些动能的实现，我还没有看，先来看看之前我们设置的`NSMutableAttributedString`是如何生效的？\n* 在第二行代码，我们直接将我们前面设置的text属性值进行设定`label.attributedText = text;`:\n\n```\n- (void)setAttributedText:(NSAttributedString *)attributedText {\n    if (attributedText.length > 0) {\n        _innerText = attributedText.mutableCopy;\n        switch (_lineBreakMode) {\n            case NSLineBreakByWordWrapping:\n            case NSLineBreakByCharWrapping:\n            case NSLineBreakByClipping: {\n                _innerText.yy_lineBreakMode = _lineBreakMode;\n            } break;\n            case NSLineBreakByTruncatingHead:\n            case NSLineBreakByTruncatingTail:\n            case NSLineBreakByTruncatingMiddle: {\n                _innerText.yy_lineBreakMode = NSLineBreakByWordWrapping;\n            } break;\n            default: break;\n        }\n    } else {\n        _innerText = [NSMutableAttributedString new];\n    }\n    [_textParser parseText:_innerText selectedRange:NULL];\n    if (!_ignoreCommonProperties) {\n        if (_displaysAsynchronously && _clearContentsBeforeAsynchronouslyDisplay) {\n            [self _clearContents];\n        }\n        [self _updateOuterTextProperties];\n        [self _setLayoutNeedUpdate];\n        [self _endTouch];\n        [self invalidateIntrinsicContentSize];\n    }\n}\n\n```\n\n* 这里的代码应该就是解析我们之前设置的`NSAttributedString`属性。\n* 按照代码，先判断_lineBreakMode，然后给`NSAttributedString`设置`yy_lineBreakMode`的值。\n* `[_textParser parseText:_innerText selectedRange:NULL];`这个是一个代理方法，但是我现在我这里的`_textParser`是`nil`,那也就不会调用这个代理方法，从函数名字上可以知道，这里的函数主要做的上就是去解析某个`Text`。\n* 调用`[self _updateOuterTextProperties];`\n\n\n```\n- (void)_updateOuterTextProperties {\n    _text = [_innerText yy_plainTextForRange:NSMakeRange(0, _innerText.length)];\n    _font = _innerText.yy_font;\n    if (!_font) _font = [self _defaultFont];\n    _textColor = _innerText.yy_color;\n    if (!_textColor) _textColor = [UIColor blackColor];\n    _textAlignment = _innerText.yy_alignment;\n    _lineBreakMode = _innerText.yy_lineBreakMode;\n    NSShadow *shadow = _innerText.yy_shadow;\n    _shadowColor = shadow.shadowColor;\n#if !TARGET_INTERFACE_BUILDER\n    _shadowOffset = shadow.shadowOffset;\n#else\n    _shadowOffset = CGPointMake(shadow.shadowOffset.width, shadow.shadowOffset.height);\n#endif\n\n    _shadowBlurRadius = shadow.shadowBlurRadius;\n    _attributedText = _innerText;\n    [self _updateOuterLineBreakMode];\n}\n```\n\n* 从上面的代码的逻辑中我们可以看出，这个函数主要做的事情就是讲我们前面传入进来的`NSAttributedString`一个个取出来\n* `- (NSString *)yy_plainTextForRange:(NSRange)range {}`这个函数的主要是从`NSAttributedString`中取出Text的值，复制给一个全局的text的值，看一下这里的实现：\n\n```\n- (NSString *)yy_plainTextForRange:(NSRange)range {\n    if (range.location == NSNotFound ||range.length == NSNotFound) return nil;\n    NSMutableString *result = [NSMutableString string];\n    if (range.length == 0) return result;\n    NSString *string = self.string;\n    [self enumerateAttribute:YYTextBackedStringAttributeName inRange:range options:kNilOptions usingBlock:^(id value, NSRange range, BOOL *stop) {\n        YYTextBackedString *backed = value;\n        if (backed && backed.string) {\n            [result appendString:backed.string];\n        } else {\n            [result appendString:[string substringWithRange:range]];\n        }\n    }];\n    return result;\n}\n```\n\n* 这里他枚举了`NSAttributedString`的属性值，如果前面设置过`YYTextBackedStringAttributeName`,这里它会进行拼接，但是我们前面没有设置这个属性，所以，这个枚举出的`value = nil`。可以通过这里的枚举方法，我们就可以枚举出我们想要`attribute`值，并进行修改：\n\n```\nNSMutableAttributedString *res = [self.richTextEditor.attributedText mutableCopy];\n\n[res beginEditing];\n__block BOOL found = NO;\n[res enumerateAttribute:NSFontAttributeName inRange:NSMakeRange(0, res.length) options:0 usingBlock:^(id value, NSRange range, BOOL *stop) {\n    if (value) {\n        UIFont *oldFont = (UIFont *)value;\n        UIFont *newFont = [oldFont fontWithSize:oldFont.pointSize * 2];\n        [res removeAttribute:NSFontAttributeName range:range];\n        [res addAttribute:NSFontAttributeName value:newFont range:range];\n        found = YES;\n    }\n}];\nif (!found) {\n    // No font was found - do something else?\n}\n[res endEditing];\nself.richTextEditor.attributedText = res;\n```\n\n* 下面就是简单的对全局的值进行赋值,看到这里，就可以稍微明白了之前的自定义设置Shadow的问题了：`NSShadow *shadow = _innerText.yy_shadow;`,然后将shadow的值进行赋值：\n\n```\n   _shadowColor = shadow.shadowColor;\n#if !TARGET_INTERFACE_BUILDER\n    _shadowOffset = shadow.shadowOffset;\n#else\n    _shadowOffset = CGPointMake(shadow.shadowOffset.width, shadow.shadowOffset.height);\n#endif\n\n    _shadowBlurRadius = shadow.shadowBlurRadius;\n```\n\n* 最后又设置了一下`- (void)_updateOuterLineBreakMode {}`代码如下：\n\n```\n- (void)_updateOuterLineBreakMode {\n    if (_innerContainer.truncationType) {\n        switch (_innerContainer.truncationType) {\n            case YYTextTruncationTypeStart: {\n                _lineBreakMode = NSLineBreakByTruncatingHead;\n            } break;\n            case YYTextTruncationTypeEnd: {\n                _lineBreakMode = NSLineBreakByTruncatingTail;\n            } break;\n            case YYTextTruncationTypeMiddle: {\n                _lineBreakMode = NSLineBreakByTruncatingMiddle;\n            } break;\n            default:break;\n        }\n    } else {\n        _lineBreakMode = _innerText.yy_lineBreakMode;\n    }\n}\n```\n\n* 这里又设计到了一下新的对象`YYTextContainer *_innerContainer;`,这里我目前没用到这个值，所以暂且先忽略它。\n* 下面调用了新的方法`- (void)_setLayoutNeedUpdate {}`,这个方法设置了一个属性值，然后调用`- (void)_clearInnerLayout {}`由于这里我们没有设置值，所以直接return掉了，最后调用了一下`    [self.layer setNeedsDisplay];`\n* 在最后的最后调用了`[self invalidateIntrinsicContentSize];`,这个函数的调用我之前也没有用过，但是看解释应该可以猜出一部分：\n\n> call this when something changes that affects the intrinsicContentSize.  Otherwise UIKit won't notice that it changed.\n> 我的猜测是当父视图的发生变化的时候，我们需要调用这个方法来通知子视图也发生了变化。\n\n\n#### 到目前为止外面只了解完了最最基础的那个函数调用，设置shadow，textcolor，font，足以看出这个yyText的强大了。\n\n\n\n\n\n---\n* 网上找了些资料，大部分都没有说清楚，能说清楚下面两篇文章：可以看看 : [http://www.jianshu.com/p/f0c33d6c39bb, http://blog.csdn.net/wypblog/article/details/7264315]\n","tags":["Swift"],"categories":["日志"]},{"title":"Core Data的迁移和合并(五)","url":"/2017/08/22/20170822/","content":"\n#### 记得在两年前我去面试的时候，面试官关于Core data的问题，他们大都只会问你一个问题，基本上你只要能够答出来，就说明还是使用过Core Data，这个问题就是：“如何迁移Core Data的数据库”？因为谁都无法预料业务的发展，以及数据库的修改，所以这个问题也是必然会发生的。这里重点列举几个Core Data数据库迁移的问题：\n\n* **首先要说一下，如果你的App，只是缓存一些离线数据的话，就没必要考虑什么数据库迁移了，因为你只需要在新版本中，删除之前的core data数据，新建一个就可以了**\n\n<!-- more -->\n\n---\n\n* 只是在原有的Entity中添加几个字段,步骤如下：\n\n1. 点击`Editor->Add Model Version`.\n2. 命名新版本的文字就啥：`xxx v2`.\n3. 如果你有多个Core Data的项目，需要勾选你想要修改的Core Data项目的名字.\n4. 点击创建完成.\n5. 点击`File Inspector`,在Model Version中勾选你刚才创建的新的Model.\n6. 此时我们就可以勾选进我们新建的Core Data Entity的字段创建表中去，创建你想要修改的字段.\n7. 此时你就可以去想要的xxx.swift的Model Template 的文件中去添加字段了，例如：`@NSManaged var image: UIImage?`\n8. 此时你就可以像使用其他字段一样使用你新建的字段了，例如上面的image`xxx.image = xxx`\n\n---\n\n* 在原有的Entity中删除字段，并且创建新的RelationShip关联到新的Entity对象：\n\n1. 前面的1-5的操作都是一样的.\n2. 点击Core Data来创建新建的一个Entity,并且设置相应的字段(这里设置Module 为项目的名字).\n3. 然后从我们新建的Entity中建立新的联系去关联到我们之前的Entity(通过设置destination来设置关联).\n4. 并且回到之前的Entity中，删除或者修改我们想要的修改的字段.\n5. 并且在之前的Entity中，建立联系，关联到之前新建的Entity(这里需要设置destination为新建的Entity，并且设置inverse).\n6. 此时已经可以开始准备合并了，在此之前，需要做些修改：\n7. 创建一个新的类，类名和我们新建的Entity的名字一样，并且在里面创建我们新建的字段.\n8. 修改之前Entity对应的Swift类中，增删修改字段.\n9. 下面是最最重要的一步：建立model 映射：\n10. 在`New/File`中选择`Mapping Model`,选择你修改的基准的Entity为Source, 选择最新的Entity为Targer Model，名字类似为：`UnCloudNotesMappingModel_v2_to_v3`\n11. 在这个新建的映射的文件中可以看出来，如果是之前就存在Entity的话，那么的它的值`Value Expression`= `$source.xxx`，可以看出来这样的数据是没有发生改变的.(**这里的source就是我们开始创建这个文件的时候选择的source是同一个文件，我们可以理解为：v3里面xx字段的值，直接就是取自v2字段的同样的值**).\n12. 刚下已经说了需要新建的一个Entity建立关联，那么必然在这个RelationShip中我们可以看到我们才新建好的Relationship的字段，但是在`Value Expression`中发现xcode并没有给我们填入什么值，这也是很好理解的，**为这个值，关联的是我们新建Entity值，当然之前的Source不知道啦！！所以你现在要做的就是删除这段关联，因为既然是关联，我可以从a对象关联b对象，那我同样可以从b对象关联到a对象**\n13. 勾选新建的Entity对象，发现此时的xode没有给我们勾选Source，这里的理解为：**默认这个新建的Entity的值，所有的值，都是我们自己新建，不需要从之前的Entity中获取值,但是我们这里一旦勾选了source，为某个对象的话，xocde会自动去更加字符创去匹配，获取相应的值，选择了source之后，对应的名字也从xxx改为yyyToxxx**.\n14. 通过之前的理解我们其实可以理解为，每一个note都会关联attachment,但是这里我也可以做一下过滤，如果`attachment里的image != nil`,才将数据进行关联.\n15. `之前xcode为我们创建的Relationship，由于里面的value expression是我们新建的Entity,所以我们将之前的RelationShip删除掉，然后为新建的Entity新建一个relationship关联到之前的旧Entity,并且设置Mapping Name,这里系统就会自动将value expression值填上runtime的函数`\n16. 最后设置两个属性：\n\n```\ndescription.shouldMigrateStoreAutomatically = true\ndescription.shouldInferMappingModelAutomatically = false\n```\n\n---\n\n* 删除对象的字段，并且建立一个新的Entity,里面包含了其他新建的字段,是并且这个Entity是之前某个Entity的子类.\n\n1. 前面的1-5的操作都是一样的.\n2. 点击Core Data来创建新建的一个Entity,并且设置相应的字段(这里设置Module 为项目的名字).\n3. 设置新建Entity的Parent Entity,并且也可以设置相应的自定义字段.\n4. 之后新建我们新建(EntityName).swift，根据新建的字段类型，定义字段，此时可以同样表明继承关系`class ImageAttachment:Attachment {}`\n5. 虽然这里创建了我们想要的Entity以及字段，但是之前的旧model如何作转化呢？这里就同样需要映射，因此这里创建了一个新的Mapping Model:`UnCloudNotesMappingModel_v3_to_v4`.\n6. 这里我们可以更加需要，如果新建的Entity的字段直接来自于之前的某个Model的话，我就可以将这个Model设置为Source，但是如果有些字段没有，或者不是直接可以获取到的话，或者需要从不同的字段中进行一定的逻辑才能够赋值的话，那么这里就需要自定义`NSEntityMigrationPolicy`,这里我们新建的子类对象，并且将Model的`Custom Policy`设置为我们新建的子类的话，系统在载入的时候，会进行比较，假如你现在的Core Data的版本确实需要更新的话，就会执行这个类.\n\n```\nclass AttachmentToImageAttachmentMigrationPolicyV3toV4: NSEntityMigrationPolicy {\n\n  override func createDestinationInstances(forSource sInstance: NSManagedObject, in mapping: NSEntityMapping, manager: NSMigrationManager) throws {\n\n\n    //1.这里会存在两个context，一个读入的source context，一个写入destinationContext.这里当然需要读入的最终的这个context\n\n\n    let description = NSEntityDescription.entity(forEntityName: \"ImageAttachment\",\n                                                 in: manager.destinationContext)\n\n    let newAttachment = ImageAttachment(entity: description!,\n                                        insertInto: manager.destinationContext)\n\n    //2. 将属性进行迭代\n    func traversePropertyMappings(block: (NSPropertyMapping, String) -> ()) throws {\n      if let attributeMappings = mapping.attributeMappings {\n\n        for propertyMapping in attributeMappings {\n\n          if let destinationName = propertyMapping.name {\n            block(propertyMapping, destinationName)\n          } else {\n            //3.如果这个对象，连相应的属性值都不能反悔的话，那就代表肯定有问题的，需要抛出问题.\n\n            let message = \"Attribute destination not configured properly\"\n            let userInfo = [NSLocalizedFailureReasonErrorKey: message]\n            throw NSError(domain: errorDomain,\n                          code: 0,\n                          userInfo: userInfo)\n\n          }\n\n        }\n\n      } else {\n\n        let message = \"No Attribute Mappings found\"\n        let userInfo = [NSLocalizedFailureReasonErrorKey: message]\n        throw NSError(domain: errorDomain,\n                      code: 0,\n                      userInfo: userInfo)\n\n      }\n    }\n\n\n    // 4. 这一步按照映射关系，应该是一一对象进行赋值的\n    try  traversePropertyMappings {\n      propertyMapping, destinationName in\n\n      guard let valueExpression = propertyMapping.valueExpression else { return }\n\n        let context: NSMutableDictionary = [\"source\": sInstance]\n        guard let desinationValue = valueExpression.expressionValue(with: sInstance, context: context) else { return }\n        newAttachment.setValue(desinationValue, forKey: destinationName)\n\n    }\n\n    // 5. 接下来的数据，你可以进行计算，或者从其他Entity中获取值\n\n    if let image = sInstance.value(forKey: \"image\") as? UIImage {\n      newAttachment.setValue(image.size.width, forKey: \"width\")\n      newAttachment.setValue(image.size.height, forKey: \"height\")\n    }\n\n    // 6.\n    let body = sInstance.value(forKeyPath: \"note.body\") as? NSString ?? \"\"\n    newAttachment.setValue(body.substring(to: 80), forKey: \"caption\")\n\n    // 7. 下面需要将新建的Entity与source object、mapping 之间建立联系，如果在迁移数据接受的时候，此函数调用失败的话，数据会丢失.\n    manager.associate(sourceInstance: sInstance, withDestinationInstance: newAttachment, for: mapping)\n  }\n\n}\n\n```\n\n---\n\n* 之前所讲的都是从v1->v2,从v2->v3,从v3->v4，但是这其实是最最简单的情况，但事实情况会比较复杂，因为你永远不知道用户此时是什么版本号？他们可以从v1->v4,也可以从v2->v4，那么这样一来就会比较复杂了.此时我们这里就需要进行自定义数据合并了.\n\n* 我们要做的事情，是进行比较，要先从bundle中读取文件名，然后我们从文件名中进行判断，这个bundle是数据v2、v3还是v1.\n\n```\nextension NSManagedObjectModel {\n  private class func modelURLs(\n    in modelFolder: String) -> [URL] {\n    return Bundle.main\n      .urls(forResourcesWithExtension: \"mom\",\n      subdirectory: \"\\(modelFolder).momd\") ?? []\n  }\n  class func modelVersionsFor(\n    modelNamed modelName: String) -> [NSManagedObjectModel] {\n    return modelURLs(in: modelName)\n      .flatMap(NSManagedObjectModel.init)\n  }\n  class func uncloudNotesModel(\n    named modelName: String) -> NSManagedObjectModel {\n    let model = modelURLs(in: \"UnCloudNotesDataModel\")\n      .filter { $0.lastPathComponent == \"\\(modelName).mom\" }\n      .first\n      .flatMap(NSManagedObjectModel.init)\n    return model ?? NSManagedObjectModel()\n  }\n}\n```\n\n* 版本号之前的判断：\n\n```\n class var version1: NSManagedObjectModel {\n    return uncloudNotesModel(named: \"UnCloudNotesDataModel\")\n  }\n  var isVersion1: Bool {\n    return self == type(of: self).version1\n  }\n  class var version2: NSManagedObjectModel {\n    return uncloudNotesModel(named: \"UnCloudNotesDataModel v2\")\n  }\n\n  var isVersion2: Bool {\n    return self == type(of: self).version2\n  }\n\n  class var version3: NSManagedObjectModel {\n    return uncloudNotesModel(named: \"UnCloudNotesDataModel v3\")\n  }\n\n  var isVersion3: Bool {\n    return self == type(of: self).version3\n  }\n\n  class var version4: NSManagedObjectModel {\n    return uncloudNotesModel(named: \"UnCloudNotesDataModel v4\")\n  }\n\n  var isVersion4: Bool {\n    return self == type(of: self).version4\n  }\n\n```\n\n* 啥时候进行数据迁移呢？\n\n```\nvar stack: CoreDataStack {\n  guard enableMigrations,\n       !store(at: storeURL,\n         isCompatibleWithModel: currentModel)\n  else { return CoreDataStack(modelName: modelName) }\n  performMigration()\n  return CoreDataStack(modelName: modelName)\n}\n\n// 通过获取元数据，并且进行比较，如果需要更新的话，就会将数据返回\n\n  private func store(at storeURL: URL,\n                     isCompatibleWithModel model: NSManagedObjectModel) -> Bool {\n    let storeMetadata = metadataForStoreAtURL(storeURL: storeURL)\n    return model.isConfiguration(withName: nil, compatibleWithStoreMetadata:storeMetadata)\n  }\n\n  private func metadataForStoreAtURL(storeURL: URL)\n    -> [String: Any] {\n      let metadata: [String: Any]\n      do {\n        metadata = try NSPersistentStoreCoordinator\n          .metadataForPersistentStore(ofType: NSSQLiteStoreType,\n                                      at: storeURL, options: nil)\n      } catch {\n        metadata = [:]\n        print(\"Error retrieving metadata for store at URL:\\(storeURL): \\(error)\")\n      }\n      return metadata\n  }\n```\n\n* 数据如何进行合并呢？\n\n```\n private func migrateStoreAt(URL storeURL: URL,\n                              fromModel from:NSManagedObjectModel,\n                              toModel to:NSManagedObjectModel,\n                              mappingModel:NSMappingModel? = nil) {\n\n    // 1.创建migration manager的实例对象\n    let migrationManager =\n      NSMigrationManager(sourceModel: from, destinationModel: to)\n\n    // 2.如果在方法中传递mapping model的对象的话，我们可以使用它，否则我们就创建它.\n    var migrationMappingModel: NSMappingModel\n    if let mappingModel = mappingModel {\n      migrationMappingModel = mappingModel\n    } else {\n      migrationMappingModel = try! NSMappingModel\n        .inferredMappingModel(\n          forSourceModel: from, destinationModel: to)\n    }\n\n    // 3\n    let targetURL = storeURL.deletingLastPathComponent()\n    let destinationName = storeURL.lastPathComponent + \"~1\"\n    let destinationURL = targetURL\n      .appendingPathComponent(destinationName)\n\n    print(\"From Model: \\(from.entityVersionHashesByName)\")\n    print(\"To Model: \\(to.entityVersionHashesByName)\")\n    print(\"Migrating store \\(storeURL) to \\(destinationURL)\")\n    print(\"Mapping model: \\(String(describing: mappingModel))\")\n\n    // 4\n    let success: Bool\n    do {\n      try migrationManager.migrateStore(from: storeURL,\n                                        sourceType:NSSQLiteStoreType,\n                                        options:nil,\n                                        with:migrationMappingModel,\n                                        toDestinationURL:destinationURL,\n                                        destinationType:NSSQLiteStoreType,\n                                        destinationOptions:nil)\n      success = true\n    } catch {\n      success = false\n      print(\"Migration failed: \\(error)\")\n    }\n\n    // 5\n    if success {\n      print(\"Migration Completed Successfully\")\n\n      let fileManager = FileManager.default\n      do {\n        try fileManager.removeItem(at: storeURL)\n        try fileManager.moveItem(at: destinationURL,\n                                 to: storeURL)\n      } catch {\n        print(\"Error migrating \\(error)\")\n      }\n    }\n  }\n\n```\n\n* 如何一步步的合并数据，这里调用了一个递归函数，从而时间一步步的合并数据：\n\n```\nfunc performMigration() {\n    if !currentModel.isVersion4 {\n      fatalError(\"Can only handle migrations to version 4!\")\n    }\n    if let storeModel = self.storeModel {\n      if storeModel.isVersion1 {\n        let destinationModel = NSManagedObjectModel.version2\n\n        migrateStoreAt(URL: storeURL,\n                       fromModel: storeModel,\n                       toModel: destinationModel)\n\n        performMigration()\n      } else if storeModel.isVersion2 {\n        let destinationModel = NSManagedObjectModel.version3\n        let mappingModel = NSMappingModel(from: nil,\n                                          forSourceModel: storeModel,\n                                          destinationModel: destinationModel)\n\n        migrateStoreAt(URL: storeURL,\n                       fromModel: storeModel,\n                       toModel: destinationModel,\n                       mappingModel: mappingModel)\n\n        performMigration()\n      } else if storeModel.isVersion3 {\n        let destinationModel = NSManagedObjectModel.version4\n        let mappingModel = NSMappingModel(from: nil,\n                                          forSourceModel: storeModel,\n                                          destinationModel: destinationModel)\n\n        migrateStoreAt(URL: storeURL,\n                       fromModel: storeModel,\n                       toModel: destinationModel,\n                       mappingModel: mappingModel)\n      }\n    }\n  }\n\n```\n","tags":["Core Data, Swift"],"categories":["日志"]},{"title":"学习NSFetchedResultsController, 获取数据部分(五)","url":"/2017/08/21/20170821/","content":"\n#### 上一周一直在忙着写项目，书虽然看完了，但是还是想写写笔记，加深一下记忆，在第四章的时候，其实通过NSFetchReques一些值的修改，其实我们已经可以开始正常的使用core data, 并且可以按照我们的意愿来过滤数据，并且进行排序。这一章重点讲的是**NSFetchedResultsController**。\n\n<!-- more -->\n\n* 什么是NSFetchedResultsController? 干什么用的？\n* 其实操作Core Data,我们做的最多的操作其实就是，从Core Data中获取数据，然后放入到Array中，然后设置DataSource，然后刷新TableView, Apple就是为了解决这种麻烦，所以才产生了`NSFetchedResultsController`，但是`NSFetchedResultsController`不同于其他的`ViewController`,因为它是没有界面的，他主要的目的是为了异步获取的数据用的。说白了，`NSFetchedResultsController`其实就是`NSFetchRequest Result`数据的封装。从继承关系上也可以看出来：\n\n```\nopen class NSFetchedResultsController<ResultType> : NSObject where ResultType : NSFetchRequestResult {}\n\nclass ViewController: UIViewController {}\n```\n\n* 和`NSFetchRequest`很用法很类似的：\n\n```\n// 1\nlet fetchRequest: NSFetchRequest<Team> = Team.fetchRequest()\nlet sort = NSSortDescriptor(key: #keyPath(Team.teamName),\n  ascending: true)\nfetchRequest.sortDescriptors = [sort]\n\n// 2\nfetchedResultsController = NSFetchedResultsController(\n  fetchRequest: fetchRequest,\n  managedObjectContext: coreDataStack.managedContext,\n  sectionNameKeyPath: nil,\n  cacheName: nil)\n// 3\ndo {\n  try fetchedResultsController.performFetch()\n} catch let error as NSError {\n  print(\"Fetching error: \\(error), \\(error.userInfo)\")\n}\n```\n\n* NSFetchedResultsController主要是为了协调Core Data和TableView,但是仍然需要传递NSFetchRequest, 记住NSFetchRequest是可以高度自定义的，可以传递`descriptiors`/ `predicate`\n* 实例化NSFetchedResultsController需要四个参数，第二个参数就是`NSManagedObjectContext`，需要这个`managedContext`来进行搜索 ,剩下的`sectionNameKeyPath`,`cacheName`\n\n* **NSFetchedResultsController里面必须至少要有一个sort descriptor**否则会直接crash\n\n#### 如何获取数据\n\n```\nfunc numberOfSections(in tableView: UITableView) -> Int {\n  guard let sections = fetchedResultsController.sections else {\nreturn 0 }\n  return sections.count\n}\nfunc tableView(_ tableView: UITableView,\n               numberOfRowsInSection section: Int)\n-> Int {\n  guard let sectionInfo =\n    fetchedResultsController.sections?[section] else {\nreturn 0 }\n  return sectionInfo.numberOfObjects\n}\n```\n\n* 通过调用`sections`的属性，返回的数组中，包含的Object中，都遵循了`NSFetchedResultsSectionInfo`的协议，这个轻量级的协议，能够调用`title`/`number`\n* 如果获取相应的对象呢？\n\n```\nlet team = fetchedResultsController.object(at: indexPath)\n```\n\n#### 如何更改数据\n\n```\nlet team = fetchedResultsController.object(at: indexPath)\n  team.wins = team.wins + 1\n  coreDataStack.saveContext()\n```\n\n#### 如何将数据分组\n\n* 可以根据我们之前创建的Entity对象中的字段，任意进行分组，例如我们的Entity中存在一个名为`qualifyingZone`的String的字段,来进行分组，只需要如下的修改：\n\n```\nfetchedResultsController = NSFetchedResultsController(\n  fetchRequest: fetchRequest,\n  managedObjectContext: coreDataStack.managedContext,\n  sectionNameKeyPath: #keyPath(Team.qualifyingZone),\n  cacheName: nil)\n```\n\n* 这里我们只是传入了一个#keyPath(),根据之前的知识，这个字段的意思会在编译的时候，去寻找Team下面的qualifyingZone。\n* 这个字段又是如何分组的呢？首先它是先讲这些最为Key的字段放在一个Section中（数组中），然后在回更加每个不同的字段去生成不同的数据。\n* **通过#keyPath,可以深入到Core Data中的relationship来查询属性值**\n* 虽然当时`sectionNameKeyPath`但是发现，数据的排序还是更加首字母的？这是因为我没有设置`NSSortDescriptor`，修改代码如下：\n\n```\nlet zoneSort = NSSortDescriptor(\n  key: #keyPath(Team.qualifyingZone), ascending: true)\nlet scoreSort = NSSortDescriptor(\n  key: #keyPath(Team.wins), ascending: false)\nlet nameSort = NSSortDescriptor(\n  key: #keyPath(Team.teamName), ascending: true)\nfetchRequest.sortDescriptors = [zoneSort, scoreSort, nameSort]\n```\n\n* 根据数组的排序，先根据`Team.qualifyingZone`排序，然后根据`Team.wins`排序，最后根据`Team.teamName`来排序。\n\n#### 缓存数据\n\n```\nfetchedResultsController = NSFetchedResultsController(\n  fetchRequest: fetchRequest,\n  managedObjectContext: coreDataStack.managedContext,\n  sectionNameKeyPath: #keyPath(Team.qualifyingZone),\n  cacheName: \"worldCup\")\n```\n\n* 数据分类是很耗性能，避免每次都去分类数据，可以通过缓存，如何通过缓存呢？\n* 直接添加一个字符串的key，这样就可以将数据缓存到磁盘中去了。\n\n#### 监听数据变化\n\n* NSFetchedResultsController可以监听数据集的变化，并且通知他的代理，通过实现代理方法，可以做响应的操作。\n* **这里代理的触发还是需要通过设置NSManagedObjectContext,如果在项目中存在多个Managed Object Context的话，那么代理的方法是不会触发的，除非我们保存数据，并且合并context**\n\n```\n// MARK: - NSFetchedResultsControllerDelegate\nextension ViewController: NSFetchedResultsControllerDelegate {\n  func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {\n    tableView.beginUpdates()\n  }\n\n  func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>,\n                  didChange anObject: Any,\n                  at indexPath: IndexPath?,\n                  for type: NSFetchedResultsChangeType,\n                  newIndexPath: IndexPath?) {\n\n    switch type {\n    case .insert:\n      tableView.insertRows(at: [newIndexPath!], with: .automatic)\n    case .delete:\n      tableView.deleteRows(at: [indexPath!], with: .automatic)\n    case .update:\n      let cell = tableView.cellForRow(at: indexPath!) as! TeamCell\n      configure(cell: cell, for: indexPath!)\n    case .move:\n      tableView.deleteRows(at: [indexPath!], with: .automatic)\n      tableView.insertRows(at: [newIndexPath!], with: .automatic)\n  }\n  }\n\n  func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>,\n                  didChange sectionInfo: NSFetchedResultsSectionInfo,\n                  atSectionIndex sectionIndex: Int,\n                  for type: NSFetchedResultsChangeType) {\n\n    let indexSet = IndexSet(integer: sectionIndex)\n\n    switch type {\n    case .insert:\n      tableView.insertSections(indexSet, with: .automatic)\n    case .delete:\n      tableView.deleteSections(indexSet, with: .automatic)\n    default:\n      break\n    }\n\n  }\n\n  func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {\n    tableView.endUpdates()\n  }\n}\n\n```\n\n#### 添加Entity\n\n```\nlet team = Team(\n    context: self.coreDataStack.managedContext)\n  team.teamName = nameTextField.text\n  team.qualifyingZone = zoneTextField.text\n  team.imageName = \"wenderland-flag\"\n  self.coreDataStack.saveContext()\n```\n","tags":["Core Data, Swift"],"categories":["日志"]},{"title":"学习CoreData, 获取数据部分(四)","url":"/2017/08/10/20170810/","content":"\n#### 前面三章都是一些很基础的操作以及概念，之前我们取数据，用的最多的也就是使用NSFetchRequest中的NSPredicate,我们通过修改相应的NSPredicate值来获取到我们想要的数据。所有这一章主要讲解的是获取数据的相关操作以及技巧。\n\n* 之前用到的操作是：创建一个`NSFetchRequest`的实例，然后通过`NSManagedObjectContext`这个对象来直接修改`NSFetchRequest`就可以实现了。\n* 仅仅获取`NSFetchRequest`的方法就有5种:\n\n<!-- more -->\n\n```\n// 1:通过最普通的NSFetchRequest<Venue>()的方法来实例化NSFetchRequest的对象，紧接着必须使用NSEntityDescription来获取相应的Entity对象，然后直接通过set entity的值。\n\nlet fetchRequest1 = NSFetchRequest<Venue>()\nlet entity =\n  NSEntityDescription.entity(forEntityName: \"Venue\",\n                             in: managedContext)!\nfetchRequest1.entity = entity\n\n\n// 2:这里直接通过NSFetchRequest的实例化方法传入entityName值，直接将上面的步骤省略了，避免使用NSEntityDescription的对象。\n\nlet fetchRequest2 = NSFetchRequest<Venue>(entityName: \"Venue\")\n\n\n// 3: 这个又在第二部的上面做出了相应的省略，当你生成NSManagedObject subclass 的对象，同时你这个对象也会生成一个类方法，直接返回NSFetchRequest，通过这样能够直接与相应的Entity产生联系。\n\nlet fetchRequest3: NSFetchRequest<Venue> = Venue.fetchRequest()\n\n\n// 4: 在三章里分析managedObjectModel就说过，这里可以直接通过managedObjectModel来获取NSFetchRequest。这里在xCode回有个可视化的操作，就是可以添加Request的操作。\n\nlet fetchRequest4 =\n  managedObjectModel.fetchRequestTemplate(forName: \"venueFR\")\n\n\n// 5: 这里第五个方法其实与第四个很相近的，都是通过managedObjectModel来获取NSFetchRequest，不同的是这里多穿了一个substitutionVariables，这个值是用在predicate中的，从而进一步来获取你想要的值。\n\nlet fetchRequest5 =\n  managedObjectModel.fetchRequestFromTemplate(\n    withName: \"venueFR\",\n    substitutionVariables: [\"NAME\" : \"Vivi Bubble Tea\"])\n```\n\n* 其实`NSFetchRequest`是一个很普通的类，但是如果你仔细研究一下`NSFetchRequest`的实例化，你就会发现`<ResultType : NSFetchRequestResult>`这个参数，这个参数的作用就是准备具体说明了你想要获取数据的格式:例如之前你获取的是`[Venue]`而不是`[AnyObject]`。\n* 点击`xxx.xcdatamodeld`,并且长按`Add Entity`,选择`Add Fetch Request`，这样就创建了一个`NSFetchRequest`的对象。但是通过这样创建的`NSFetchRequest`的**对象是无法修改的。这里需要注意一下**，并且通过修改这里`Fetch all`选择相应的model，当然这里也可以通过添加另外的`predicate`的值，来对我们需要的数据进行操作。\n* 那么如何来获取我们之前在模板中创建的`NSFetchRequest`对象呢？这里我们用到是通过`managedObjectModel`来获取相应的`Request`:\n\n```\nguard let model =\n  coreDataStack.managedContext\n    .persistentStoreCoordinator?.managedObjectModel,\n  let fetchRequest = model\n    .fetchRequestTemplate(forName: \"FetchRequest\")\n    as? NSFetchRequest<Venue> else {\nreturn\n}\n```\n\n* `NSFetchRequest`有一个`resultType`的属性值，之前我们使用的都是它的默认值`NSManagedObjectResultType`,其实它是一个枚举值，一共可以获取四中不同的类型：\n\n```\n.managedObjectResultType: 返回的响应的数据(默认的值)\n.countResultType: 返回的匹配数据的个数\n.dictionaryResultType: 以字典的形式来返回相应的数据，包括count，匹配的数据。\n.managedObjectIDResultType: 返回匹配数据的唯一标示符\n```\n\n* 这里创建`Predicate`的方式之前我们也已经看到了,这里的#keyPath, 这个在编译的时候，编译器就会一级级的找相应的属性值，是否存在写错的情况：\n\n```\nlazy var cheapVenuePredicate: NSPredicate = {\n  return NSPredicate(format: \"%K == %@\",\n    #keyPath(Venue.priceInfo.priceCategory), \"$\")\n}()\n```\n\n* 获取count：\n\n```\n func populateCheapVenueCountLabel() {\n    let fetchRequest =\n      NSFetchRequest<NSNumber>(entityName: \"Venue\")\n    fetchRequest.resultType = .countResultType\n    fetchRequest.predicate = cheapVenuePredicate\n    do {\n      let countResult =\n        try coreDataStack.managedContext.fetch(fetchRequest)\n      let count = countResult.first!.intValue\n      firstPriceCategoryLabel.text =\n        \"\\(count) bubble tea places\"\n    } catch let error as NSError {\n      print(\"Count not fetch \\(error), \\(error.userInfo)\")\n    }\n\n    -----------------\n\n\n     let fetchRequest: NSFetchRequest<Venue> = Venue.fetchRequest()\n  fetchRequest.predicate = expensiveVenuePredicate\n  do {\n    let count =\n      try coreDataStack.managedContext.count(for: fetchRequest)\n    thirdPriceCategoryLabel.text = \"\\(count) bubble tea places\"\n  } catch let error as NSError {\n    print(\"Count not fetch \\(error), \\(error.userInfo)\")\n  }\n}\n```\n\n* 上面所有的操作都是需要把所有的相关数据载入到内存中去，然后再去计算个数，core data 能够快速找到数据的“总和、平均值、最大、最小”：\n\n```\nfunc populateDealsCountLabel() {\n// 1\n  let fetchRequest =\n    NSFetchRequest<NSDictionary>(entityName: \"Venue\")\n  fetchRequest.resultType = .dictionaryResultType\n\n\n  // 2: 这边你为了获取总和生成了一个NSExpressionDescription的对象，并且set了一个name的值，便于自己能够从字典中找到自己想要的那个值：\n  let sumExpressionDesc = NSExpressionDescription()\n  sumExpressionDesc.name = \"sumDeals\"\n\n\n// 3: 首先你生成了一个NSExpression的变量来确定你需要哪个字段来计算总和，其次生成了一个NSExpression来变量来确定你要运行的函数，最后定义了返回数据的类型是int32位：\n  let specialCountExp =\n    NSExpression(forKeyPath: #keyPath(Venue.specialCount))\n  sumExpressionDesc.expression =\n    NSExpression(forFunction: \"sum:\",\n                 arguments: [specialCountExp])\n  sumExpressionDesc.expressionResultType =\n    .integer32AttributeType\n\n\n// 4：将自己设置的东西都告诉给FetchRequest\n  fetchRequest.propertiesToFetch = [sumExpressionDesc]\n\n\n// 5:根据上面的定义，我们需要调用的是sum函数，将我们Venue.specialCount所有的字段都加起来，丢在一个字典中，字典的key为sumDeals:\n\n  do {\n    let results =\n      try coreDataStack.managedContext.fetch(fetchRequest)\n    let resultDict = results.first!\n    let numDeals = resultDict[\"sumDeals\"]!\n    numDealsLabel.text = \"\\(numDeals) total deals\"\n  } catch let error as NSError {\n    print(\"Count not fetch \\(error), \\(error.userInfo)\")\n  }\n}\n```\n\n* 这里除了支持sum，还有其他函数支持吗？**count,min,max,median,mode,absolute**\n\n* 这里我们运用的都是些一个单独的NSPredicate，来进行过滤数据，但是我们其实还可以运用多个Predicate来实现类似`AND`,`OR`,`NOT`，可以通过**NSCompoundPredicate**将两个单独`NSPredicate`组合成一个。\n\n#### 排序\n\n* 另一个很牛逼的地方，就是可以对获取的数据进行排序，这里运用的函数是`NSSortDescriptor`,其实这个函数在我们版本号比较的时候就可以运用，但是Core Data中的排序，它是发生在SQLite层面的，而不是内存层面的。\n\n```\nlazy var nameSortDescriptor: NSSortDescriptor = {\n  let compareSelector =\n    #selector(NSString.localizedStandardCompare(_:))\n  return NSSortDescriptor(key: #keyPath(Venue.name),\n}()\nascending: true,\nselector: compareSelector)\nlazy var distanceSortDescriptor: NSSortDescriptor = {\n  return NSSortDescriptor(\n    key: #keyPath(Venue.location.distance),\n    ascending: true)\n}()\nlazy var priceSortDescriptor: NSSortDescriptor = {\n  return NSSortDescriptor(\n    key: #keyPath(Venue.priceInfo.priceCategory),\n    ascending: true)\n}()\n```\n\n* 上面需要解释一下的是Venue.name 的排序，需要三个字段：1:属性的字段名。2：升序还是降序，3: 执行比较的函数。**这里需要重点说一下，我之前比较的都是用的compare的函数，但是apple这里建议使用的是NSString.localizedStandardCompare**，因为这个函数对一些特殊的字符也做了相应的操作。\n\n#### 异步操作：\n\n* 现在我们所有获取数据的操作其实都是在主线程操作的，所以在我们操作大量数据的时候，就会生卡顿，在iOS8的时候，CoreData可以在后台长期高效的运行。\n\n```\nvar asyncFetchRequest: NSAsynchronousFetchRequest<Venue>!\n```\n\n```\noverride func viewDidLoad() {\n  super.viewDidLoad()\n// 1\n  fetchRequest = Venue.fetchRequest()\n// 2\n  asyncFetchRequest =\n    NSAsynchronousFetchRequest<Venue>(\n      fetchRequest: fetchRequest) {\n        [unowned self] (result: NSAsynchronousFetchResult) in\n        guard let venues = result.finalResult else {\nreturn\n}\n      self.venues = venues\n      self.tableView.reloadData()\n  }\n// 3\n  do {\n    try coreDataStack.managedContext.execute(asyncFetchRequest)\n    // Returns immediately, cancel here if you want\n  } catch let error as NSError {\n    print(\"Could not fetch \\(error), \\(error.userInfo)\")\n  }\n}\n```\n\n* 这里可以看到`NSAsyncchronousFetchRequest`并没有取代`NSFetchRequest`,这里可以把`异步操作`是`普通操作的一个封装`。\n* 并且这里`NSManagedObjectContext`执行的是`execute(_:)`而不是`fetch(_:)`\n* 当然这里你可以可以通过调用`cancel()`来取消查询。\n\n#### 批量操作，无需获取数据。\n\n* 在iOS8的时候，提供了一个新的接口可以批量操作，并且也不需要将数据载入到内存中去`NSBatchUpdateRequest`，\n\n```\n// 1. 通过传入EntityName 实例化了一个NSBatchUpdateRequest对象\nlet batchUpdate = NSBatchUpdateRequest(entityName: \"Venue\")\n\n// 2. 设置了需要修改的字段，以及值\nbatchUpdate.propertiesToUpdate =\n  [#keyPath(Venue.favorite) : true]\n\n// 3. 这个批量操作需要影响哪些数据\nbatchUpdate.affectedStores =\n  coreDataStack.managedContext\n    .persistentStoreCoordinator?.persistentStores\n\n// 4. 设置了返回结果的类型，我们这里定义为返回批量更新的count值\nbatchUpdate.resultType = .updatedObjectsCountResultType\n\n\ndo {\n  let batchResult =\n    try coreDataStack.managedContext.execute(batchUpdate)\n      as! NSBatchUpdateResult\n  print(\"Records updated \\(batchResult.result!)\")\n} catch let error as NSError {\n  print(\"Could not update \\(error), \\(error.userInfo)\")\n}\n```\n","tags":["Core Data, Swift"],"categories":["日志"]},{"title":"学习CoreData(三)","url":"/2017/08/09/20170809/","content":"\n* 这一章主要介绍的了四个组成的类\n\n```\n`NSManagedObjectModel`,`NSPersistentStore`,`NSPersistentStoreCoordinator`,`NSManagedObjectContext`\n```\n<!-- more -->\n\n1. `NSManagedObjectModel`: 它就相当于数据库的一个表，我的理解就是代表我们创建的一个`Entity`,里面包含很多我们创建的字段值，当然也包含与其他`Entity`之前的关系（relationship）。具体`NSManagedObjectModel`是如何与我们创建的`data model`产生联系的呢？答案就是：`runtime`,通过`runtime`的机制，能够在编译期高效的将我们所创建`model data`，也就是将`xcdatamodel`文件的内容编译进`momd`文件夹中，再将`momd`文件夹中的内容实例化`NSManagedObjectModel`\n2. `NSPersistentStore`: 他就是负责读写数据，这里还提到了私有`NSPersistentStore`类型，三种是原子性的，一种是非原子性的（所谓的原子性和定义属性值用的原子性不是同一个概念，这里指的原子性：在你做读写的时候，需要将所有的相关数据都载入到内存中去，而非原子性可以根据数据的需求而载入）,四种Type依次为:`NSQLiteStoreType`,`NSXMLStoreType`,`NSBinaryStoreType`,`NSInMemoryStoreType`。\n3. `NSPersistentStoreCoordinator`: 是`NSManagedObjectModel`和`NSPersistentStore`的桥接，我的理解是，它就是`NSManagedObjectModel`和`NSPersistentStore`上层的实现，core data 主要也是通过它来实现功能，`NSPersistentStoreCoordinator`隐藏了它内部的实现，因为`NSManagedObjectContext`并不知道你要存储的是`sqlite xml还是其他的格式`，如果你有多个持久化存储，而对`NSManagedObjectContext`也是统一的接口。\n4. `NSManagedObjectContext`，是`managed object`的暂存器，它也是最最上层的封装，所有的操作都可以通过它来完成，如果不调用save()的方法的话，所有的`NSManagedObjectContext`变化均不会生效的。`NSManagedObjectContext`管理着所有期间创建、获取对象的生命周期，也报错错误信息，以及model的关系，每个`managedobjec`都必须持有对`NSManagedObjectContext`的引用，一旦持有了`NSManagedObjectContext`,在`managedobjec`的整个生命周期中都会持有，也一个application中，也可以存在多个`NSManagedObjectContext`，并且`NSManagedObjectContext`也不是线程安全的。\n\n* iOS10 出现了一个新的类`NSPersistentContainer`，你只需要实例化`NSPersistentContainer`就可以获得上面所提到的四个重要的类了。\n\n* 通过懒加载的方式，直接生成`NSPersistentContainer`:\n\n```\n  private lazy var storeContainer: NSPersistentContainer = {\n\n    let container = NSPersistentContainer(name: self.modelName)\n\n    container.loadPersistentStores {\n      (storeDescription, error) in\n\n      if let error = error as NSError? {\n        print(\"Unresolved error \\(error), \\(error.userInfo)\")\n      }\n\n    }\n\n    return container\n\n  }()\n```\n\n* 那么自然获取`NSManagedObjectContext`就可以直接通过`NSPersistentContainer`来获取了：\n* 虽然这里的`NSManagedObjectContext`可以直接获取，但是`managed model`,`store coordinator` 以及`persistent store`就需要通过`NSPersistentStoreDescription`\n\n```\nlazy var managedContext: NSManagedObjectContext = {\n  return self.storeContainer.viewContext\n}()\n```\n\n* 这里在保存数据之前可以先进行判断数据是够发生变化，这边变化的东西，`NSManagedObjectContext`是肯定知道的：\n\n```\nfunc saveContext () {\n  guard managedContext.hasChanges else { return }\n  do {\n    try managedContext.save()\n  } catch let error as NSError {\n    print(\"Unresolved error \\(error), \\(error.userInfo)\")\n  }\n}\n```\n\n* 创建完`Entity`之后，可以为这个`Entity`来创建关系，点击关系，可以关联其他的`Entity`,并且也可以编辑`RelationShip`的`Data Model`Inspector: `To Many`（一对多），并且也可以设置`Ordered`顺序,这里一旦生成对多有序的对象，那对象就是`NSOrderedSet`类型。\n\n\n* 可以看到实例化model，对象很简单，只需要传入`context`就可以了：\n\n```\nlet walk = Walk(context: managedContext)\n```\n\n* 也可以直接通过`NSManagedObjectContext`直接删除某个对象：\n\n```\n//2\n  managedContext.delete(walkToRemove)\n```\n","tags":["Core Data, Swift"],"categories":["日志"]},{"title":"学习CoreData, 子类化NSManagerObject(二)","url":"/2017/08/08/20170808/","content":"\n* 打开xxx.xcdatamodeld文件,添加Entity,例如这里名叫“Person”的类,并且通过类似第一部分的操作就可以编辑了Attributes了。\n* 这里在给Attribute添加字段的时候需要注意的: 字段类型有`Boolean 布尔类型`, `Date 时间戳`, `Double 浮点类型`,`String 字符串类型`, `Integer Integer 32 Integer 64 整型`。\n\n<!-- more -->\n\n* 如果Entity中有关联的`image`或者`PDF`(任何可以被序列化为0或者任何的东西)类型的话，都可以将它定义为`Binary Data 二进制类型`, 但是这也会带来一个问题：“如果二进制文件太大,当你每次需要获取这个Entity的时候，就会消耗巨大的内存，从而影响性能”，这里你可以通过勾选`Allows External Storage`,这样“Core Data会根据你存入数据的大小，来决定是直接存储这个值还是仅仅只是存储一个URI的值，这个值指向的是一个单独的文件数据”,并且如果打开了这个属性值，你将无法通过查询的方式来获取这个值。\n* 这里的UIColor,NSArray,NSDictionary任何只要遵循了NSCoding协议的都可以定义为: `Transformable`。\n* 之前不管是取值还是赋值都是通过KVC的方式来实现的，例如：\n\n```\n// Set the name\nperson.setValue(aName, forKey: \"name\")\n// Get the name\nlet name = person.value(forKey: \"name\")\n```\n\n* 我们勾选`Codegen`值为：`Manual/None`,然后点击`Editor\\Create NSManagedObject Subclass....`，这样`Xcode`就可以为我们创建了两个文件。如果修改了响应的`Entity`的文件的属性，可以重新点击`Editor\\Create NSManagedObject Subclass....`\n* 生成的文件中，属性值前面都写着`@NSManaged`,这个字段的意思是告诉Swift编译器，这个属性的存储和实现都是在运行时产生的，而不是在编译的时候产生。因为这些属性的存储是需要`managed object context`,而这个东西在编译的时候，还没有生成。\n* 测试插入的一个新的数据：\n\n```\n // Save test bow tie\n  let bowtie = NSEntityDescription.insertNewObject(\n    forEntityName: \"Bowtie\",\n    into: self.persistentContainer.viewContext) as! Bowtie\n  bowtie.name = \"My bow tie\"\n  bowtie.lastWorn = NSDate()\n  // Retrieve test bow tie\n  do {\n    let request = NSFetchRequest<Bowtie>(entityName: \"Bowtie\")\n    let ties =\n      try self.persistentContainer.viewContext.fetch(request)\n    let sample = ties.first\n    print(\"Name :\\(sample?.name), Worn: \\(sample?.lastWorn)\")\n  } catch let error as NSError {\n    print(\"Fetching error: \\(error), \\(error.userInfo)\")\n  }\nreturn true\n}\n```\n\n* `image`和`UIColor`的存取\n\n```\n...\n   let colorDict = btDict[\"tintColor\"] as! [String: AnyObject]\n    bowtie.tintColor = UIColor.color(dict: colorDict)\n\n    let image = UIImage(named: imageName!)\n    let photoData = UIImagePNGRepresentation(image!)!\n    bowtie.photoData = NSData(data: photoData)\n...\n```\n\n* 如何根据条件查询？运用`NSPredicate`:\n\n```\n//2\n  let request = NSFetchRequest<Bowtie>(entityName: \"Bowtie\")\n  let firstTitle = segmentedControl.titleForSegment(at: 0)!\n  request.predicate = NSPredicate(\n    format: \"searchKey == %@\", firstTitle)\ndo { //3\n    let results = try managedContext.fetch(request)\n//4\n    populate(bowtie: results.first!)\n  } catch let error as NSError {\n    print(\"Could not fetch \\(error), \\(error.userInfo)\")\n  }\n```\n\n* CoreData 如何对字段值进行验证？\n* 勾选需要验证字段，打开`data model inspector`,然后勾选`Validation`，可以勾选`默认值`,`最大值`,`最小值`，这样就可以在catch中捕获住Error：\n\n```\n if error.domain == NSCocoaErrorDomain &&\n      (error.code == NSValidationNumberTooLargeError ||\n        error.code == NSValidationNumberTooSmallError) {\n      rate(currentBowtie)\n}\n```\n","tags":["Core Data, Swift"],"categories":["日志"]},{"title":"学习CoreData(一)","url":"/2017/08/07/20170807/","content":"\n### 最近在看Core Data这本书，很多人都说这个东西多难用，但是很多细节如果不进去细细看的话，也会存在很多懵逼的地方。不得不承认，这个东西还是挺牛逼的。\n\n<!-- more -->\n\n---\n\n* 如何存入相应的`Entity`对象? 在回答这个问题之前要先知道，我们是通过什么对象来存入数据的呢？\n* 答案是：`NSManagedObjectContext`\n\n---\n\n* 那什么是`NSManagedObjectContext`?\n* 书上的给的解释我认为很贴切：`You can consider a managed object context as an in-memory “scratchpad” for working with managed objects`，我的理解是：`它其实就相当于内存中的暂存器`,那么完成插入数据就分为两步：`1. 将数据插入到NSManagedObjectContext`，`2. 然后将managed object context的变化保存到磁盘中`\n\n---\n\n* 那现在怎么获取这个所谓的暂存器`NSManagedObjectContext`?\n* 如果你的项目创建是通过xcode，勾选创建`Use Core Data`的话，就可以直接通过下面的代码来获取：\n\n```\nlet managedContext =\n    appDelegate.persistentContainer.viewContext\n```\n\n---\n\n* 如何通过`NSManagedObjectContext`来获取`Entity`？\n* 我们通过模板来创建的`Entity`对象，在CoreData中就好比`Class`,这些`Entity`都是继承`NSManagedObject`类或者为其子类，那这个问题就转化为如何取得我们之前早起定义的`Entity`，也就是`NSManagedObject`对象呢？\n\n```\nlet entity =\n    NSEntityDescription.entity(forEntityName: \"Person\",\n                               in: managedContext)!\n```\n\n---\n\n* 这里是通过`NSEntityDescription`对象一个类方法`entity`,传入相应的`Entity`字符串，但是这里返回并不是我们之前预料的`NSManagedObject`,而是`NSEntityDescription`自己。\n* 这里是因为`NSEntityDescription`= `数据模型实体定义` 与 `NSManagedObject` 的链接部分\n\n---\n\n* 拿到了`Entity`,如何来设置值呢？\n* 因为`NSManagedObject`是用OC来写的，可以通过`KVC`的方式来设置，这里一定要注定字符串的书写正确，否则就会发生crash\n\n---\n\n* 之前说了最后还需要`commit`,那如何`commit`的？\n* 直接调用`managedContext.save()`,这里可能会提交不成功，那就需要catch住相应的错误。\n\n---\n\n#### 赋值的代码：\n\n```\n   func save(name: String) {\n        guard let appDelegate = UIApplication.shared.delegate as? AppDelegate else {\n            return\n        }\n\n        //1.\n        let managedContext = appDelegate.persistentContainer.viewContext\n\n        //2.\n        let entity = NSEntityDescription.entity(forEntityName: \"Person\", in: managedContext)!\n\n        let person = NSManagedObject(entity: entity, insertInto: managedContext)\n\n        //3.\n        person.setValue(name, forKeyPath: \"name\")\n\n        //4.\n        do {\n            try managedContext.save()\n            people.append(person)\n        } catch let error as NSError {\n            print(\"Could not save. \\(error), \\(error.userInfo)\")\n        }\n    }\n```\n\n\n#### 取值的代码：\n\n```\n//1\n  guard let appDelegate =\n    UIApplication.shared.delegate as? AppDelegate else {\nreturn\n}\n  let managedContext =\n    appDelegate.persistentContainer.viewContext\n//2\n  let fetchRequest =\n    NSFetchRequest<NSManagedObject>(entityName: \"Person\")\n//3\n  do {\n    people = try managedContext.fetch(fetchRequest)\n  } catch let error as NSError {\n    print(\"Could not fetch. \\(error), \\(error.userInfo)\")\n  }\n```\n\n* 其他都和赋值的操作是一样的，那第二部是什么意思呢？\n* 就如这个`NSFetchRequest`类名字一样，`NSFetchRequest`他就是赋值从`Core Data中获取数据的东西`，这里我们通过传入`EntityName`来准确告诉`context`我们需要获取的是什么对象。这里是获取所有符合条件的对象。\n* 最后调用`fetch`会直接返回所有数据，同样这里也可能会失败，记住catch住错误。\n","tags":["Core Data, Swift"],"categories":["日志"]},{"title":"React-Native 0.46 最新环境配置","url":"/2017/07/31/20170731/","content":"\n\n### 隔了好久，闲来无事，看到自己github上React-Native的项目好久没有更新了，所以想继续搞搞它，但是发现好多坑。\n\n* 打开官网 `https://facebook.github.io/react-native/`，我所用的都是最新的版本`0.46`, 点击链接到`https://facebook.github.io/react-native/docs/getting-started.html`,点击`Build Projects with Native Code`，会有一个`Demo`，按照这个`Demo`一步步操作，会遇到很多的坑，这里我记录一下：\n\n<!-- more -->\n\n1.先运行Android的机器，发现会报未找到`SDK`的问题，具体如下：\n\n```\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nA problem occurred configuring project ':app'.\n> SDK location not found. Define location with sdk.dir in the local.properties file or with an ANDROID_HOME environment variable.\n```\n\n* 解决：以mac为例子，找到`~/.bashrc`的文件，也有可能是`~/.zshrc`的文件\n\n```\n1. vim ~/.bashrc\n\n\n2.  export ANDROID_HOME=~/Library/Android/sdk\n    export PATH=${PATH}:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools\n```\n\n2.再次运行`react-native run-android` 想执行真机的话, 报这如下错误：\n\n```\nCould not run adb reverse: Command failed: /Users/gonghuan/Library/Android/sdk/platform-tools/adb -s K21GAMN590201150 reverse tcp:8081 tcp:8081\n```\n\n* 这里假如你的系统是`Android 5.0`以上的话，应该就不会有这个问题了，但是如果你的安卓机器和我的一样，都是低于`Android 5.0的话`：, 以我的手机为例[安卓4.4.4]，解决：\n\n```\n1. (Android 5.0以下)通过Wi-Fi连接你的本地开发服务器\n首先确保你的电脑和手机设备在同一个Wi-Fi环境下。\n2. 在设备上运行你的React Native应用。和打开其它App一样操作。\n你应该会看到一个“红屏”错误提示。这是正常的，下面的步骤会解决这个报错。\n3. 摇晃设备，或者运行adb shell input keyevent 82，可以打开开发者菜单。\n4. 点击进入Dev Settings。\n5. 点击Debug server host for device。\n6. 输入你电脑的IP地址和端口号（譬如10.0.1.1:8081）。在Mac上，你可以在系统设置/网络里找查询你的IP地址。在Windows上，打开命令提示符并输入ipconfig来查询你的IP地址。在Linux上你可以在终端中输入ifconfig来查询你的IP地址。\n7. 回到开发者菜单然后选择Reload JS。`\n```\n\n3.运行`react-native run-android`的时候，启动模拟器，我这边报这个错误：\n\n```\nError: No available formula with the name \"android-sdk\"\n```\n\n* 解决途径：1. 如果你已经按照官网 [https://facebook.github.io/react-native/docs/getting-started.html] 的教程，走完，但是还是报错的话就执行下面的命令：\n\n```\nbrew tap caskroom/cask\n\n\nbrew cask install android-sdk\n\n\nbrew cask install android-platform-tools\n\n```\n","tags":["React-Native"],"categories":["日志"]},{"title":"学习设计模式-迭代器模式","url":"/2017/07/13/20170713/","content":"\n\n### 代码写多了，就想把代码写好，将代码写好，就必然要学习设计模式，今天重点学习一下迭代器模式和组合模式。这里我参照的学习是以JAVA为参照的《Header First》设计模式，我这里会以Object-c的格式来重写，最后以一个我项目中的实例来说明一下。\n\n### 1.1 迭代器设计模式：\n\n1. 问题：这里有两个类：一个是煎饼餐厅菜类`PancakeHouseMenu`(这里假设代码中是以数组的形式来存储),一个是普通餐厅类`DinerMenu`(这里假设是以字典的形式来存储),他们都有自己原有的代码，以及逻辑，现在如何将这两个菜单类合并成一个类更好给用户调用。\n\n<!-- more -->\n\n* 这个是PancakeHouseMenu的代码\n\n```\n#import \"PancakeHouseMenu.h\"\n#import \"Pancak.h\"\n\n@interface PancakeHouseMenu ()\n\n@property (nonatomic, strong) NSMutableArray *items;\n\n@end\n\n\n@implementation PancakeHouseMenu\n\n- (instancetype)init {\n    if (self = [super init]) {        \n        [self addItem:@\"cake_A\" isVege:YES price:0.23];\n        [self addItem:@\"cake_B\" isVege:NO price:0.53];\n        [self addItem:@\"cake_C\" isVege:YES price:1.2];\n    }\n    return self;\n}\n\n- (void)addItem:(NSString *)itemName isVege:(BOOL)isVege price:(CGFloat)price {\n    Pancak *cake  = [Pancak pancakName:itemName isVege:isVege price:price];\n    if (cake != nil) [self.items addObject:cake];\n}\n\n- (NSArray <Pancak *>*) menuItems; {\n    return [self.items copy];\n}\n\n#pragma mark - Getter Methods\n\n- (NSMutableArray *)items {\n    if (_items == nil) _items = [NSMutableArray new];\n    return _items;\n}\n\n\n@end\n```\n\n* 这个是DinerMenu的代码\n\n```\n#import \"DinerMenu.h\"\n#import \"Diner.h\"\n\n@interface DinerMenu ()\n\n@property (nonatomic, strong) NSMutableDictionary *items;\n@property (nonatomic, assign) NSInteger            numberOfItems;\n\n@end\n\n@implementation DinerMenu\n\n- (instancetype)init {\n    if (self = [super init]) {\n        \n        self.numberOfItems = 0;\n        \n        [self addItem:@\"Diner_A\" isVege:YES price:2.32];\n        [self addItem:@\"Diner_B\" isVege:NO price:5.33];\n        [self addItem:@\"Diner_C\" isVege:YES price:1.27];\n    }\n    return self;\n}\n\n- (NSDictionary *) menuItems {\n    return [self.items copy];\n}\n\n- (void)addItem:(NSString *)itemName isVege:(BOOL)isVege price:(CGFloat)price {\n    Diner *diner = [Diner DinerName:itemName isVege:isVege price:price];\n    if (diner != nil && itemName != nil) {\n        [self.items setObject:diner forKey:@(self.numberOfItems)];\n        self.numberOfItems ++;\n    }\n}\n\n- (NSMutableDictionary *)items {\n    if (_items == nil) _items = [NSMutableDictionary new];\n    return _items;\n}\n\n@end\n```\n\n* 通过比较就可以看出这两个的区别。存储数据分别用的是`NSMutableArray`和`NSMutableDictionary`\n* 如果此时我需要分别打印响应的数据的时候的，就需要这样：\n\n```\n- (void)printMenu {\n    \n    self.pancakeMenu = [PancakeHouseMenu new];\n    NSArray *pancakeItems = self.pancakeMenu.menuItems;\n    \n    self.dinerMenu = [DinerMenu new];\n    NSDictionary *dinerItems = self.dinerMenu.menuItems;\n    \n    for (int i = 0 ; i < pancakeItems.count ; i++) {\n        Pancak *pancake = pancakeItems[i];\n        NSLog(@\"%@\", pancake);\n    }\n    \n    NSLog(@\"--------------------\");\n    \n    for (int i = 0 ; i < dinerItems.count; i ++ ) {\n        Diner *diner = dinerItems[@(i)];\n        NSLog(@\"%@\", diner);\n    }\n    \n}\n```\n\n* 结果如下：\n\n```\n2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] pancake:[name:cake_A--isvege:1--price:0.23]\n2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] pancake:[name:cake_B--isvege:0--price:0.53]\n2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] pancake:[name:cake_C--isvege:1--price:1.20]\n2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] --------------------\n2017-07-12 16:54:00.993 Learn_Iterator_Composite_Pattern[6245:186657] diner:[name:Diner_A--isvege:1--price:2.32]\n2017-07-12 16:54:00.993 Learn_Iterator_Composite_Pattern[6245:186657] diner:[name:Diner_B--isvege:0--price:5.33]\n2017-07-12 16:54:00.993 Learn_Iterator_Composite_Pattern[6245:186657] diner:[name:Diner_C--isvege:1--price:1.27]\n```\n\n* 这样第一个问题就出现了，`这里两家餐厅的菜单存储的数据结构没法控制，这里需要打印菜单的时候，就需要分别遍历两个数据`\n* 解决版本：`封装变化的部分`（这里变化的部分就是循环遍历的地方）\n* 这里创建一个`protocol`,代码如下：\n\n```\n@protocol Iterator <NSObject>\n\n/**\n 是否这个聚合中存在更多的元素\n \n @return 返回bool值\n */\n- (BOOL)hasNext;\n\n/**\n 返回下一个对象\n \n @return 下一个对象\n */\n- (id)next;\n\n@end\n```\n\n* 创建一个新的类`DinerMenuIterator`,这个类是`Iterator`具体实现的类，具体实现：\n\n```\n#import \"DinerMenuIterator.h\"\n\n@interface DinerMenuIterator ()\n\n@property (nonatomic, strong) NSDictionary *items;\n@property (nonatomic, assign) NSInteger    position;\n\n@end\n\n@implementation DinerMenuIterator\n\n- (instancetype)initWithItems:(NSDictionary *)items {\n    if (self = [super init]) {\n        self.position   = 0;\n        self.items      = items;\n    }\n    return self;\n}\n\n- (BOOL)hasNext {\n    if (self.position >= self.items.count) return NO;\n    return YES;\n}\n\n- (id)next {\n    if ([self hasNext]) {\n        id item = self.items[@(self.position)];\n        self.position ++;\n        return item;\n    }\n    return nil;\n}\n\n@end\n```\n\n* 修改`DinerMenu`的类：\n\n```\n/**\n 返回菜单项\n \n @return 菜单总数据\n */\n//- (NSDictionary *) menuItems;\n\n/**\n 迭代器的接口\n \n @return 迭代器对象\n */\n- (id<Iterator>)iterator;\n```\n\n* .m 文件的具体实现：\n\n```\n- (id<Iterator>)iterator {\n    return [[DinerMenuIterator alloc] initWithItems:[self.items copy]];\n}\n\n//- (NSDictionary *) menuItems {\n//    return [self.items copy];\n//}\n```\n\n* 这样打印代码如下：\n\n```\n- (void)printMenu {\n    \n    self.pancakeMenu = [PancakeHouseMenu new];\n    id <Iterator>pancakIterator = [self.pancakeMenu iterator];\n    \n    self.dinerMenu = [DinerMenu new];\n    id <Iterator>dinerIterator = [self.dinerMenu iterator];\n    \n    \n    [self iterate_print_menu:pancakIterator];\n    \n    NSLog(@\"--------------------\");\n    \n    [self iterate_print_menu:dinerIterator];\n    \n}\n\n- (void)iterate_print_menu:(id<Iterator>)it {\n    while (it.hasNext) {\n        NSLog(@\"%@\", it.next);\n    }\n}\n```\n\n* 这样就解决了游走于每一个元素内部之间，而不需要暴露内部的实现。\n* 迭代器模式：提供一种方法顺序访问聚合对象中各个元素，而又不暴露其内部的实现。\n\n\n","tags":["OC"],"categories":["日志"]},{"title":"学习《iOS Animations》","url":"/2017/07/04/20170704/","content":"\n\n## 最近一直在学习《iOS Animations》这本书，记录一下学习到知识点：\n\n* 这本都快看完了，一直觉得没啥可做笔记的，以为UI动画的一些用法，你知道就是知道，不知道就是不知道，知道了 就觉得很容易，所以觉得这是一个熟能生巧的技能，但是想想，这本书都快看完了，还是要留下一些什么，所以觉得记些东西。\n\n### Animating Constraints 如何在动画中修改约束\n\n* 最简单的就是获取`NSLayoutConstraint!`的属性值，直接修改对象的`constant`可以直接实现约束值的改变。官方的api解释如下：\n\n>  Unlike the other properties, the constant may be modified after constraint creation.  Setting the constant on an existing constraint performs much better than removing the constraint and adding a new one that's just like the old but for having a new constant.\n\n<!-- more -->\n\n```\n@IBOutlet weak var menuHeightConstraint: NSLayoutConstraint!\nmenuHeightConstraint.constant = isMenuOpen ? 200.0 : 60.0\n```\n\n#### 1.1 添加动画\n* 运用类似这些api`animate(withDuration:animations:)`就可以实现动画。\n* 可以在animations的closure里面添加动画的代码，也可以在外面修改完响应的约束代码，然后直接在closure中调用`self.view.layoutIfNeeded()`\n\n```\n    UIView.animate(withDuration: 1.0, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 10.0, options: .curveEaseIn, animations: {\n        self.view.layoutIfNeeded()        \n    }, completion: nil)\n```\n\n#### 1.2 遍历修改约束\n\n```\ntitleLabel.superview?.constraints.forEach { constraint in\n\t if constraint.firstItem === titleLabel &&\n     constraint.firstAttribute == .centerX {\n    constraint.constant = isMenuOpen ? -100.0 : 0.0\n    return\n\t}\n}\n```\n* 这里的作用就是遍历`titleLabel`的父视图的约束.\n* 表达式`firstItem.firstAttribute = secondItem.secondAttribute + constant`\n* 删除某个约束，是通过 `isActive`的属性来设置的，`isActive`的属性为`false`的时候，就代表去除约束, 当设置`isActive`的属性值为`false`,视图的层级会删除约束，并且如果没有对象引用它，它就会从内存中去除掉。\n\n#### 1.3 添加新的约束\n\n\n\n* 1.在刚才枚举中，可以通过循环，并且创建一个新的约束，并且替换掉：\n\n```\nlet newConstraint = NSLayoutConstraint(\n  item: titleLabel,\n  attribute: .centerY,\n  relatedBy: .equal,\n  toItem: titleLabel.superview!,\n  attribute: .centerY,\n  multiplier: isMenuOpen ? 0.67 : 1.0,\n  constant: 5.0)\nnewConstraint.identifier = \"TitleCenterY\"\nnewConstraint.isActive = true\n```\n* 通过设置`identifier`的属性值，来找到视图层级的元素，通过设置`isActive`来告诉`Autolayout`将其应用到当前的布局中去。\n* 如果是手动编写`autolayout`的代码，创建完新的约束后，需要通过`addConstraint`,将新的约束添加到视图上去。\n* 但是系统更偏向于使用` NSLayoutConstraint.activate(_:)`的类方法,接受一个 constraint的数组，性能更优，官方api的解释如下:\n\n> Convenience method that activates each constraint in the contained array, in the same manner as setting active=YES. This is often more efficient than activating each constraint individually.\n\n* 2.\n\n```\nlet conX = imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor)\nlet conBottom = imageView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: imageView.frame.height)\nlet conWidth  = imageView.widthAnchor.constraint(equalTo: view.widthAnchor, multiplier: 0.33, constant: -50)\nlet conHeight = imageView.heightAnchor.constraint(equalTo: imageView.widthAnchor)\nNSLayoutConstraint.activate([conX, conBottom, conWidth, conHeight])\n```\n\n\n\n","tags":["Swift"],"categories":["日志"]},{"title":"学习算法","url":"/2017/06/20/20170620/","content":"\n\n### 前两天闲来无事有重新温习了一下算法，用`Swift3`重写了一下算法：今天先写一下`O(n^2)`的两种算法：`选择排序`、`插入排序`，以及算法复杂度为`O(nlogn)`的：`递归排序`\n\n* 项目我已经丢到github上了，可以自己去下载： [https://github.com/Ghstart/play_with_algorithm]\n\n#### 1.1 准备工作\n\n* 首先写算法，我需要有准备为我产生测试用例的方法，因此我定义了了一个类`Helper`,并且写静态方法：\n\n```\n  static func generateSources(count: Int) -> [Int] {\n        var sources: [Int] = [Int]()\n        for _ in 1...count {\n            let randomNum: UInt32 = arc4random_uniform(1_000_000)\n            sources.append(Int(randomNum))\n        }\n        return sources\n    }\n```\n\n<!-- more -->\n\n* 学习算法必不可少的，就是需要去验证我的算法，是否正确，这里我写了一个静态方法去验证我的算法是否排序正确：\n\n```\n static func isSorted(testSources: [Int]) -> Bool {\n        \n        if testSources.count < 3 {\n            assert(true, \"你逗我呢？？就几个自己数\")\n            return false\n        }\n        \n        \n        for i in 0...testSources.count - 2 {\n            if testSources[i] > testSources[i + 1] {\n                return false\n            }\n        }\n        \n        return true\n    }\n```\n\n\n* 写算法，我必须要去计算每个算法所执行的时间，通过`Unit Test`的`measure`可以来看出每个方法执行的时间，这里我也写了一个静态方法：\n\n```\n  static func executeTime(whichFunctionName: String, testSources: [Int], operation: ([Int]) -> ([Int])) {\n        let methodStart = Date()\n        let tt = operation(testSources)\n        let methodFinished = Date()\n        let executionTime = methodFinished.timeIntervalSince(methodStart)\n        print(String(format:\"执行%@花费%.9fs\", whichFunctionName, executionTime))\n        assert(Helper.isSorted(testSources: tt), \"排序后还是存在问题！！\")\n    }\n```\n\n#### 1.2 开始coding\n\n* 选择排序，其实说白了，就找`索引`, 从当前位置一直往后找，并且判断，如果小，就找出他的索引，再继续往后找，直到到最后一位, `这里注意，它是不能提前结束的，所以这就是为什么说他会比插入排序慢了`：\n\n```\n/**\n     * 选择排序\n     */\n    func selectionSort(sources: [Int]) -> [Int] {\n        \n        var sources = sources\n        \n        for i in 0..<sources.count {\n            \n            var minIndex = i\n            \n            for j in i+1..<sources.count  {\n                \n                if sources[j] < sources[minIndex] {\n                    \n                    minIndex = j\n                }\n            }\n            \n            if minIndex != i {\n                swap(&sources[minIndex], &sources[i])\n            }\n           \n        }\n        \n        return sources\n    }\n```\n\n* 插入排序，是从第二个位置开始往前找，判断前面的是否比他大，比他大的话，就将前面的数字往后挪，因此类推：\n\n```\n  /**\n     * 插入排序\n     */\n    func insertionSort(sources: [Int]) -> [Int] {\n        \n        var sources = sources\n        \n        for i in 1..<sources.count {\n\n            let e = sources[i]\n            var j = i - 1\n            \n            while ( j >= 0 && sources[j] > e) {\n                \n                sources[j + 1] = sources[j]\n                \n                j = j - 1\n            }\n            \n            sources[j+1] = e\n        \n        }\n        \n        return sources\n    }\n```\n\n* 递归排序\n\n```\n \t/**\n     * 归并排序\n     */\n    func mergeSort(sources: [Int]) -> [Int] {\n        \n        var sources = sources\n        \n        __mergeSort(sources: &sources, l: 0, r: sources.count - 1)\n        \n        return sources\n    }\n    \n    func __mergeSort( sources: inout [Int], l: Int, r: Int) {\n        \n        if l >= r {\n            return\n        }\n        \n        let mid: Int = (l + r) / 2\n        __mergeSort(sources: &sources, l: l, r: mid)\n        __mergeSort(sources: &sources, l: mid+1, r: r)\n        __merge(sources: &sources, l: l, mid: mid, r: r)\n        \n    }\n    \n    // [l...mid]  [mid+1...r]\n    func __merge(sources: inout [Int], l: Int, mid: Int, r: Int) {\n        \n        var aux = [Int]()\n        for i in l...r {\n            aux.insert(sources[i], at: i-l)\n        }\n        \n        var i: Int = l\n        var j: Int = mid + 1\n        for k in l...r {\n            \n            if i > mid {\n                \n                sources[k] = aux[j-l]\n                j = j + 1\n                \n            } else if j > r {\n                \n                sources[k] = aux[i-l]\n                i = i + 1\n                \n            } else if aux[i-l] < aux[j-l] {\n                \n                sources[k] = aux[i-l]\n                i = i + 1\n                \n            } else {\n                \n                sources[k] = aux[j-l]\n                j = j + 1\n            }\n            \n        }\n        \n    }\n\n```\n\n\n#### 1.3 测试：\n\n* 如何调用：\n\n```\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let arr = Helper.generateSources(count: 1_000)\n        let arr1 = arr\n        \n        Helper.executeTime(whichFunctionName: \"插入排序\", testSources: arr, operation: insertionSort)\n        Helper.executeTime(whichFunctionName: \"选择排序\", testSources: arr1, operation: selectionSort)\n        \n    }\n    \n```\n\n* 控制台的打印：\n\n```\n执行插入排序花费0.016882956s\n执行选择排序花费0.023320019s\n```\n\n","tags":["算法"],"categories":["日志"]},{"title":"学习Android开发基础笔记Tips","url":"/2017/05/31/20170531/","content":"\n### 学习Android, 最近正好有时间，可以系统的看看Android的系统开发，记录下学习的笔记，供今后参考。\n\n#### 1.1 基础环境：\n\n1. 使用的IDE为：Android Studio.\n2. SDK 最低的版本为：Android 4.1.\n\n* `LinearLayout`是布局组件，可以从继承关系上看出关系, 继承自View的子类`ViewGroup`，并且`FrameLayout`,`TableLayout`,`RelativeLayout`他们都是继承自`ViewGroup`\n\n```\n// 继承关系\npublic class LinearLayout extends ViewGroup\n\npublic abstract class ViewGroup extends View implements ViewParent, ViewManager\n```\n\n<!-- more -->\n\n#### 1.2 UI属性:\n\n```\nmatch_parent: 视图与其父视图大小相同\nwrap_content: 视图将根据展示的内容自动调整大小\nandroid:orientation: LinearLayout 具有的属性，决定子组件是“水平”还是“垂直”排列\n```\n\n* 字符串，对某个组件setString的时候，你会发现是这样写的：`@string/xxxx`, 这里需要注意一下：`android:text属性值不是字符串值，而是对字符串资源的应用`，其实这时候你setString的时候，实际上是去`app/res/values`的文件夹中查找`strings.xml`。\n\n```\n<string name=\"xxxx\">YYYYYY</string>\n```\n\n* 随意创建一个文件，系统会默认给我们创建一些代码：\n* 这里的`R.java`文件是在代码编译的时候创建的:\n\n```\npublic class QuizActivity extends AppCompatActivity {\n\t\t\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_quiz);\n}\n```\n\n* `AppCompatActivity`是`Activity`的子类\n* `activity`创建完后，需要获取自己的界面：\n\n```\npublic void setContentView(@LayoutRes int layoutResID) {\n\n}\n```\n\n* 这里的`layoutResID`就是要在资源中来寻找相应的资源。资源文件需要从`app/res`目录下寻找，和`TextView`中获取字符串的方法是一样的，需要去`app/res/values`中的`strings.xml`中去寻找：\n\n```\npublic final void setText(@StringRes int resid) {\n\n}\n```\n\n#### 1.3 按钮的点击：\n\n```\n   mNextButton = (Button) findViewById(R.id.next_button);\n        mNextButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n             \n            }\n        });\n```\n\n#### 1.4 Toast的提示信息：\n\n```\nToast.makeText(CurrentActivity.this, R.string.xxx, Toast.LENGTH_SHORT).show();\n```\n\n#### 1.5 生命周期\n\n1. 不存在 ->(onCreate)-> 停止（不可见）->(onStart)->暂停（可见）-> (onResume) 运行（可见 & 在前台）\n2. 运行（可见 & 在前台）->(onPause)-> 暂停（可见 ->(onStop)-> 停止（不可见 ->(onDestory)-> 不存在\n\n* 在创建了Activity之后，并且此实例出现在屏幕之前会调用`onCreate`的方法\n\n* 转屏幕的时候，生命周期的改变：\n\n1. 当屏幕发生转动的时候，Activity的生命周期会从新再走一遍，也就是 上面的会先按照 2 -> 1,每次转屏都会这样。\n\n* 想要在转屏的时候，保存数据，可以调用下面`onSaveInstanceState`的方法来保存数据，下次在需要的时候，可以获取数据：\n\n```\n @Override\n protected void onSaveInstanceState(Bundle outState) {\n      super.onSaveInstanceState(outState);\n      outState.putInt(KEY_INDEX, mCurrentIndex);\n }\n    \n    \n   @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState); \n    \t   if (savedInstanceState != null) {\n            mCurrentIndex = savedInstanceState.getInt(KEY_INDEX);\n        }\n    }\n```\n\n* 但是转屏并且保存数据的生命周期方法的调用顺序为：\n\n1. `onPause()` -> `onSaveInstanceState()` -> `onStop()` -> `onDestory()`\n\n\n\n\n\n","tags":["Android"],"categories":["日志"]},{"title":"学习爬虫Scrapy[官网教程]","url":"/2017/05/25/20170525/","content":"\n#### 1.学习爬虫框架 Scrapy\n* 前几天一直在正Django的框架，现在基本上已经ok了，如果我们需要自己创建属于自己的网站、需要前台展示数据，后台可以编辑数据，可以插入到数据库，可以建立自己的数据类型，使用Django已经够了，那么现在有一个很重要的难题：数据从哪里来？怎么获取？如何存取？-> `Scrapy`能够很好满足我们这些需求。\n* 目前文档是线上最新的版本:`Scrapy 1.3`[https://docs.scrapy.org/en/latest/]\n\n#### 1.1 什么是Scrapy\n* `scrapy`是一个web端抓取网站数据的框架，可以用来数据挖掘，信息处理等等\n\n<!-- more -->\n\n#### 1.2 安装Scrapy\n* 安装scrapy官网建议两种途径：\n\n1.使用`conda`: \n```\n\nconda install -c conda-forge scrapy\n\n```\n \n\n2.使用`pip`: \n\n```\n\npip install Scrapy\n\n```\n\n* 官方建议，我们在安装`Scrapy`的时候，最好安装自己创建的虚拟环境中`a dedicated virtualenv`，这样至少不会与系统的包产生冲突。\n* `virtualenv`的安装网址为：[http://sourabhbajaj.com/mac-setup/Python/virtualenv.html]\n\n\n\n```\n//1.\ncd myproject/\n//2.\nvirtualenv venv \n// 如果你的系统已经安装了python2已经python3，但是你现在想建立一个python3的环境\n// virtualenv -p python3 envname\n//3.\nsource venv/bin/activate\n//4.\npip install Scrapy\n```\n\n\n* 执行完上面的4行命令，此时应该就可以安装好了`Scrapy`了。\n* 执行一下`pip list`，看一下安装`scrapy`系统默认给我们安装了什么：\n\n```\n\n(venv) ➜  venv pip list\nPackage          Version\n---------------- -------\nappdirs          1.4.3\nasn1crypto       0.22.0\nattrs            17.1.0\nAutomat          0.6.0\ncffi             1.10.0\nconstantly       15.1.0\ncryptography     1.8.1\ncssselect        1.0.1\nenum34           1.1.6\nidna             2.5\nincremental      16.10.1\nipaddress        1.0.18\nlxml             3.7.3\npackaging        16.8\nparsel           1.2.0\npip              9.0.1\npyasn1           0.2.3\npyasn1-modules   0.0.8\npycparser        2.17\nPyDispatcher     2.0.5\npyOpenSSL        17.0.0\npyparsing        2.2.0\nqueuelib         1.4.2\nScrapy           1.3.3\nservice-identity 16.0.0\nsetuptools       35.0.2\nsix              1.10.0\nTwisted          17.1.0\nw3lib            1.17.0\nwheel            0.29.0\nzope.interface   4.4.1\n\n```\n\n* `lxml`[http://lxml.de/], 高效的`xml`和`html`的解析框架，最低版本为`3.4`\n* `parsel`[https://pypi.python.org/pypi/parsel] ,在lxml的封装，解析`html/xml`的数据\n* `w3lib`[https://pypi.python.org/pypi/w3lib], 处理页面的url以及encodings\n* `twisted`[https://twistedmatrix.com/trac/], 异步的网络请求框架。最低版本为：`14.0`\n* `cryptography`和`pyOpenSSL`(最低版本为`0.14`) 多重网络安全\n\n#### 1.3 开始抓取数据：\n* 现在我们开始爬取页面，这里就爬取一下这个页面：`http://quotes.toscrape.com/`，这个网站列举了很多著名的导演，这个抓取的目的有下面几个：\n\n1. 创建一个新的`Scrapy`对象.\n2. 写一个`spider`对象抓取网站，并且解析数据\n3. 用命令行导出抓取的数据\n4. 改变规则，递归的抓取数据\n5. 运用`spider`的参数\n\n#### 1.3.1 新建scrapy项目\n\n```\n//1.\nscrapy startproject tutorial\n\n//2.\nNew Scrapy project 'tutorial', using template directory '/Users/gonghuan/Desktop/myproject/venv/lib/python2.7/site-packages/scrapy/templates/project', created in:\n    /Users/gonghuan/Desktop/myproject/venv/tutorial\n\nYou can start your first spider with:\n    cd tutorial\n    scrapy genspider example example.com\n```\n\n#### 1.3.2 创建我们第一个spider\n\n```\nimport scrapy\n\n\nclass QuotesSpider(scrapy.Spider):\n    name = \"quotes\"\n\n    def start_requests(self):\n        urls = [\n            'http://quotes.toscrape.com/page/1/',\n            'http://quotes.toscrape.com/page/2/',\n        ]\n        for url in urls:\n            yield scrapy.Request(url=url, callback=self.parse)\n\n    def parse(self, response):\n        page = response.url.split(\"/\")[-2]\n        filename = 'quotes-%s.html' % page\n        with open(filename, 'wb') as f:\n            f.write(response.body)\n        self.log('Saved file %s' % filename)\n```\n\n* `spider`是`Scrapy`用来抓取数据的类\n* 必须要继承`scrapy.Spider`，并且要初始化请求，抓取规则，解析数据的规则等等\n* `name`被赋值为`quotes`,这是作为项目的唯一标示符，必须唯一的。\n* `start_requests`的方法，必须要返回一个可以递归的`request`请求。\n* `parse`的方法，用来处理下载下来的`response`，`response`的参数保存在`TextResponse`的实例中。\n* `parse`的作用：1: 解析`response`,并将爬去下来的`dics`解析成我们需要的数据，2: 并且找到新的url数据，并且创建新的`request`\n* 最后执行`scrapy crawl quotes`,这个命令`quotes`就是我们刚才定义的name,然后他们将会向`quotes.toscrape.com`这个域名发起请求,终端也会出现下面的返回：\n\n```\n... (omitted for brevity)\n2016-12-16 21:24:05 [scrapy.core.engine] INFO: Spider opened\n2016-12-16 21:24:05 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)\n2016-12-16 21:24:05 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023\n2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (404) <GET http://quotes.toscrape.com/robots.txt> (referer: None)\n2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://quotes.toscrape.com/page/1/> (referer: None)\n2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://quotes.toscrape.com/page/2/> (referer: None)\n2016-12-16 21:24:05 [quotes] DEBUG: Saved file quotes-1.html\n2016-12-16 21:24:05 [quotes] DEBUG: Saved file quotes-2.html\n2016-12-16 21:24:05 [scrapy.core.engine] INFO: Closing spider (finished)\n...\n```\n\n* 此时检查项目的文件夹，会出现`quotes-1.html、quotes-2.html`这样的两个文件，就代表已经成功抓取下来了。\n* 刚才在`start_requests`的函数中，我们返回了`scrapy.Request`的对象，当这些请求一旦接受到服务器返回的`response`的时候，就会立刻调用callback的方法，也就是`parse`的方法，这个方法会包含刚才我们的请求的`url`以及相应的参数。\n\n#### 1.3.3 简写代码\n* 其实我们发现`start_requests`其实就是通过对于的`url`生成相应的`scrapy.Request`的对象，但其实我们可以不用实现`start_requests`的方法，我们可以直接定义一个`start_urls`的列表，里面的元素就是相应的请求`url`,一旦你定义了这个对象，`start_requests`会默认从`start_urls`来获取`url`\n* 即使在你的代码中没有指定的callback函数，`parse`的函数也会默认来处理每个url发起的请求，主要也是因为`parse`是系统默认的方法（当你没有准确的指定callback）\n* 修改为如下的代码：\n\n```\nimport scrapy\n\n\nclass QuotesSpider(scrapy.Spider):\n    name = \"quotes\"\n    start_urls = [\n        'http://quotes.toscrape.com/page/1/',\n        'http://quotes.toscrape.com/page/2/',\n    ]\n\n    def parse(self, response):\n        page = response.url.split(\"/\")[-2]\n        filename = 'quotes-%s.html' % page\n        with open(filename, 'wb') as f:\n            f.write(response.body)\n```\n\n#### 1.3.4 解析数据\n\n* 官方的建议，最好的解析是在`shell` [https://docs.scrapy.org/en/latest/topics/shell.html#topics-shell] 的操作下，在我们刚才创建的虚拟环境下执行如下的脚本`scrapy shell \"http://quotes.toscrape.com/page/1/\"`\n* 看到如下的终端返回：\n\n```\n[ ... Scrapy log here ... ]\n2016-09-19 12:09:27 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://quotes.toscrape.com/page/1/> (referer: None)\n[s] Available Scrapy objects:\n[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)\n[s]   crawler    <scrapy.crawler.Crawler object at 0x7fa91d888c90>\n[s]   item       {}\n[s]   request    <GET http://quotes.toscrape.com/page/1/>\n[s]   response   <200 http://quotes.toscrape.com/page/1/>\n[s]   settings   <scrapy.settings.Settings object at 0x7fa91d888c10>\n[s]   spider     <DefaultSpider 'default' at 0x7fa91c8af990>\n[s] Useful shortcuts:\n[s]   shelp()           Shell help (print this help)\n[s]   fetch(req_or_url) Fetch request (or URL) and update local objects\n[s]   view(response)    View response in a browser\n>>>\n```\n\n* 我们如何获取`response`里面的元素呢？可以通过`css` [https://www.w3.org/TR/selectors/]\n* 执行`response.css('title')`,就可以在终端看到如下的返回：\n\n```\n[<Selector xpath='descendant-or-self::title' data='<title>Quotes to Scrape</title>'>]\n```\n* 执行`response.css('title')`返回的是一个类似列表的一个东西，这个东西叫做`SelectorList`,这个列表里面就是搜索的对象，这些对象是`Selector`,这些`Selector`就是包装这些`XML/HTML`的外壳。你可以直接通过`Selector`直接获得里面的值：\n\n```\n>>> response.css('title').extract()\n['<title>Quotes to Scrape</title>']\n```\n* 你会发现还是一个列表，不是我们想要的值，这时我们就需要对css进行过滤，添加`::text`，就表示我们想要的只是`<title>`标签中对应的值\n\n```\n>>> response.css('title::text').extract()\n['Quotes to Scrape']\n```\n* 返回的还是一个列表，但是你确定你需要的是第一个元素的话，可以这样直接使用`extract_first`取得列表中的元素,这样为了避免产生`IndexError`：\n\n```\n>>> response.css('title::text').extract_first()\n'Quotes to Scrape'\n```\n\n* 除了使用`extract()`以及`extract_first()`,还是可以使用`re()`，就是通过正则来筛选解析的数据\n\n```\n>>> response.css('title::text').re(r'Quotes.*')\n['Quotes to Scrape']\n>>> response.css('title::text').re(r'Q\\w+')\n['Quotes']\n>>> response.css('title::text').re(r'(\\w+) to (\\w+)')\n['Quotes', 'Scrape']\n```\n\n#### 1.3.4 除了使用`CSS`，你也可以使用`XPath`来查找元素\n\n* 例如：\n\n```\n>>> response.xpath('//title')\n[<Selector xpath='//title' data='<title>Quotes to Scrape</title>'>]\n>>> response.xpath('//title/text()').extract_first()\n'Quotes to Scrape'\n```\n* `XPath`是非常形象具体，并且功能强大的，`CSS`的选择器也是通过一些接口来转化为`XPath`的，虽然`XPath`没有`CSS`那么出名，但是它还是非常强大的，官方也是建议学习使用`XPath`，给出相关的链接：\n\n1. [https://docs.scrapy.org/en/latest/topics/selectors.html#topics-selectors]\n2. [http://zvon.org/comp/r/tut-XPath_1.html]\n3. [http://plasmasturm.org/log/xpath101/]\n\n#### 1.3.5 解析数据\n\n* 现在你已经知道了一些关于选择器，获取数据的方法，现在就可以完善我们之前的爬虫了\n* 刚才我们爬去的的页面中，你会发现每个`http://quotes.toscrape.com`都含有一下的`html`：\n\n```\n<div class=\"quote\">\n    <span class=\"text\">“The world as we have created it is a process of our\n    thinking. It cannot be changed without changing our thinking.”</span>\n    <span>\n        by <small class=\"author\">Albert Einstein</small>\n        <a href=\"/author/Albert-Einstein\">(about)</a>\n    </span>\n    <div class=\"tags\">\n        Tags:\n        <a class=\"tag\" href=\"/tag/change/page/1/\">change</a>\n        <a class=\"tag\" href=\"/tag/deep-thoughts/page/1/\">deep-thoughts</a>\n        <a class=\"tag\" href=\"/tag/thinking/page/1/\">thinking</a>\n        <a class=\"tag\" href=\"/tag/world/page/1/\">world</a>\n    </div>\n</div>\n```\n\n* 还是通过`shell`的方法来测试，执行下面的代码:\n\n```\n//1.\nscrapy shell 'http://quotes.toscrape.com\n//2.\nresponse.css(\"div.quote\")\n```\n\n* 当然也可以把筛选后的数据，复制给每个变量：\n\n```\nquote = response.css(\"div.quote\")[0]\n```\n\n* 现在也可以通过解析`quote`来获得下面的值：`title`/`author`/`tag`\n\n```\n>>> title = quote.css(\"span.text::text\").extract_first()\n>>> title\n'“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”'\n>>> author = quote.css(\"small.author::text\").extract_first()\n>>> author\n'Albert Einstein'\n>>> tags = quote.css(\"div.tags a.tag::text\").extract()\n>>> tags\n['change', 'deep-thoughts', 'thinking', 'world']\n```\n\n* 已经可以知道我们是如何来获取数据的了，现在我们就可以遍历循环，并且将爬去下来的数据插入到我们的Python的字典数据结构中：\n\n```\n>>> for quote in response.css(\"div.quote\"):\n...     text = quote.css(\"span.text::text\").extract_first()\n...     author = quote.css(\"small.author::text\").extract_first()\n...     tags = quote.css(\"div.tags a.tag::text\").extract()\n...     print(dict(text=text, author=author, tags=tags))\n{'tags': ['change', 'deep-thoughts', 'thinking', 'world'], 'author': 'Albert Einstein', 'text': '“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”'}\n{'tags': ['abilities', 'choices'], 'author': 'J.K. Rowling', 'text': '“It is our choices, Harry, that show what we truly are, far more than our abilities.”'}\n    ... a few more of these, omitted for brevity\n>>>\n```\n\n#### 1.3.5 更新我们的spide代码：\n* 现在回到我们之前新建的`spider`的项目中去，到目前为止，我们还真正去获取任何的数据，我们只是做了一件事情，就是讲页面的`html`的代码保存在本地，我们可以将每个页面的数据，爬去下来，并且将这些数据放下Python的字典的数据结构中，并且返回回去。代码如下：\n\n```\nimport scrapy\n\n\nclass QuotesSpider(scrapy.Spider):\n    name = \"quotes\"\n    start_urls = [\n        'http://quotes.toscrape.com/page/1/',\n        'http://quotes.toscrape.com/page/2/',\n    ]\n\n    def parse(self, response):\n        for quote in response.css('div.quote'):\n            yield {\n                'text': quote.css('span.text::text').extract_first(),\n                'author': quote.css('small.author::text').extract_first(),\n                'tags': quote.css('div.tags a.tag::text').extract(),\n            }\n```\n\n* 运行之后看到如下的返回：\n\n```\n2016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from <200 http://quotes.toscrape.com/page/1/>\n{'tags': ['life', 'love'], 'author': 'André Gide', 'text': '“It is better to be hated for what you are than to be loved for what you are not.”'}\n2016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from <200 http://quotes.toscrape.com/page/1/>\n{'tags': ['edison', 'failure', 'inspirational', 'paraphrased'], 'author': 'Thomas A. Edison', 'text': \"“I have not failed. I've just found 10,000 ways that won't work.”\"}\n```\n\n#### 1.3.6 保存数据\n* 最简单的保存形式就是通过`Feed exports` [https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-exports]\n* 这里我们可以执行下面的代码保存为`json`的格式：\n\n```\nscrapy crawl quotes -o quotes.json\n```\n* 此时在文件中就会出现一个名叫`quotes.json`的文件，其实就是我们刚才爬去下来的数据。\n* 其实在一些简单的爬虫项目中，这样写，其实已经足够了，但是在一些复杂的大型项目中，可以写`Item Pipeline`[https://docs.scrapy.org/en/latest/topics/item-pipeline.html#topics-item-pipeline], 其实这个功能就是对应的项目的中`tutorial/pipelines.py`, `scrapy`项目默认会帮你创建的。\n\n#### 1.3.7 获取更多的url\n* 其实刚才在项目中，我们只是爬去了两个url，并且也知道如何去解析他们，但是可能我们需要的是爬去整个网站的url，比如我们在爬去一个页面的时候，遇到这样的`html`,我们就需要计算并且获取对应的`url`:\n\n```\n<ul class=\"pager\">\n    <li class=\"next\">\n        <a href=\"/page/2/\">Next <span aria-hidden=\"true\">&rarr;</span></a>\n    </li>\n</ul>\n```\n\n* 此时你可能需要获取的是`a`里面对应的`href`的值：\n\n```\n>>> response.css('li.next a::attr(href)').extract_first()\n'/page/2/'\n```\n\n* 现在我们可以修改我们的spider的代码了，并且不需要指定几个url了，我们需要将这些逻辑都放到`parse`的函数中去：\n\n```\nimport scrapy\n\n\nclass QuotesSpider(scrapy.Spider):\n    name = \"quotes\"\n    start_urls = [\n        'http://quotes.toscrape.com/page/1/',\n    ]\n\n    def parse(self, response):\n        for quote in response.css('div.quote'):\n            yield {\n                'text': quote.css('span.text::text').extract_first(),\n                'author': quote.css('small.author::text').extract_first(),\n                'tags': quote.css('div.tags a.tag::text').extract(),\n            }\n\n        next_page = response.css('li.next a::attr(href)').extract_first()\n        if next_page is not None:\n            next_page = response.urljoin(next_page)\n            yield scrapy.Request(next_page, callback=self.parse)\n```\n\n* 上面的代码很容易看出，当解析完数据之后，我们就会寻找`下一页`的`url`,并且发现这里写的是一个相对的url，这里可以通过`urljoin()`这个函数来拼接url，并且`yields`回去一个新的request，当拿到的`respsonse`又会回到`parse`的函数中来解析\n* scrapy的下载机制：当你`yields`一个新的请求，scrapy会发送改请求，并注册一个回调方法，以便在完成的时候能够解析他。\n\n#### 1.3.8 简化发送的请求 \n* 为了简化发送的请求，我们可以用`response.follow`, 而不是新建一个新的`Request`\n\n```\nimport scrapy\n\n\nclass QuotesSpider(scrapy.Spider):\n    name = \"quotes\"\n    start_urls = [\n        'http://quotes.toscrape.com/page/1/',\n    ]\n\n    def parse(self, response):\n        for quote in response.css('div.quote'):\n            yield {\n                'text': quote.css('span.text::text').extract_first(),\n                'author': quote.css('span small::text').extract_first(),\n                'tags': quote.css('div.tags a.tag::text').extract(),\n            }\n\n        next_page = response.css('li.next a::attr(href)').extract_first()\n        if next_page is not None:\n            yield response.follow(next_page, callback=self.parse)\n```\n\n* 与`scrapy.Request`不同，`response.follow`是支持相对路径，其实就是这个`follow`它会替我们做`response.urljoin`,并且`response.follow`返回是一个`Request`的实例。\n* 之前的代码，取的是列表中的第一项元素，但是我们也可以枚举这个列表，来调用`response.follow`\n\n```\nfor href in response.css('li.next a::attr(href)'):\n    yield response.follow(href, callback=self.parse)\n    \n// 也可以进行简写\nfor a in response.css('li.next a'):\n    yield response.follow(a, callback=self.parse)\n```\n\n* 对于抓取作者信息，我们可以自定义自己的回调函数\n\n```\nimport scrapy\n\n\nclass AuthorSpider(scrapy.Spider):\n    name = 'author'\n\n    start_urls = ['http://quotes.toscrape.com/']\n\n    def parse(self, response):\n        # follow links to author pages\n        for href in response.css('.author + a::attr(href)'):\n            yield response.follow(href, self.parse_author)\n\n        # follow pagination links\n        for href in response.css('li.next a::attr(href)'):\n            yield response.follow(href, self.parse)\n\n    def parse_author(self, response):\n        def extract_with_css(query):\n            return response.css(query).extract_first().strip()\n\n        yield {\n            'name': extract_with_css('h3.author-title::text'),\n            'birthdate': extract_with_css('.author-born-date::text'),\n            'bio': extract_with_css('.author-description::text'),\n        }\n\n```\n\n* 这里当找到`author`相关的链接，我们会回调我们自定义的函数`parse_author`,在这个函数里，我们顶一个帮助函数，帮助我们具体还获取里面的值，在`parse`函数中，我们会找到下一页的请求，然后继续发送请求，回调函数还是我们的`parse`的函数.\n* 这里有个关键的问题，我们不需要担心同一个`url`发送多次，易导致进入死循环，`Scrapy`默认是能够过滤已经请求过的url，并且你还可以通过在`settings.py`的文件中设置`DUPEFILTER_CLASS` [https://docs.scrapy.org/en/latest/topics/settings.html#std:setting-DUPEFILTER_CLASS]。\n\n\n#### 1.3.9 在spider中传递参数\n\n* 我们可以通过下面的`-a`来传递参数，这些参数默认是传递到Spider中的`__init__`函数中去，并且能够成为spider的属性值\n\n```\nscrapy crawl quotes -o quotes-humor.json -a tag=humor\n```\n\n* 例如上面的命令，我传递了`tag`的值，这样我就可以在我的spider项目中能够通过`self.tag`来获取传进来的值，也可以通过这样的值来请求准确url,其实就是请求的是这样的url: `http://quotes.toscrape.com/tag/humor`\n\n```\nimport scrapy\n\n\nclass QuotesSpider(scrapy.Spider):\n    name = \"quotes\"\n\n    def start_requests(self):\n        url = 'http://quotes.toscrape.com/'\n        tag = getattr(self, 'tag', None)\n        if tag is not None:\n            url = url + 'tag/' + tag\n        yield scrapy.Request(url, self.parse)\n\n    def parse(self, response):\n        for quote in response.css('div.quote'):\n            yield {\n                'text': quote.css('span.text::text').extract_first(),\n                'author': quote.css('small.author::text').extract_first(),\n            }\n\n        next_page = response.css('li.next a::attr(href)').extract_first()\n        if next_page is not None:\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python、Scrapy"],"categories":["日志"]},{"title":"学习Django第五/六部分，基本的测试用例[官网教程]","url":"/2017/05/17/20170517/","content":"\n### 经过前四部分的学习，此时我们已经创建了我们第一个app：polls, 并且根据我们自己的需求，修改了url，修改了对应的view函数，连接数据库，插入数据库相应的数据，并将数据库里的数据捞出来，显示在模板上，这似乎就是我们在前四部分做的事情，说起来简单，但是做好、做精细却不容易。下面我们会为我们的app提供测试的功能。\n\n#### 1.1 什么是自动测试\n* 测试是对代码对好检测，测试能够针对不同层面进行测试(1.对某个特定的方法是否按照预期返回都能够进行测试。2.有的人会对整个项目的整体操作做相应的测试`用户输入具体的某些值，得到预期的一些值`)，其实这里的测试与第二部分运用`shell`的操作是差不多的。\n* 而自动化测试区别在于，一旦你的自动化测试生成了之后，当你修改了代码之后，你不需要再花时间人工去测试，自动可以测试你的代码。\n\n<!-- more -->\n\n#### 1.2 写第一个测试用例\n* `polls`的应用存在一些小bug，在`Question`的Model中定义了这样一个方法，这个方法能够判断我们发布的时间是不是在一天之内的，如果在一天之内就会返回`True`，否则就是`False`：\n\n```\ndef was_published_recently(self):                                                                                          \n         return self.pub_date >= timezone.now() - datetime.timedelta(days=1)\n```\n* 运用`shell`,在终端输入`python manager.py shell`，然后再输入下面的代码：\n\n```\n>>> import datetime\n>>> from django.utils import timezone\n>>> from polls.models import Question\n>>> # create a Question instance with pub_date 30 days in the future\n>>> future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))\n>>> # was it published recently?\n>>> future_question.was_published_recently()\nTrue\n```\n* 这个显然是错误的，距离我发布的时间30天，应该返回`false`\n* 开始写自动化测试来发现暴露这个bug，至少在今后，不会再出现类似的问题了。\n* 打开`polls/tests.py`的文件，添加如下的代码：\n\n```\nimport datetime\n\nfrom django.utils import timezone\nfrom django.test import TestCase\n\nfrom .models import Question\n\n\nclass QuestionMethodTests(TestCase):\n\n    def test_was_published_recently_with_future_question(self):\n        \"\"\"\n        was_published_recently() should return False for questions whose\n        pub_date is in the future.\n        \"\"\"\n        time = timezone.now() + datetime.timedelta(days=30)\n        future_question = Question(pub_date=time)\n        self.assertIs(future_question.was_published_recently(), False)\n```\n* 这里创建了一个`django.test.TestCase`的子类，实例化了一个`Question`的对象，通过传入一个`time`的参数，然后断言`question`的`was_published_recently()`返回的为`false`\n* 执行`python manage.py test polls`\n\n```\nCreating test database for alias 'default'...\nSystem check identified no issues (0 silenced).\nF\n======================================================================\nFAIL: test_was_published_recently_with_future_question (polls.tests.QuestionMethodTests)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/path/to/mysite/polls/tests.py\", line 16, in test_was_published_recently_with_future_question\n    self.assertIs(future_question.was_published_recently(), False)\nAssertionError: True is not False\n\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nFAILED (failures=1)\nDestroying test database for alias 'default'...\n```\n* 执行`python manage.py test polls`是让Django去在`polls`这个app 应用中查找`你写的测试用例`，当`Django`查找到`django.test.TestCase`的子类，Django将会为这个测试创建一些数据，Django接着去寻找以`test`开头的测试方法,在刚才我们创建的`test_was_published_recently_with_future_question`这个函数，第二行中，传入了一个`pub_date`创建了一个`Question`的实例对象，接着就断言`question`的`was_published_recently()`返回为`False`, 但是实际上返回的是`True`,这也就是导致我们断言失败的原因所在。\n\n#### 1.3 修改bug\n* 此时我们已经知道了如果我们设置的`pub_date`是将来的时间的话，`Question.was_published_recently()`就应该返回的是`False`,所以打开`polls/models.py`修改为：\n\n```\ndef was_published_recently(self):\n    now = timezone.now()\n    return now - datetime.timedelta(days=1) <= self.pub_date <= now\n```\n* 再次执行`python manage.py test polls`就会得到下面的正确反馈：\n\n```\nGhCoder_Site python manage.py test polls\nCreating test database for alias 'default'...\nSystem check identified no issues (0 silenced).\n.\n----------------------------------------------------------------------\nRan 1 test in 0.002s\n\nOK\nDestroying test database for alias 'default'...\n```\n\n#### 1.4 更全面的测试\n* 依旧测试`was_published_recently()`这个函数，让我们的测试更加全面，添加如下的两个方法：\n\n```\ndef test_was_published_recently_with_old_question(self):\n    \"\"\"\n    was_published_recently() should return False for questions whose\n    pub_date is older than 1 day.\n    \"\"\"\n    time = timezone.now() - datetime.timedelta(days=30)\n    old_question = Question(pub_date=time)\n    self.assertIs(old_question.was_published_recently(), False)\n\ndef test_was_published_recently_with_recent_question(self):\n    \"\"\"\n    was_published_recently() should return True for questions whose\n    pub_date is within the last day.\n    \"\"\"\n    time = timezone.now() - datetime.timedelta(hours=1)\n    recent_question = Question(pub_date=time)\n    self.assertIs(recent_question.was_published_recently(), True)\n```\n\n* 这里我们添加了超过一天的数据，以及一天之内的数据，测试返回回来都和我们的断言是一样的，这样我就能更加保证我们的代码没有问题了。\n\n#### 1.5 测试View\n* 之前我们的测试都是测试驱动的标准来写测试的，但是这也并不能涵盖我们所有的代码，`测试驱动`我们重点去关心具体的代码实现，但是`测试view`的话，我们重点是通过浏览器来模拟用户进行测试。\n\n##### 1.5.1 Django测试客户端\n* Django是提供测试客户端来模拟用户来具体与`view`进行交互，我们可以在`tests.py`文件中写代码，也可以通过`shell`来完成。\n* 其实说白了就是看不到界面，完全是通过`shell`脚本来模拟请求，能够正常解析到`response`、`response_code`、`response.content`、`response.context`等等\n* 我们先通过`shell`来完成`测试环境`的设置:\n\n```\n//1.\npython manager.py shell\n\n//2.\n>>> from django.test.utils import setup_test_environment\n>>> setup_test_environment()\n\n>>> from django.test import Client\n>>> # create an instance of the client for our use\n>>> client = Client()\n\n\n>>> # get a response from '/'\n>>> response = client.get('/')\n>>> # we should expect a 404 from that address; if you instead see an\n>>> # \"Invalid HTTP_HOST header\" error and a 400 response, you probably\n>>> # omitted the setup_test_environment() call described earlier.\n>>> response.status_code\n404\n>>> # on the other hand we should expect to find something at '/polls/'\n>>> # we'll use 'reverse()' rather than a hardcoded URL\n>>> from django.urls import reverse\n>>> response = client.get(reverse('polls:index'))\n>>> response.status_code\n200\n>>> response.content\nb'\\n    <ul>\\n    \\n        <li><a href=\"/polls/1/\">What&#39;s up?</a></li>\\n    \\n    </ul>\\n\\n'\n>>> response.context['latest_question_list']\n<QuerySet [<Question: What's up?>]>\n```\n\n##### 1.5.2 改善我们的View\n* 在第四部分的时候，我们依据类的形式来创建了view,在`polls/views.py`的文件中：\n\n```\nclass IndexView(generic.ListView):\n    template_name = 'polls/index.html'\n    context_object_name = 'latest_question_list'\n\n    def get_queryset(self):\n        \"\"\"Return the last five published questions.\"\"\"\n        return Question.objects.order_by('-pub_date')[:5]\n```\n* 这是之前的代码，我们现在想修改`get_queryset`这个方法，之前是返回最后的5条数据，现在我们希望通过时间来过滤：\n\n```\n//1.\nfrom django.utils import timezone\n\ndef get_queryset(self):\n    \"\"\"\n    Return the last five published questions (not including those set to be\n    published in the future).\n    \"\"\"\n    return Question.objects.filter(\n        pub_date__lte=timezone.now()\n    ).order_by('-pub_date')[:5]\n```\n* `Question.objects.filter(pub_date__lte=timezone.now())`意思是：`查找Question,并且他们的pub_date<=现在的时候`。\n\n##### 1.5.3 测试我们新的页面\n* 在`polls/tests.py`的文件中添加如下的代码：\n\n```\n//1.\nfrom django.urls import reverse\n\ndef create_question(question_text, days):\n    \"\"\"\n    Creates a question with the given `question_text` and published the\n    given number of `days` offset to now (negative for questions published\n    in the past, positive for questions that have yet to be published).\n    \"\"\"\n    time = timezone.now() + datetime.timedelta(days=days)\n    return Question.objects.create(question_text=question_text, pub_date=time)\n\n\nclass QuestionViewTests(TestCase):\n    def test_index_view_with_no_questions(self):\n        \"\"\"\n        If no questions exist, an appropriate message should be displayed.\n        \"\"\"\n        response = self.client.get(reverse('polls:index'))\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"No polls are available.\")\n        self.assertQuerysetEqual(response.context['latest_question_list'], [])\n\n    def test_index_view_with_a_past_question(self):\n        \"\"\"\n        Questions with a pub_date in the past should be displayed on the\n        index page.\n        \"\"\"\n        create_question(question_text=\"Past question.\", days=-30)\n        response = self.client.get(reverse('polls:index'))\n        self.assertQuerysetEqual(\n            response.context['latest_question_list'],\n            ['<Question: Past question.>']\n        )\n\n    def test_index_view_with_a_future_question(self):\n        \"\"\"\n        Questions with a pub_date in the future should not be displayed on\n        the index page.\n        \"\"\"\n        create_question(question_text=\"Future question.\", days=30)\n        response = self.client.get(reverse('polls:index'))\n        self.assertContains(response, \"No polls are available.\")\n        self.assertQuerysetEqual(response.context['latest_question_list'], [])\n\n    def test_index_view_with_future_question_and_past_question(self):\n        \"\"\"\n        Even if both past and future questions exist, only past questions\n        should be displayed.\n        \"\"\"\n        create_question(question_text=\"Past question.\", days=-30)\n        create_question(question_text=\"Future question.\", days=30)\n        response = self.client.get(reverse('polls:index'))\n        self.assertQuerysetEqual(\n            response.context['latest_question_list'],\n            ['<Question: Past question.>']\n        )\n\n    def test_index_view_with_two_past_questions(self):\n        \"\"\"\n        The questions index page may display multiple questions.\n        \"\"\"\n        create_question(question_text=\"Past question 1.\", days=-30)\n        create_question(question_text=\"Past question 2.\", days=-5)\n        response = self.client.get(reverse('polls:index'))\n        self.assertQuerysetEqual(\n            response.context['latest_question_list'],\n            ['<Question: Past question 2.>', '<Question: Past question 1.>']\n        )\n```\n\n* 仔细看一下你就会发现：\n1. 这里`create_question`是一个快生产`question`的函数。\n2. `test_index_view_with_a_past_question`我们不创建任何的`question`对象，我们的的一些断言，这个测试就素在测试`如果数据库里面没有我们需要的数据`，我们该如何处理，检测了`response`以及`response.context`。这里用到了`assertContains()` and `assertQuerysetEqual()`\n3. 在下面的测试同样。\n\n##### 1.5.4 测试详情页面\n* 打开`polls/views.py`修改为,详情页面也要过滤掉将来的时间点的数据：\n\n```\nclass DetailView(generic.DetailView):\n    ...\n    def get_queryset(self):\n        \"\"\"\n        Excludes any questions that aren't published yet.\n        \"\"\"\n        return Question.objects.filter(pub_date__lte=timezone.now())\n```\n\n* 此时再添加一下测试数据，打开`polls/tests.py`：\n\n```\nclass QuestionIndexDetailTests(TestCase):\n    def test_detail_view_with_a_future_question(self):\n        \"\"\"\n        The detail view of a question with a pub_date in the future should\n        return a 404 not found.\n        \"\"\"\n        future_question = create_question(question_text='Future question.', days=5)\n        url = reverse('polls:detail', args=(future_question.id,))\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 404)\n\n    def test_detail_view_with_a_past_question(self):\n        \"\"\"\n        The detail view of a question with a pub_date in the past should\n        display the question's text.\n        \"\"\"\n        past_question = create_question(question_text='Past Question.', days=-5)\n        url = reverse('polls:detail', args=(past_question.id,))\n        response = self.client.get(url)\n        self.assertContains(response, past_question.question_text)\n```\n\n```\nGhCoder_Site python manage.py test polls\nCreating test database for alias 'default'...\nSystem check identified no issues (0 silenced).\n..........\n----------------------------------------------------------------------\nRan 10 tests in 0.058s\n\nOK\nDestroying test database for alias 'default'...\n```\n\n* 还有一些进阶的测试工具：\n1. `Selenium`[http://seleniumhq.org/]\n2. `LiveServerTestCase` [https://docs.djangoproject.com/en/1.11/topics/testing/tools/#django.test.LiveServerTestCase]\n\n##### 1.5.5 自定义项目app\n1.添加`css`样式：\n\n* 在创建项目的时候，项目中的`HTML`/`JavaScript`/`CSS`都是用来呈现页面以及布局的时候需要用到，我们应该把这些文件统一放到`static files`的文件里面去。这里`django.contrib.staticfiles\u0010`替我们都做好了。\n* 首先在`polls`的目录中添加`static`的文件夹，Django将会自动去找`static`文件夹中的文件。\n* 在`static`下面在添加`polls`文件夹，再在`polls`文件夹里面再添加`style.css`,里面添加如下的操作：\n\n```\nli a {\n    color: green;\n}\n```\n* 然后在`polls/templates/polls/index.html`文件里面添加如下的代码：\n\n```\n{ % load static % }\n\n<link rel=\"stylesheet\" type=\"text/css\" href=\"{ % static 'polls/style.css' % }\" />\n```\n* `{ % static % }`tag能够生成static文件夹的绝对url。\n\n2.添加图片的样式\n* 创建一个`images`文件夹，路径为`polls/static/polls/images/xxx.png`,然后就可以在`css`的文件中添加如下的代码\n\n```\nbody {\n    background: white url(\"images/xxx.png\") no-repeat right bottom;\n}\n```\n\n\n\n\n\n\n\n","tags":["Python、Django"],"categories":["日志"]},{"title":"学习Django第四部分，细化系统模板[官网教程]","url":"/2017/05/16/20170516/","content":"\n#### 1.8：细化views页面的功能\n* 打开`polls/detail.html`的文件，将其中的代码修改一下：\n\n```\n<h1>{ { question.question_text } }</h1>\n\n{ % if error_message % }<p><strong>{ { error_message } }</strong></p>{ % endif % }\n\n<form action=\"{ % url 'polls:vote' question.id % }\" method=\"post\">\n{ % csrf_token % }\n{ % for choice in question.choice_set.all % }\n    <input type=\"radio\" name=\"choice\" id=\"choice{ { forloop.counter } }\" value=\"{ { choice.id } }\" />\n    <label for=\"choice{ { forloop.counter } }\">{ { choice.choice_text } }</label><br />\n{ % endfor % }\n<input type=\"submit\" value=\"Vote\" />\n</form>\n```\n<!-- more -->\n\n* 这里的改动比较大,在页面上显示了勾选按钮，`value`与`question.id`类型关联起来了，`name`的值写死为`choice`,当某人勾选了一个，并且点击的提交的按钮，那么就会post的数据为：`choice=#`。\n* 定义了一个`form`, 并且`method=post`\n* `forloop.counter`就指明了多少次循环\n* 因为我们运用了`post`的请求，所以我们需要防止他们跨域请求，并且篡改数据，这里我们需要感谢Django,他给我们定义了{ % csrf_token % }这个标记，就是为了防止被篡改数据\n* 现在来处理post过来的请求，并且做出相应的处理。打开`polls/urls.py`\n\n```\nfrom django.shortcuts import get_object_or_404, render\nfrom django.http import HttpResponseRedirect, HttpResponse\nfrom django.urls import reverse\n\nfrom .models import Choice, Question\n# ...\ndef vote(request, question_id):\n    question = get_object_or_404(Question, pk=question_id)\n    try:\n        selected_choice = question.choice_set.get(pk=request.POST['choice'])\n    except (KeyError, Choice.DoesNotExist):\n        # Redisplay the question voting form.\n        return render(request, 'polls/detail.html', {\n            'question': question,\n            'error_message': \"You didn't select a choice.\",\n        })\n    else:\n        selected_choice.votes += 1\n        selected_choice.save()\n        # Always return an HttpResponseRedirect after successfully dealing\n        # with POST data. This prevents data from being posted twice if a\n        # user hits the Back button.\n        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))\n```\n\n* 这里的`request.POST`就是个字典类型的数据，通过取`request.POST['choice']`得到的是选中的id，并且以字符串的形式返回。\n* 在`request.POST`中，提供了`KeyError`的错误，当你要去的key不在post的字段里面，就会拿到这样的错误。\n* 注意到当成功之后，相应的votes加1之后，我们返回的不是`HttpResponse`,而是`HttpResponseRedirect`,接受一个参数，这个参数就是成功之后调教的url。并且官网提出了，当成功完成post之后，就是应该跳转页面，这不仅仅是Django要求的，而是作为web开发所必须要养成的好习惯。\n* 最后注意到我们在`HttpResponseRedirect`里面用到了`reverse()`，其实他的作用就是为了解决硬编码的问题，其实`reverse('polls:results', args=(question.id,)` = `/polls/3/results/`\n* 看到成功返回的页面为`results`的函数：\n\n```\nfrom django.shortcuts import get_object_or_404, render\n\ndef results(request, question_id):\n    question = get_object_or_404(Question, pk=question_id)\n    return render(request, 'polls/results.html', {'question': question})\n```\n* 在这里需要创建`polls/results.html`的模板页面\n\n```\n<h1>{ { question.question_text } }</h1>\n\n<ul>\n{ % for choice in question.choice_set.all % }\n    <li>{ { choice.choice_text } } -- { { choice.votes } } vote{ { choice.votes|pluralize } }</li>\n{ % endfor % }\n</ul>\n\n<a href=\"{ % url 'polls:detail' question.id % }\">Vote again?</a>\n```\n* 此时选中之后的结果页面就可以正常显示的了：\n\n```\nWhat's up?\n\n    Not much -- 4 vote s\n    The sky -- 1 vote\n    Just hacking again -- 0 vote s\n    Just kidding -- 0 vote s\n```\n* 这里官网提了一个意见，就是`selected_choice = question.choice_set.get(pk=request.POST['choice'])`,这个数据是从数据库中取出来的，但是如果两个用户同一时间做次操作，并且进行投票的话，这里会存在一个竞争的关系，这里官网给出的意见是用函数`F()`来避免这种情况 [https://docs.djangoproject.com/en/1.11/ref/models/expressions/#avoiding-race-conditions-using-f]\n\n#### 1.9：使用通用视图让代码少点\n* 可能你已经发现了，`detail`和`results`的页面非常的相近，这里我们会做出改变\n* 这些`views`页面都做了一些类似的事情，`根据URL从数据库中得到数据`,`加载模板，并且显示出来`，这些操作都是雷同的，此时我们可以通过`通用视图`来减少我们的代码量\n\n##### 1.9.1 修改URLconf\n* 打开`polls/urls.py`文件修改为：\n\n```\nfrom django.conf.urls import url\n\nfrom . import views\n\napp_name = 'polls'\nurlpatterns = [\n    url(r'^$', views.IndexView.as_view(), name='index'),\n    url(r'^(?P<pk>[0-9]+)/$', views.DetailView.as_view(), name='detail'),\n    url(r'^(?P<pk>[0-9]+)/results/$', views.ResultsView.as_view(), name='results'),\n    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),\n]\n```\n* 这里做了两个改变1：一个是讲参数的名字丢该为了`pk`, 2:将views只想的函数方式修改了，只是是在同一个类中调用不同的属性是使用方法，现在是调用不同类的方式，或许是类是更好的条件继承、重用代码的吧。\n\n##### 1.9.2 修改views\n* 打开`polls/views.py`文件修改为：\n\n```\nfrom django.shortcuts import get_object_or_404, render\nfrom django.http import HttpResponseRedirect\nfrom django.urls import reverse\nfrom django.views import generic\n\nfrom .models import Choice, Question\n\n\nclass IndexView(generic.ListView):\n    template_name = 'polls/index.html'\n    context_object_name = 'latest_question_list'\n\n    def get_queryset(self):\n        \"\"\"Return the last five published questions.\"\"\"\n        return Question.objects.order_by('-pub_date')[:5]\n\n\nclass DetailView(generic.DetailView):\n    model = Question\n    template_name = 'polls/detail.html'\n\n\nclass ResultsView(generic.DetailView):\n    model = Question\n    template_name = 'polls/results.html'\n\n\ndef vote(request, question_id):\n    ... # same as above, no changes needed.\n```\n\n* 这里用到了`ListView`和`DetailView`，分别需要去去继承他们，他们其实都是一些抽象的概念。\n* 每个通用视图都需要一个model的字段，因此你需要丢一个Model字段。\n* `DetailView`显示需要从URL中获取`pk`的字段，所以我们在写url的时候，将`quesiton_id`的参数名字修改为了`pk`。\n* `DetailView`需要使用的模板名字为：`<app name>/<module name>_detail.name`，在我们现在的项目中，模板的名字为：`polls/question_detail.html`,这里模板名字的存在是为告诉Django需要使用特定名称的模板，而不是使用默认生成的模板，这里你就会发现`detail`和`result`虽然继承的都是`DetailView`,但是他们指定了不同模板名字，这就让显示不同的模板名字。\n* 类似的`ListView`也是一样的，默认Django会去找`<app name>/<model name>_list.html`，但是由于我们定义了`template_name`,因此他只会找`polls/index.html`\n* 在之前我们都是通过丢一个名叫`question`以及`latest_question_list`的值给模板的，对`DetailView`而言：`question`的值是默认会被生成的，因为我们运用了Django model(Question),Django 是能够通过名字自动检测的。\n* 而在`ListView`中，我们用到了`latest_question_list`,Django默认会生成`question_list`,但是我们需要的是`latest_question_list`,因此我们需要覆写这个属性`context_object_name`，将它准确定义为我们需要的名字`latest_question_list`\n* 模板这部分 确实还是挺复杂的，主要是我们不太熟悉一些字段的用法、含义，可以自行参考 [https://docs.djangoproject.com/en/1.11/topics/class-based-views/]","tags":["Python、Django"],"categories":["日志"]},{"title":"学习Django第三部分，重点关注如何运用系统模板,并且自定义URL[官网教程]","url":"/2017/05/15/20170515/","content":"\n### 1.开始写新的Views\n* 打开`polls/views.py`文件，写views的函数和写其他的函数略有不同，因为他们可以接受参数，写入下面的代码：\n\n```\ndef detail(request, question_id):\n    return HttpResponse(\"You're looking at question %s.\" % question_id)\n\ndef results(request, question_id):\n    response = \"You're looking at the results of question %s.\"\n    return HttpResponse(response % question_id)\n\ndef vote(request, question_id):\n    return HttpResponse(\"You're voting on question %s.\" % question_id)\n```\n<!-- more -->\n* 写完了views的这些函数，其实这些函数只是简单的返回一些字符串，下面来出来一些关于url的函数处理`polls/urls.py`：\n\n```\nfrom django.conf.urls import url\n\nfrom . import views\n\nurlpatterns = [\n    # ex: /polls/\n    url(r'^$', views.index, name='index'),\n    # ex: /polls/5/\n    url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n    # ex: /polls/5/results/\n    url(r'^(?P<question_id>[0-9]+)/results/$', views.results, name='results'),\n    # ex: /polls/5/vote/\n    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),\n]\n```\n* 现在当你再去访问`/polls/34`、`/polls/34/results/`、`/polls/34/vote/`你就可以看到，这些能够对应到刚才你写的几个函数了。\n* 当你访问的url为`/polls/34/`的时候，此时Django将先找到项目中的`urls`模块，（其实就是加载项目中的urls.py的文件），它将会找到名为`urlpatterns`这个列表，看看在你的列表的项目中，有没有出现你访问的url的条目，当系统找到`^polls/`之后，就会去掉`^polls/`,然后将剩下的`34/`发送给`polls.urls`进行更深的解析，终于在`polls/urls.py的urlpatterns`列表中找到了这行代码` url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail')`,因为这行代码的第二个参数是指向的`views.detail`函数句柄，这里其实执行的是下面的代码：\n\n```\ndetail(request=<HttpRequest object>, question_id='34')\n```\n* 而这里的`question_id='34'`,部分是因为我们写的这部分正则:`(?P<question_id>[0-9]+)`,括号所包含的内容将作为一个参数传给对应的函数, `?P<question_id>`定义了传给函数的形参名\n\n#### 1.1:具体处理一些页面的请求\n\n* 每个页面应该可以做1-2件事情，返回http的请求，可以通过HttpResponse[https://docs.djangoproject.com/en/1.11/ref/request-response/#django.http.HttpResponse], 还有些未找到页面Django也给了响应的便利返回Http404[https://docs.djangoproject.com/en/1.11/topics/http/views/#django.http.Http404], 其实说白了每个页面它希望得到的是HttpResponse能够处理正常的逻辑，要不然就是`exception`，打开polls/views.py\n\n\n```\nfrom django.http import HttpResponse\nfrom .models import Question\n\ndef index(request):\n    latest_question_list = Question.objects.order_by('-pub_date')[:5]\n    output = ', '.join([q.question_text for q in latest_question_list])\n    return HttpResponse(output)\n```\n\n* 这里当你再次访问`/polls/`的时候，你就可以看到在第二部分数据库操作插入的数据了，但是我们如何让我们的界面显示的好看一点呢，这里就需要引入`template`模板，现在我们`polls`的文件夹中创建`templates`文件夹，Django将会自动去这个文件夹中去寻找模板。\n* 这里还要说一下，如果在`settings.py`文件中`APP_DIRS`设置的是`TRUE`的话，Django的模板默认就会去INSTALL_APPS去寻找对应的`templates`的文件夹。\n* 系统给我们的意见是，让我们在`templates`文件夹下面再创建一个`polls`的文件夹，在`polls`的文件夹内再创建`index.html`,总的路径应该是这样的：`polls/templates/polls/index.html`，这样创建的是为了方便我们在调用模板的时候方便、易读`polls/index.html`\n* 下面再刚创建的`index.html`中添加如下的代码：\n\n```\n{ % if latest_question_list % }\n    <ul>\n    { % for question in latest_question_list % }\n        <li><a href=\"/polls/{ { question.id } }/\">{ { question.question_text } }</a></li>\n    { % endfor % }\n    </ul>\n{ % else % }\n    <p>No polls are available.</p>\n{ % endif % }\n```\n\n* 显示的模板已经写完了，下面再将之前的`views.py`的函数修改一下：\n\n```\nfrom django.http import HttpResponse\nfrom django.template import loader\n\nfrom .models import Question\n\n\ndef index(request):\n    latest_question_list = Question.objects.order_by('-pub_date')[:5]\n    template = loader.get_template('polls/index.html')\n    context = {\n        'latest_question_list': latest_question_list,\n    }\n    return HttpResponse(template.render(context, request))\n```\n\n#### 1.2：render()函数\n* 这里我们可以通过`render()`函数来简写我们的模板，直接可以通过`render函数`,并且也不需要放回`HttpResponse`,也不需要`loader`函数来载入我们的模板了\n* `render()`函数将`request`作为第一个参数，模板的名字作为第二个参数，第三个参数为可选参数，返回的是`HttpResponse`的对象。\n* 用render之后，代码改变为：\n\n```\nfrom django.shortcuts import render\n\nfrom .models import Question\n\n\ndef index(request):\n    latest_question_list = Question.objects.order_by('-pub_date')[:5]\n    context = {'latest_question_list': latest_question_list}\n    return render(request, 'polls/index.html', context)\n```\n\n#### 1.3：下面来处理一下404的错误页面\n```\nfrom django.http import Http404\nfrom django.shortcuts import render\n\nfrom .models import Question\n# ...\ndef detail(request, question_id):\n    try:\n        question = Question.objects.get(pk=question_id)\n    except Question.DoesNotExist:\n        raise Http404(\"Question does not exist\")\n    return render(request, 'polls/detail.html', {'question': question})\n```\n\n* 这里的在详情页面的时候，如果访问主键不存在的话，我们应该抛出404的错误，让我们能够捕捉到错误。\n* 同时在`polls/detail.html`的文件中添加如在下代码：\n\n```\n{ { question } }\n```\n\n#### 1.4：404函数的缩写get_object_or_404()\n\n```\nfrom django.shortcuts import get_object_or_404, render\n\nfrom .models import Question\n# ...\ndef detail(request, question_id):\n    question = get_object_or_404(Question, pk=question_id)\n    return render(request, 'polls/detail.html', {'question': question})\n```\n* `get_object_or_404()`函数第一个参数为：Django的Model, 第二个参数，是一个列表，是任意数量参数的列表,当get不到任何东西的时候，就会返回Http404的对象。\n\n#### 1.5:使用系统模板\n* 回到我们之前写的`polls/detail.html`，改为这样：\n\n```\n<h1>{ { question.question_text } }</h1>\n<ul>\n{ % for choice in question.choice_set.all % }\n    <li>{ { choice.choice_text } }</li>\n{ % endfor % }\n</ul>\n```\n* 当我们运用系统的模板的时候，可以看到系统是用的`点语法`,例如`{ { question.question_text } }`，Django 先去寻找`question`这个对象是否存在，然后再去寻找`question`是否存在`question_text`的这个属性值。\n* ` { % for % } `这是一个for循环，`question.choice_set.all`=`question.choice_set.all()`这个返回的是一个包含`Choice`，可迭代的集合。\n* 系统模板更多信息[https://docs.djangoproject.com/en/1.11/topics/templates/]\n\n#### 1.6：去除系统模板中的硬编码\n\n* 我们在写`index.html`模板的时候，我们写到这样一段代码`<li><a href=\"/polls/{ { question.id } }/\">{ { question.question_text } }</a></li>`，通过我们在`views.py`的函数中将`question`的数据中传递到模板上，并且在模板上这样使用，道理上来说是没毛病的。\n* 这样写的问题，在于模板和数据，紧密耦合在一起，在很多模板中，假如我一旦修改了URL，我们就得去一堆的模板中修改这个写死的url。\n* 因为我们在`polls/urls.py`中已经用到了`url`的模块,那么我们就能够通过之前定义的url,并且知道下面将要跳转url。\n\n```\nurlpatterns = [\n               url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n          ]\n```\n\n* 因此可以修改为：\n\n```\n//修改前\n<li><a href=\"/polls/{ { question.id } }/\">{ { question.question_text } }</a></li>\n//修改后\n<li><a href=\"{ % url 'detail' question.id % }\">{ { question.question_text } }</a></li>\n```\n\n* 如果你想要修改详情页面的url，假如现在的url不是之前的`polls/12`,而是最新的url：`polls/specifics/12`,此时你只需要在你的url中加一个一个url，例如：\n\n```\n...\nurl(r'^specifics/(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n...\n```\n\n#### 1.7:URL的命名空间\n* 在这个项目中，我们仅仅只是创建了一个app，叫做`polls`,但是在实际的Django的项目中，其实会有10、20几个app, 那么我们在使用之前提到的`{ % url % }`,Django如何区分url呢？比如我`polls`下面有一个`detail`，假如我还有个新的app，下面也有一个`detail`,我改怎么区分呢？\n* 官方的意思是去定义`app_name`,打开`polls/url.py`\n\n```\nfrom django.conf.urls import url\n\nfrom . import views\n\napp_name = 'polls'\nurlpatterns = [\n    url(r'^$', views.index, name='index'),\n    url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n    url(r'^(?P<question_id>[0-9]+)/results/$', views.results, name='results'),\n    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),\n]\n```\n\n* 并且家模板里面的代码也做一下修改：\n\n```\n//未使用app_name\n<li><a href=\"{ % url 'detail' question.id % }\">{ { question.question_text } }</a></li>\n\n//使用app_name = 'polls'\n<li><a href=\"{ % url 'polls:detail' question.id % }\">{ { question.question_text } }</a></li>\n```\n\n\n#### ps: 最后说一下，hexo好坑呐！在markdown格式中不能出现\"{ {\" 以及 “{ %”,必须要在中间添加个空格。哎！无语。。。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python、Django"],"categories":["日志"]},{"title":"学习Django第二部分[官网教程]","url":"/2017/05/14/20170514/","content":"\n### 学习Django的第二部分[对官网Demo教程的翻译，以及自己的一些认识]\n\n#### 第一部分，已经使用了Django写了一个简单View，并且配置了我们的url，是的我们能够正常访问到我们新建的View页面。今天开始第二部分：\n<!-- more -->\n1. 我们需要到`xxxProject/settings.py`文件去修改配置，我们这里主要讲的是数据库的配置。\n2. Django默认是安装了SQLite，这里不需要额外下载什么。\n3. 如果需要用到别的数据库，可以去`settings`文件去修改。默认是这样的：\n\n```\nDATABASES = {\n      'default': {\n          'ENGINE': 'django.db.backends.sqlite3',\n          'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\n      }\n  }\n```\n\n#### 这里解释一下：\n * `ENGINE`字段根据选用数据库的不同，Django已经给我们做好了数据的枚举：`django.db.backends.sqlite3`,`django.db.backends.postgresql`,`django.db.backends.mysql`,`django.db.backends.oracle`\n * `NAME`数据库的名字\n * 如果你和我一样，不是选用的Django默认的使用的sqlite的话，除此之外，还需要配置`USER`,`PASSWORD`,`HOST`,我用的mysql,这里如果需要正常使用mysql的话，可能还需要安装其他的一些依赖库，这里可以参考 [https://docs.djangoproject.com/en/1.11/topics/install/#database-installation]\n * 官方给出了demo，可以根据自己的需求进行修改\n \n ```\n DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': 'mydatabase',\n        'USER': 'mydatabaseuser',\n        'PASSWORD': 'mypassword',\n        'HOST': '127.0.0.1',\n        'PORT': '5432',\n    }\n}\n ```\n\n#### 数据库配置好之后，然后我们开始配置`TIME_ZONE`,默认值为`America/Chicago`,如果在中国的话，应该是`Asia/Shanghai`北京时间吧，至于时区的列表： [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones]。\n\n#### 这里重点说一下`INSTALLED_APPS`的配置，放在这个选项中的列表的字符串，代表运行Django同事需要激活这些对应的Django应用，app能够在不同的project中使用，并且你也能够打包、分发给别人来使用。\n\n```\n# Application definition\n  \n  INSTALLED_APPS = [                                                                                                                                                                                      \n      'django.contrib.admin',//Django 的默认后台系统\n      'django.contrib.auth', //Django 的认证系统\n      'django.contrib.contenttypes', // 管理内容类型\n      'django.contrib.sessions', // 管理sessions\n      'django.contrib.messages', // 管理消息\n      'django.contrib.staticfiles', // 管理静态文件\n  ]\n```\n\n* 这些已经安装的，默认的app，至少会在后台建立1的表（现在还没有建立表呢），在执行了`python manage.py migrate`才会在我们的数据库里建立这里app的表。\n* 这里我在linux环境下安装的时候，遇到点问题：包了很多奇葩的错误，这里我就说几个，我遇到的，其他我没有列出来的，可能你直接google就能找到了：\n\n1. 通过`sudo pip install MySQL-python`来安装mysql的时候包这个错\n\n```\nCommand \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-7696Ic/MySQL-python/\n```\n#### 直接在命令行运行:\n\n```\nsudo apt install libmysqlclient-dev\npip install mysql\n```\n#### 还有其他的一些小问题： [http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c]\n\n#### 执行完 `python manage.py migrate` 就会看到终端出现这些字样，就代表你的表已经成功生成了, 如果不信，你也可以打开自己mysql数据库，就会发现Django已经为我生成好了表了。\n\n```\nOperations to perform:\n  Apply all migrations: admin, auth, contenttypes, sessions\nRunning migrations:\n  Applying contenttypes.0001_initial... OK\n  Applying auth.0001_initial... OK\n  Applying admin.0001_initial... OK\n  Applying admin.0002_logentry_remove_auto_add... OK\n  Applying contenttypes.0002_remove_content_type_name... OK\n  Applying auth.0002_alter_permission_name_max_length... OK\n  Applying auth.0003_alter_user_email_max_length... OK\n  Applying auth.0004_alter_user_username_opts... OK\n  Applying auth.0005_alter_user_last_login_null... OK\n  Applying auth.0006_require_contenttypes_0002... OK\n  Applying auth.0007_alter_validators_add_error_messages... OK\n  Applying auth.0008_alter_user_username_max_length... OK\n  Applying sessions.0001_initial... OK\n```\n\n#### 官方给出了关于`migrate`命令的作用，Django会去project中找我的settings.py文件，并且找到INSTALL_APPS，为这些安装的app创建必要的表, 并且官方也说了，这些默认的INSTALL_APPS并不是每个人都需要他，当不需要的时候，删除掉xxxProject/settings.py文件中对应的app，然后执行`migrate`就可以了。\n\n### 创建Model\n#### 好了，现在开始我们需要创建Model了，这也是我为什么喜欢Django的最最根本的原因，Django中的Model不同于其他语言中的Model对象，而是实质性的涉及到数据库的数据。\n1. 之前在第一章的时候，我们创建了一个属于我们自己的app，名字叫做`polls`的app,我们现在围绕这个app创建属于这个app的Model，我们创建两个Model，一个叫做`Question`,一个叫`Choice`,`Question`含有一个问题字段和发布时间的字段，`Choice`含有两个字段一个choice的Text的字段、一个vote的字段，<strong>并且一个choice会关联一个question字段</strong>，现在开始编辑`polls/models.py`文件：\n\n```\nfrom django.db import models\n\n\nclass Question(models.Model):\n    question_text = models.CharField(max_length=200)\n    pub_date = models.DateTimeField('date published')\n\n\nclass Choice(models.Model):\n    question = models.ForeignKey(Question, on_delete=models.CASCADE)\n    choice_text = models.CharField(max_length=200)\n    votes = models.IntegerField(default=0)\n```\n * 这些model的类都是`django.db.models.Model`的子类。\n * 这里的每个字段对应的就是数据库中的每个字段。\n * 一些字段是需要必须的参数的，比如`CharField`必须有参数`max_length`的存在。\n * 一些字段也可以传入一些可选的参数: 比如：`IntegerField`的`default`的字段。\n * `ForeignKey`可以通过外键的形式，将`choice`的类型关联到`Question`的类型上去，在Django的model数据中，是支持一对多，一对一，多对多的。\n \n ### 激活Model\n \n #### 上面虽然外面已经创建了这两个Model，但是目前为止，还没有和我现在有Django项目关联上，在此之前，我们必须要先激活Model,并且根据我们的model代码创建出对应的数据库表的信息。\n  * 首先我们先要将我们的`polls`的app安装上。去`settings.py`的INSTALL_APPS的列表中，将我们的`polls`app添加进去。\n  \n  ```\n  INSTALLED_APPS = [\n  \n    'polls.apps.PollsConfig',\n    \n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]\n  ```\n* 现在执行`python manage.py makemigrations polls`得到下面的信息：\n\n```\n polls/migrations/0001_initial.py\n    - Create model Choice\n    - Create model Question\n    - Add field question to choice\n```\n\n* 执行`makemigrations`的目的是告诉Django，你已经对你Model对了一些改变，你希望Django能够保存你的这些改变。\n* `Migrations`对你Model的变化仅仅只是将这些变化以文件的形式保存在磁盘中，这些文件，你都是可以看到的`polls/migrations/0001_initial.py`\n* 下面要执行`migrate`,将你之前Model的改变同步到数据库表中去。我们为了能够看到具体做了那些`SQL`上的改变，可以运行`sqlmigrate`,这个命令会返回对应SQL语句。执行之后，你会看到下面的返回：\n\n```\nGhCoder_Site python manage.py sqlmigrate polls 0001\nBEGIN;\n--\n-- Create model Choice\n--\nCREATE TABLE `polls_choice` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `choice_text` varchar(200) NOT NULL, `votes` integer NOT NULL);\n--\n-- Create model Question\n--\nCREATE TABLE `polls_question` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `question_text` varchar(200) NOT NULL, `pub_date` datetime(6) NOT NULL);\n--\n-- Add field question to choice\n--\nALTER TABLE `polls_choice` ADD COLUMN `question_id` integer NOT NULL;\nALTER TABLE `polls_choice` ADD CONSTRAINT `polls_choice_question_id_c5b4b260_fk_polls_question_id` FOREIGN KEY (`question_id`) REFERENCES `polls_question` (`id`);\nCOMMIT;\n```\n#### 注意到下面一些关键的点：\n* 首先表的名字是 `AppName_ModelName`。\n* 每个表中为我们自动创建了主键：`id`类型，并且默认不为空，且自增。\n* 外键的添加是`ModelName_id`。\n* `sqlmigrate`其实并没有对数据库做出相应的操作，他只是告诉你这是他将要对数据库所做出的操作，并且能够让你检查是否正确。\n\n```\n//执行下面的命令\npython manage.py migrate\n\n//得到下面的信息\nGhCoder_Site python manage.py migrate \nOperations to perform:\n  Apply all migrations: admin, auth, contenttypes, polls, sessions\nRunning migrations:\n  Applying polls.0001_initial... OK\n```\n\n#### 现在你也可以通过`phpmyadmin`，可以看到数据库中的表都已经如我们之前model定义的那样，创建好了，这就是`migragte`的魅力所在，可能你在以后的开发中，你根本不需要时不时的去修改数据库，增加修改某个字段，通过`migrate`就能够实现，只要三个步骤，你就可以显示了了。\n1. 改变Model，增加修改字段都可以。\n2. 执行`python manage.py makemigrations`来为这些变化创建`migrations`。\n3. 执行`python manage.py migrate`来修改数据库表。\n\n### 运用API来操作Model\n#### Django非常贴心地为我们提供shell的命令来操作数据。\n1. 在操作shell之前，我们首先要运行`python manage.py shell`。\n2. 然后我们就进入到了python的运行环境。下面这段代码是官网给我的，我觉得很详细，也很具体，我只是翻译了一下：\n\n```\n// 从polls.models文件中导入Question、Choice\n>>> from polls.models import Question, Choice   # Import the model classes we just wrote.\n\n// 在系统的内存中是否存在Question类型的数据\n# No questions are in the system yet.\n>>> Question.objects.all()\n<QuerySet []>\n\n# Create a new Question.\n# Support for time zones is enabled in the default settings file, so\n# Django expects a datetime with tzinfo for pub_date. Use timezone.now()\n# instead of datetime.datetime.now() and it will do the right thing.\n\n// 这里创建了Question的数据结构，这个数据结构需要两个字段，一个是字符串，一个date的数据类型，date的数据类型，我这里用timezone来创建，因此这里导入了timezone的模块\n>>> from django.utils import timezone\n>>> q = Question(question_text=\"What's new?\", pub_date=timezone.now())\n\n// q的实例执行保存的方法\n# Save the object into the database. You have to call save() explicitly.\n>>> q.save()\n\n// 直接返回里q的id，这里返回的是int，还是long，是根据你选择的数据库来定的。\n# Now it has an ID. Note that this might say \"1L\" instead of \"1\", depending\n# on which database you're using. That's no biggie; it just means your\n# database backend prefers to return integers as Python long integer\n# objects.\n>>> q.id\n1\n\n// 返回question的实例的属性值\n# Access model field values via Python attributes.\n>>> q.question_text\n\"What's new?\"\n>>> q.pub_date\ndatetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)\n\n// 同时也可以修改question实例的属性值，但是要记住保存\n# Change values by changing the attributes, then calling save().\n>>> q.question_text = \"What's up?\"\n>>> q.save()\n\n// 返回内存中所有的Question类型的数据\n# objects.all() displays all the questions in the database.\n>>> Question.objects.all()\n<QuerySet [<Question: Question object>]>\n```\n\n#### 这里在执行`Question.objects.all()`，返回是`<QuerySet [<Question: Question object>]>`，这样可读性不是很好，官方的意思说：只要分别在model文件中覆写`def __str__(self):`方法就可以了。\n\n```\nfrom django.db import models\nfrom django.utils.encoding import python_2_unicode_compatible\n\n@python_2_unicode_compatible  # only if you need to support Python 2\nclass Question(models.Model):\n    # ...\n    def __str__(self):\n        return self.question_text\n\n@python_2_unicode_compatible  # only if you need to support Python 2\nclass Choice(models.Model):\n    # ...\n    def __str__(self):\n        return self.choice_text\n```\n\n```\n>>> from polls.models import Question, Choice\n\n# Make sure our __str__() addition worked.\n// 从这里就可以看到我们刚才覆写“def __str__(self):”的作用了\n>>> Question.objects.all()\n<QuerySet [<Question: What's up?>]>\n\n# Django provides a rich database lookup API that's entirely driven by\n# keyword arguments.\n// Django 可以通过filter字段来过滤\n// 也可以通过双下划线来自定义过滤条件\n>>> Question.objects.filter(id=1)\n<QuerySet [<Question: What's up?>]>\n>>> Question.objects.filter(question_text__startswith='What')\n<QuerySet [<Question: What's up?>]>\n\n# Get the question that was published this year.\n// 导入一些自定义的模块\n// 生成响应的实例对象，并且用来过滤\n>>> from django.utils import timezone\n>>> current_year = timezone.now().year\n>>> Question.objects.get(pub_date__year=current_year)\n<Question: What's up?>\n\n# Request an ID that doesn't exist, this will raise an exception.\n// 如果直接通过get的方式来获取某些对象的话，如果对象不存在的话，就会抛出异常\n>>> Question.objects.get(id=2)\nTraceback (most recent call last):\n    ...\nDoesNotExist: Question matching query does not exist.\n\n# Lookup by a primary key is the most common case, so Django provides a\n# shortcut for primary-key exact lookups.\n# The following is identical to Question.objects.get(id=1).\n// 查询主键\n>>> Question.objects.get(pk=1)\n<Question: What's up?>\n\n# Make sure our custom method worked.\n>>> q = Question.objects.get(pk=1)\n// 调用自定义的方法\n>>> q.was_published_recently()\nTrue\n\n# Give the Question a couple of Choices. The create call constructs a new\n# Choice object, does the INSERT statement, adds the choice to the set\n# of available choices and returns the new Choice object. Django creates\n# a set to hold the \"other side\" of a ForeignKey relation\n# (e.g. a question's choice) which can be accessed via the API.\n>>> q = Question.objects.get(pk=1)\n\n# Display any choices from the related object set -- none so far.\n// 通过set能过找到有没有对应的外键对象存在\n>>> q.choice_set.all()\n<QuerySet []>\n\n# Create three choices.\n// 通过create能够创建关联的对象，创建的方法其实就是就可以把它看做是简单的实例化方法，传入对应的字段就可以了。\n>>> q.choice_set.create(choice_text='Not much', votes=0)\n<Choice: Not much>\n>>> q.choice_set.create(choice_text='The sky', votes=0)\n<Choice: The sky>\n>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)\n\n# Choice objects have API access to their related Question objects.\n>>> c.question\n<Question: What's up?>\n\n# And vice versa: Question objects get access to Choice objects.\n// 取得所有区这个Question 关联的 Choice的对象\n>>> q.choice_set.all()\n<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>\n>>> q.choice_set.count()\n3\n\n# The API automatically follows relationships as far as you need.\n# Use double underscores to separate relationships.\n# This works as many levels deep as you want; there's no limit.\n# Find all Choices for any question whose pub_date is in this year\n# (reusing the 'current_year' variable we created above).\n// 可以通过双下划线，在数据结构中找到关系\n>>> Choice.objects.filter(question__pub_date__year=current_year)\n<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>\n\n// 删除数据\n# Let's delete one of the choices. Use delete() for that.\n>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')\n>>> c.delete()\n```\n* 这些`shell`的操作，你以为都只是在内存里操作的话，你就错了。<strong>打开你的数据库，你会发现你的这些shell的操作会实际操作到数据库的</strong>\n* 系统更多关于`shell`的操作在这里，你可以自己去查阅\n\n1. [https://docs.djangoproject.com/en/1.11/ref/models/relations/]\n2. [https://docs.djangoproject.com/en/1.11/topics/db/queries/]\n3. [https://docs.djangoproject.com/en/1.11/topics/db/queries/#field-lookups-intro]\n\n### 下面介绍Django的一个牛逼的后台，他叫`admin`\n* 首先我们得先创建我们的最高权限的用户。\n* 执行`python manage.py createsuperuser`\n\n```\nGhCoder_Site python manage.py createsuperuser\nUsername (leave blank to use 'parallels'): gonghuan\nEmail address: 11@11.com\nPassword: \nPassword (again): \nSuperuser created successfully.\n```\n\n* 再次执行`python manage.py runserver`,然后打开`http://127.0.0.1:8000/admin/`，你就会看到admin的后台登录系统了。\n* 登录进去，你只会看见`user`,`group`的模块，那如何把我们之前创建的`polls`的app，展现在后台呢？方便我编辑数据？\n* 打开`polls/admin.py`,并且我们需要告诉admin，Question这个数据类型，admin是有数据接口的，可以控制他。编辑如下代码：\n\n```\nfrom django.contrib import admin\n\nfrom .models import Question\n\nadmin.site.register(Question)\n```\n*此时我们就可以看到我们的Question的配置出现在后台了，并且可以增删改查了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python、Django"],"categories":["日志"]},{"title":"用Python的Django框架搭建前后台[官网教程]","url":"/2017/05/09/20170509/","content":"\n### 人生苦短，我用Python--不管你之前写过多少其他语言，当你有一天回来写python的时候，你就会觉得“世界是那么的美好！”\n\n\n#### 今天我就来讲讲我是如何用`Python`的`django`[https://docs.djangoproject.com] 来搭建后台的：\n<!-- more -->\n1. 我是在mac的环境下搭建的，linux也试过，其实搭建环境来说，都差不多,这里就以mac为例子\n2. 首先mac或者linux的话，应该是自带python的，如果是win系统的话，你可以自己去下载[https://www.python.org/]\n3. 数据库（database）也是很重要的，因为我们想做的是一个健全的前后台系统、后期还需要给移动端提供数据来源，所以我这里选用mysql，我这里偷懒就用了`MAMP`一键安装，在linux下也有相应的叫`LAMP`,一步步点击下一步之后就完成了，这里我用的是`Apache+Mysql`。安装完成之后，你就可以看到mysql的端口、密码、用户名啥的（这里可能有些坑，需要自己去踩，这里就不说了，自行google),这里要弄好，因为我们后续在配置django的时候需要配置。\n4. 下面进入正式安装jdango，官方建议通过pip去安装。\n\n```\npip install -U pip\n```\n##### 如果报错就执行下面的命令：\n```\npip install --upgrade pip\n```\n##### 不出意外的话，此时你的pip，应该已经安装好了。下面来安装环境，这里环境，官方的意见是安装`virtualenv`或者`virtualenvwrapper`,这里其实我都试过，你也可以试试，这里就用`virtualenv` [https://virtualenv.pypa.io/en/stable/] , 你也可以自己参考一下virtualenv的官方介绍 [https://virtualenv.pypa.io/en/stable/installation/] :\n```\n[sudo] pip install virtualenv\n```\n##### 最后执行安装`django`的命令：\n```\npip install Django\n```\n##### 官方给出了严重你是否安装成功，以及安装的版本,当成功打印的时候，就代表已经成功安装了。\n```\n>>> import django\n>>> print(django.get_version())\n1.11\n```\n##### 也可以直接在终端输入\n```\npython -m django --version\n```\n\n#### 直接开始项目：\n1. 直接在终端输入：此时在当前路径下就会看到我们创建的`GhCoder_Site`文件夹：\n\n```\ndjango-admin startproject GhCoder_Site\n```\n\n2. 文件夹的结构：\n\n```\n├── GhCoder_Site\n│   ├── __init__.py\n│   ├── settings.py\n│   ├── urls.py\n│   └── wsgi.py\n└── manage.py\n```\n\n#### 这里官方给了一些解释，我觉得很好，有助于我们的理解, 其实我之前都是写php的，深有感触--note:\n> If your background is in plain old PHP (with no use of modern frameworks), you’re probably used to putting code under the Web server’s document root (in a place such as /var/www). With Django, you don’t do that. It’s not a good idea to put any of this Python code within your Web server’s document root, because it risks the possibility that people may be able to view your code over the Web. That’s not good for security.\nPut your code in some directory outside of the document root, such as /home/mycode.\n\n#### 官方对于每个文件夹以及文件的作用都做了一定的解释，这里我就不解释了很通俗易懂：\n* The outer GhCoder_Site/ root directory is just a container for your project. Its name doesn’t matter to Django; you can rename it to anything you like.\n* manage.py: A command-line utility that lets you interact with this Django project in various ways. You can read all the details about manage.py in django-admin and manage.py.\n* The inner GhCoder_Site/ directory is the actual Python package for your project. Its name is the Python package name you’ll need to use to import anything inside it (e.g. GhCoder_Site.urls).\n* GhCoder_Site/__init__.py: An empty file that tells Python that this directory should be considered a Python package. If you’re a Python beginner, read more about packages in the official Python docs.\n* GhCoder_Site/settings.py: Settings/configuration for this Django project. Django settings will tell you all about how settings work.\n* GhCoder_Site/urls.py: The URL declarations for this Django project; a “table of contents” of your Django-powered site. You can read more about URLs in URL dispatcher.\n* GhCoder_Site/wsgi.py: An entry-point for WSGI-compatible web servers to serve your project. See How to deploy with WSGI for more details.\n\n#### 下面直接运行下面的命令：\n```\npython manage.py runserver\n```\n#### 你会得到这样的反馈：\n```\nPerforming system checks...\n\nSystem check identified no issues (0 silenced).\n\n//请忽略这里\nYou have 13 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.\nRun 'python manage.py migrate' to apply them.\n\nMay 09, 2017 - 07:08:16\nDjango version 1.11, using settings 'GhCoder_Site.settings'\nStarting development server at http://127.0.0.1:8000/\nQuit the server with CONTROL-C.\n```\n#### 此时打开浏览器，输入`http://127.0.0.1:8000/`，你就会看到`Welcome to Django” page, in pleasant, light-blue pastel. It worked!`，就代表成功了。\n\n#### 切换端口：\n```\npython manage.py runserver 8080\n```\n#### 切换ip、监听所有的ip\n```\npython manage.py runserver 0:8000\n```\n\n### Django的开发模式都是依赖于一个个app，这一点我非常喜欢，后期就算项目很大，也不会很乱，创建第一个app:\n\n```\npython manage.py startapp polls\n```\n### 结构如下：\n\n```\n.\n├── db.sqlite3\n├── GhCoder_Site\n│   ├── __init__.py\n│   ├── __init__.pyc\n│   ├── settings.py\n│   ├── settings.pyc\n│   ├── urls.py\n│   ├── urls.pyc\n│   ├── wsgi.py\n│   └── wsgi.pyc\n├── manage.py\n└── polls\n    ├── admin.py\n    ├── apps.py\n    ├── __init__.py\n    ├── migrations\n    │   └── __init__.py\n    ├── models.py\n    ├── tests.py\n    └── views.py\n```\n\n#### 创建第一个views,打开`polls/views.py`,输入：\n```\ndef index(request):\n      return HttpResponse(\"Hello, world, You are in polls app\")\n```\n\n#### 现在配置一下路由,到文件`polls`,创建一个名为`urls.py`的文件。将之前写的view和这个url对应上：\n```\nfrom django.conf.urls import url                                                                                                                      \nfrom . import views\n   \nurlpatterns = [\n               url(r'^$', views.index, name='index')\n           ]\n```\n\n#### 最后将app的url，写到项目中的urls.py的文件里面去，到`GhCoder_Site/urls.py`文件里面，添加如下代码：\n```\nfrom django.conf.urls import include, url\nfrom django.contrib import admin\n\nurlpatterns = [\n    url(r'^polls/', include('polls.urls')),\n    url(r'^admin/', admin.site.urls),\n]\n```\n\n#### 这里关于include的官方介绍：\n> The include() function allows referencing other URLconfs. Note that the regular expressions for the include() function doesn’t have a $ (end-of-string match character) but rather a trailing slash. Whenever Django encounters include(), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing.\n\n> The idea behind include() is to make it easy to plug-and-play URLs. Since polls are in their own URLconf (polls/urls.py), they can be placed under “/polls/”, or under “/fun_polls/”, or under “/content/polls/”, or any other path root, and the app will still work.\n\n#### 此时你访问`http://127.0.0.1:8000/polls/`就看到你刚才写的view以及url\n\n\n\n\n\n\n\n\n\n","tags":["Python、Django"],"categories":["日志"]},{"title":"Object-C 网管、以及切换AppDelegate的RootViewCtroller","url":"/2017/05/05/20170505/","content":"\n## 昨天将最新版1.9.5发布上线。总结一下这一版本中踩过的坑。\n\n### 产品的需求：\n1. app中默认是游客身份，随着不同身份的切换，可能需要切换不同的网管。(假如请求的url为: `http://www.siji.com/a.php`,那么随着身份的切换的话，可能 `http://www.siji.com`需要修改为`http://www.chengke.com`)，并且有些请求，是不需要依赖身份的：(比如登录部分请求就是`http://www.login.com/login.php`、支付部分的请求就是`http://www.pay.com/pay.php`)。\n<!-- more -->\n2. app中需要区分两种身份(例如 1.司机身份 2.乘客身份)，未来可能还需要更多身份去切换，伴随着身份切换，可能UI上会发生重大的改变，例如：司机身份是UITabBarController为rootViewController的，乘客身份只是(UIViewController+UISlideViewController)侧滑的样式。\n\n<strong>之前发布的版本，有一点很重的线程安全的问题，我没有考虑到，现在我已经做了响应的修改了。在关于能够修改字典、数组的方法中我都用到了NSRecursiveLock，从而能够保证线程是安全的。属性的相关安全性，我也查了些资料：[https://zhuanlan.zhihu.com/p/23998703]</strong>\n\n\n### 解决第一个问题：\n1. 首先我这里希望我在app刚进来的时候，就配置好，并且我这里希望他是线程安全，并且方便get/set值。这里我选用`单例`。并且在系统刚进来的时候就配置, 我已经加入cocoapods了：[https://github.com/Ghstart/GateWayObject]：\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    self.window = [[RootWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n\n    //1.设置默认URL，就是其中一种身份对应的URL\n    //2.设置一些URL的映射，不会根据之前身份设置来修改\n    [GateWayObject sharedInstanceWithDefaultURL:@\"https://cz.redlion56.com/gwcz/\"\n                                    ReflectURLS:@{\n                                                  @\"user/login.do\": @\"https://login.redlion56.com/gwlogin/user/login.do\",\n                                                  @\"uic/user/logout.do\": @\"https://cz.redlion56.com/gwcz/uic/user/logout.do\"\n                                                  }];\n                                                  \n    // 3. 设置乘客身份对应的网管                          \n    [[GateWayObject currentGateWay] setGateWayURL:@\"https://cz.redlion56.com/gwcz/\"\n                                     forKeyObject:carownerRole];\n     \n    // 4.设置乘客对应的网管\n    [[GateWayObject currentGateWay] setGateWayURL:@\"https://sj.redlion56.com/gwsj/\"\n                                     forKeyObject:driverRole];\n}\n```\n\n```\n// 5.并且还可以根据相应的条件来切换网管\n  if (xxx) {\n        \n        [[GateWayObject currentGateWay] swichGateWayBaseOn:carownerRole];\n        \n    } else {\n        \n        [[GateWayObject currentGateWay] swichGateWayBaseOn:driverRole];\n    }\n```\n\n```\n// 7.直接可以取得次环境下对应的正确URL\n[self GET:[[GateWayObject currentGateWay] currentURLBaseOnRelativeURL:url]\n   parameters:parameters\n      success:^(NSURLSessionDataTask *task, id responseObject) {\n          }\n      } failure:^(NSURLSessionDataTask *task, NSError *error) {\n          if (failure && error.code != -999 && ![error.localizedDescription isEqualToString:@\"已取消\"]) {\n              failure(error);\n          }\n      }];\n```\n\n### 下面看一下我的.h文件：\n```\n@interface GateWayObject : NSObject\n\n@property (nonatomic, readonly) NSString    *currentRelateURL;\n\n///////////-init-//////////////\n/*\n ** 获得当前的网管\n */\n\n+ (GateWayObject *)currentGateWay;\n\n/*\n ** 网管实例化方法\n ** 默认网关\n */\n+ (GateWayObject *)sharedInstanceWithDefaultURL:(NSString *)url;\n\n/*\n ** 网关实例化\n ** 可以配置一些默认的URL对应的一些网关\n */\n+ (GateWayObject *)sharedInstanceWithDefaultURL:(NSString *)url ReflectURLS:(NSDictionary *)reflectURLS;\n\n/*\n ** 设置网关\n */\n- (void)setGateWayURL:(NSString *)url forKeyObject:(id)keyObject;\n\n/*\n ** 设置默认的一些网关，优先级仅次于http/https\n */\n- (void)setDefaultRelativeURL:(NSString *)relativeURL fullURL:(NSString *)fullURL;\n\n/*\n ** 根据之前的设置的身份切换网管\n ** 返回值为true则切换成功 false失败\n */\n- (BOOL)swichGateWayBaseOn:(id)keyObject;\n\n/*\n ** 取得当前URL\n */\n- (NSString *)currentURLBaseOnRelativeURL:(NSString *)url;\n\n\n@end\n```\n\n### 第二个问题的解决方案，自定义`RootWindow`,让它集成于 `UIWindow`，并且覆写，然后自己写一套新的stroyboard，每次身份切换的时候，直接切换keyWindow的rootViewController\n\n```\n- (void)setRootViewController:(UIViewController *)rootViewController\n{\n\t// 这里我发现在某些设备上由于push、present之后就不能够正常销毁,这里就需要你去判断，做相应的pop、dismiss之后，在去setRootViewController\n\t// 但是后来又发现系统的navigation的栈，栈的弹出需要时间才能弹出，不是立刻弹出啊的，这里就很鸡肋了，目前我还没想到啥解决方案。\n    [UIViewController fastToRootVC];\n    \n    //remove old rootViewController's sub views\n    for (UIView* subView in self.rootViewController.view.subviews)\n    {\n        [subView removeFromSuperview];\n    }\n    \n    //remove old rootViewController's view\n    [self.rootViewController.view removeFromSuperview];\n    \n    //set new rootViewController\n    [super setRootViewController:rootViewController];\n    \n    //remove empty UILayoutContainerView(s) remaining on root window\n    for (UIView *subView in self.subviews)\n    {\n        if (subView.subviews.count == 0)\n        {\n            [subView removeFromSuperview];\n        }\n    }\n}\n```\n\n\n","tags":["Object-c"],"categories":["日志"]},{"title":"关于PHP7的新坑","url":"/2017/03/27/20170327/","content":"## 距离上次写PHP已经过了2、3年了，最近闲来无事，想再整整PHP。我是通过mac安装了虚拟机，Ubuntn16.04的版本，在安装PHP环境的时候，就发现很多坑，一些小问题google可以查到的我这里就不说了，在安装完Apache、PHP、Mysql的时候，并且安装完Phpmyadmin的时候，会报错：\n\n<!-- more -->\n\n\n```\nThe mysqli extension is missing....\n```\n### google一搜就会发现：\n\n```\nsudo apt-get install php5-mysql\n```\n### 这里对应的php5的安装，那你这里是写`php7.0-mysql`还是写`php7.1-mysql`就需要看你安装php的版本号了。你可以通过`<?php echo phpinfo();?>`、也可以通过`php --version`可以知道，你需要安装的是多少。\n\n## 在调用mysql的时候，之前我记得我很久之前就一直都在使用`mysql_connect()`这个函数来连接数据库，但是最近我发现我通过这个函数、没有任何的反馈，通过try/catch也没有任何error、这个问题一直纠结了好久，今天才发现原来在`php7`的版本的时候，已经完全废弃了这个函数了，而是已经使用`mysqli_connect()`,\n\n### 这里是PHP官方手册的说明：\n\n```\nWarning\n本扩展自 PHP 5.5.0 起已废弃，并在自 PHP 7.0.0 开始被移除。应使用 MySQLi 或 PDO_MySQL 扩展来替换之。参见 MySQL：选择 API 指南以及相关 FAQ 来获取更多信息。用以替代本函数的有：\nmysqli_connect()\nPDO::__construct()\n```\n\n### 所以我这里就用mysqli_connect()来替换，我这里建立一个video的库，并且建了一个test的表：\n\n```\n$servername = \"localhost\";\n$username = \"root\";\n$password = \"123456789\";\n$dbname = \"video\";\n\n// Create connection\n$conn = new mysqli($servername, $username, $password, $dbname);\n// Check connection\nif ($conn->connect_error) {\n    die(\"Connection failed: \" . $conn->connect_error);\n} \n\n$sql = \"SELECT * FROM test\";\n$result = $conn->query($sql);\n\nif($result -> num_rows > 0) {\n    while($row = $result -> fetch_assoc()) {\n        echo \"Name: \".$row[\"name\"].\"-Status: \".$row[\"status\"].\"-Time:\".$row[\"time\"].\"<br>\";\n    }\n} else {\n    echo 'no datas';\n}\n\n$result->close();\n```\n\n\n\n\n\n\n\n","tags":["PHP"],"categories":["日志"]},{"title":"更新Reveal2的一些问题","url":"/2017/03/15/20170315/","content":"\n### 最近任务也不是很多，尽量逼自己把每天学的一些的东西都记录下来。\n\n<!-- more -->\n---\n\n{% qnimg 103.jpeg %}\n\n> 这张图来自`简书`APP，也是一个朋友闻起来来的，他说这是在无数据、无网络的状态下就会出现这样的界面，这个是怎么做到的呢？\n\n1 . 我当时想了一下，还是觉得要用collectionView来实现吧，其实`热门文章`的内容，其实自己看就会发现，他就一种cell格式，而`热门专题`应该就是用collectionview来做的吧。\n\n2 .后来一拍脑子觉得不对啊，这tm得多烦啊，而且这个仅仅只是无数据的一种页面的展示啊，要我做，那就直接一张image遮罩着不就行了。\n\n### 猜想了半天还是用Reveal来看一下吧。\n\n1 .由于很长时间不用Reveal了，而且我之前的Reveal还是1.x的版本，然后用越狱机器一看，一直导入失败，一直在报这个错误(❌)\n\n> The operation couldn’t be completed. The app is linked against an older version of the Reveal library. You may need to update the Reveal library in your app. \n\n2 .后来发现之前导入到机器中的一个`libReveal.dylib`的文件以及找不到了，这下，我tm傻眼了，我一直以为让我更新一下这个所谓的动态库呢！ 后来google了一下，发现了官方的回复：\n\n>We no longer ship a dynamic library starting with Reveal 2, we include an iOS 8+ framework instead. The good news is that you should be able to make a copy of, and rename the framework's binary (RevealServer.framework/ReveaServer) to libReveal.dylib and then follow the instructions as before\n\n### 最后还发现几个好玩的东西：\n\n---\n{% qnimg 104.jpeg %}\n\n---\n\n{% qnimg 105.jpeg %}\n\n>可以发现真的就如我的猜想，他其实这些都是之前就定死的一个image，遮罩在上面的，其他也就不用说了。\n\n\n","tags":["Reveal"],"categories":["日志"]},{"title":"尝试Swift搭建服务器-建立自己的网站","url":"/2017/02/25/20170225/","content":"\n\n## 学习Paul大神的swift-server，我也尝试用Swift来搭建自己的网站。这里主要依赖的是IBM开源的Kitura框架。\n\n<!-- more -->\n\n### 环境搭建 （Mac下）\n\n1. 因为我们是在自己的mac上搭建环境，所以需要下载Docker[https://docs.docker.com/docker-for-mac/] 这个软件，这个软件的作用就相当于一台看不见的虚拟机，能够在mac上运行Linux。\n2. 下载完成之后，建立根目录文件夹。\n\n```\ncd ~/Desktop\nmkdir server\ncd server\ndocker run -itv $(pwd):/projects --name projects -w /projects -p 8089:8089 -p 8090:8090 -p 5984:5984 twostraws/server-side-swift /bin/bash\n```\n3 . 这里docker开头的命令，是让doker软件来运行的，其中'/projects' 指的是文件内建立以projects开头的文件默认指向的是当前的文件路径，并且建立的8090、5984这两个端口。\n\n4 . 建立好之后你就会看到类似如下的返回值：\n\n```\nroot@f2429f0045db:/projects#\n```\n\n### 建立第一个文件\n\n1. 运行如下命令：\n\n```\ncd ~/Desktop/server\nmkdir project1\ncd project1\nswift package init --type executable\n```\n#### 最后一行命令可能比较困惑，其实这行命令就是告诉swift package（这里的swift package相当于OC中的cocoapods、或者NodeJS中的npm一样）,我们需要建立一个新的项目，’--type executable‘的意思是我们希望建立一个独立的部分。看到如下返回值就代表成功了：\n\n```\nCreating executable package: project1\nCreating Package.swift\nCreating .gitignore\nCreating Sources/\nCreating Sources/main.swift\nCreating Tests/\n```\n\n2 .运行：\n\n```\nswift build\n```\n\n3 . 再运行\n\n```\n.build/debug/project1\n```\n当看到\"Hello world!\"就代表已经成功了。\n\n4 .再运行\n\n```\nswift package generate-xcodeproj\n```\n\n此时用Xcode打开刚刚生成的project1.xcodeproj,切换project1>Sources>project1,当控制台中打印“Hello world!”\n\n5 . 找到Main.swift文件，更换内容，我们引入路由模块，并且实例化，并且监听8090端口\n\n```\nimport Kitura\n\nlet router = Router()\n\nKitura.addHTTPServer(onPort: 8090, with: router)\nKitura.run()\n```\n\n此时打开浏览器\"http://localhost:8090\",大功告成！！！\n\n### 环境搭建 （Linux下）\n\n1. 先下载适合你Linux版本的Swift的版本[https://swift.org/download/]\n\n1. 其实这里Kitura的官网给出了教程，你也可以按照官方的教程走下去。[http://www.kitura.io/en/starter/settingup.html]\n\n```\n$ sudo apt-get update\n$ sudo apt-get install clang libicu-dev libcurl4-openssl-dev libssl-dev\n```\n\n\n```\n$ export PATH=<path to uncompressed tar contents>/usr/bin:$PATH\n```\n2 .这里已经介绍解释的很清楚了，就是将<>以及其中的内容替换成你刚才下载并解压下来的Swift包路径，假设我的路径为/home/gh/swift-3.0.2-release/, 那就可以在终端运行：\n\n```\n$ export PATH=/home/gh/swift-3.0.2-release/usr/bin:$PATH\n```\n\n3 .紧接着运行,看到正常的返回就代表已经安装正常。\n\n```\nswift --version\n```\n\n4 .下面的方法步骤就和之前在Mac上的配置是一样的了，你也可以参考Kitura的教程[http://www.kitura.io/en/starter/gettingstarted.html]\n","tags":["Swift"],"categories":["日志"]},{"title":"学习阿里开源项目BeeHive(三)","url":"/2016/12/01/20161201/","content":"\n\n### 最后总结一下整个BeeHive项目的搭建。以及我看完之后的一些质疑和想法，有些作者以及给出了回答，会在下一版本的更新中进行修改。\n---\n#### 先贴上我自己画的一个提纲\n\n{% qnimg step1.png %} \n<!-- more --> \n---\n{% qnimg step3.png %}\n---\n#### 首先，为什么每个ViewController都需要配备一个配备一个Module的文件？\n\n因为他需要通过`+(void)load{}`的方法，动态的将`moduleInfo`的信息存储下来，这里是存储在`BHModuleManager`文件中的`self.BHModules`*此时这里存储的都是字符串，还没有创建为实例对象*。\n---\n#### 为什么有些`module`的文件中没有load方法，但是他还是在启动之前也注册进去了呢？答：因为这里作者都是通过`宏`的的形式，来快速实现加载的信息，本质上和`+(void)load{}`是一样的。\n\n*BH_EXPORT_MODULE(NO)*  \n---\n#### 这里在官方的demo中看到TestAppDelegate进行了ModuleConfigName、ServiceConfigName的设置，不设置可以吗？答：可以！！这里在`BHContext`对象实例化的时候，已经默认设置了初始值了。\n---\n#### 这里假如我有新的功能，我应该往哪里去添加呢？答：*这里只是我的猜想*->应该在`BHContext`中去添加，因为在`BHContext`实例化的时候，就顺带实例化了一系列的对象：`BHShortCutItem`、`BHOpenURLItem`、`BHNotificationItem`、`BHUserActivity`、`BHConfig`,并且这些对象都是单例，这里我保持我的态度。*这里的if调试时作者的笔误，他会在下一版本更新 if ([BHInstance isKindOfClass:[BHContext class]]) {}*\n\n\n```\n-(instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.modulesByName  = [[NSMutableDictionary alloc] initWithCapacity:1];\n        self.servicesByName  = [[NSMutableDictionary alloc] initWithCapacity:1];\n        self.moduleConfigName = @\"BeeHive.bundle/BeeHive\";\n        self.serviceConfigName = @\"BeeHive.bundle/BHService\";\n\n#if __IPHONE_OS_VERSION_MAX_ALLOWED > 80400\n        self.touchShortcutItem = [BHShortcutItem new];\n#endif\n\n        self.openURLItem = [BHOpenURLItem new];\n        self.notificationsItem = [BHNotificationsItem new];\n        self.userActivityItem = [BHUserActivityItem new];\n    }\n\n    return self;\n}\n```\n\n```\n+(instancetype) shareInstance\n{\n    static dispatch_once_t p;\n    static id BHInstance = nil;\n\n    dispatch_once(&p, ^{\n        BHInstance = [[[self class] alloc] init];\n        if ([BHInstance isKindOfClass:[BHContext class]]) {\n            ((BHContext *) BHInstance).config = [BHConfig shareInstance];\n        }\n    });\n\n    return BHInstance;\n}\n```\n---\n#### 系统是在什么时候载入本地的组件信息的呢？答：是在哎`BeeHive`调用`setContext`对象的时候，进行调用的。并且这里通过`context`中的文件名，进行拼接，返回plist文件的信息。 *比起在这里将self.BHModules 文件信息换成了响应的实例对象*\n---\n#### 那看到各个`Module`都会调用`modSetUp`、`modInit`类似的方法，那这些方法是在什么时候调用的？答：是在调用父类的`Appdelegate`的方法的时候调用的，\n---\n#### 初了一些主动调用的上面这些方法，那什么时候才会调用系统的方法，类似进入后台、被挂起、进入前台。答：这是在appdelegate的响应方法调用的时候，也会调用。\n","tags":["学习"],"categories":["日志"]},{"title":"学习阿里开源项目BeeHive(二)","url":"/2016/11/28/20161128/","content":"\n### 紧接着前面那篇文章，回到`BHAppDelegate.m`的文件里面的\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n```\n<!-- more -->\n\n之前已经把所有的timeProdiler的这个类的作用，实例，已经public的方法都已经说了。在这个方法的实现中，作者还做了另外一件事情。\n\n```\n    [[BHModuleManager sharedManager] tiggerEvent:BHMSetupEvent];\n    [[BHModuleManager sharedManager] tiggerEvent:BHMInitEvent];\n\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[BHModuleManager sharedManager] tiggerEvent:BHMSplashEvent];\n    });\n```\n\n1. `BHModuleManager`从字面上理解应该就是管理模块之前调用逻辑的意思，并且在`BHModuleManager.m`中，我们可以看出来这个类也是个单例。\n2. 在init之后，紧接着就是调用`- (void)tiggerEvent:(BHModuleEventType)eventType;`的方法。\n3. 在这个方法的实现中可以看到一个很长的swich语句，遍历你传入的一个枚举类型，来做一系列的事情。\n4. 先看在`didFinishLaunch`中，第一次调用这个方法，传入的参数为`BHMSetupEvent`。\n\n```\n case BHMSetupEvent:\n [self handleModuleEvent:kSetupSelector];\n break;\n```\n\n```\n- (void)handleModuleEvent:(NSString *)selectorStr\n{\n    SEL seletor = NSSelectorFromString(selectorStr);\n    [self.BHModules enumerateObjectsUsingBlock:^(id<BHModuleProtocol> moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) {\n        if ([moduleInstance respondsToSelector:seletor]) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n            [moduleInstance performSelector:seletor withObject:self.wholeContext];\n#pragma clang diagnostic pop\n\n        [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@\"%@ --- %@\", [moduleInstance class], NSStringFromSelector(seletor)]];\n\n        }\n    }];\n}\n```\n\n1. 可以看到传入了一个字符串作为入参，而这个参数写在这个文件的.m中。`static  NSString *kSetupSelector = @\"modSetUp:\";`写死了。\n2. 紧接着在`handleModuleEvent`的实现中，通过runtime的NSSelectorFromString的方法将字符串转化为SEL的类型。\n3. 再枚举BHModules数组，从枚举中我们发现，不是所有的object对象都添加在BHModules的MutableArray中，这些object的对象必须要遵守`id<BHModuleProtocol>`的协议。\n4. 查询数组中有没有对象可以响应这个方法的，如果有的话，就调用这个方法，并且开始reordTime。\n5. 并且为了消除编译器所报的警告，可以通过添加`#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"`,来消除warning。\n\n#### 紧接着调用了同一个方法，却传入了不同的参数\n\n```\n [[BHModuleManager sharedManager] tiggerEvent:BHMInitEvent];\n\n\n  case BHMInitEvent:\n  //special\n  [self handleModulesInitEvent];\n  break;\n```\n\n```\n- (void)handleModulesInitEvent\n{\n\n    [self.BHModules enumerateObjectsUsingBlock:^(id<BHModuleProtocol> moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) {\n        __weak typeof(&*self) wself = self;\n        void ( ^ bk )();\n        bk = ^(){\n            __strong typeof(&*self) sself = wself;\n            if (sself) {\n                if ([moduleInstance respondsToSelector:@selector(modInit:)]) {\n                    [moduleInstance modInit:sself.wholeContext];\n                }\n            }\n        };\n\n        [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@\"%@ --- modInit:\", [moduleInstance class]]];\n\n        if ([moduleInstance respondsToSelector:@selector(async)]) {\n            BOOL async = [moduleInstance async];\n\n            if (async) {\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    bk();\n                });\n\n            } else {\n                bk();\n            }\n        } else {\n            bk();\n        }\n    }];\n}\n```\n\n1. 首先循环遍历`self.BHModules`这个数组对象，先用Timer 开始记录下init方法的时间。\n2. 判断数组中的元素是否响应`async`的方法, 这个`- (BOOL)async;`的方法定义在`BHModuleProtocol`中，如果响应了这个方法，就取得这个方法的返回值,`从字面上判断这个变量记录了是否运行在多线程中，这里我只是个猜测`。\n3. 如果是在多线程中，就回到主线程中来执行上面所定义的block：`void ( ^ bk )();`，如果不是的话或者没有响应`async`,都直接运行这个block，应该默认状态下就是主线程了。\n4. 从代码上看来，就是不管在什么线程或者是否响应`async`的方法，上面的block是肯定要执行的。\n5. block中所做的事情也很简单，就是判断这个元素对象是否响应`- (void)modInit:(BHContext *)context;`,这个protocol的代理方法，如果响应的话，就会执行这段代码，至于这里的`BHContext`的对象，我目前没看到在哪里传入进来，这里只看到了一个`Setter`的方法。\n\n```\n- (void)setWholeContext:(BHContext *)wholeContext\n{\n    _wholeContext = wholeContext;\n    self.modulesConfigFilename = _wholeContext.moduleConfigName;\n}\n```\n\n#### 最后执行的一个方法\n\n```\n dispatch_async(dispatch_get_main_queue(), ^{\n        [[BHModuleManager sharedManager] tiggerEvent:BHMSplashEvent];\n    });\n```\n1. 这个方法和`[self handleModuleEvent:kSetupSelector];`一样，除了传入的参数不同，响应的方法不同，其他都是一样。\n2. 这里还要强制要求这个方法的调用一定要在主线程中。\n\n### 这样就已经把自定义的`BHAppDelegate`的主要几个实现已经介绍了一下，下面来看看demo中的实现。在`TestAppDelegate`的`didFinishLaunchingWithOptions`的方法中。\n\n#### 这四行代码涉及到了同一个对象`BHContext`,从字面上判断应该是`上下文对象，应该是对象之间的调用会需要用它来记录一下，这里是我的猜测`\n```\n[BHContext shareInstance].application = application;\n[BHContext shareInstance].launchOptions = launchOptions;\n[BHContext shareInstance].moduleConfigName = @\"BeeHive.bundle/BeeHive\";//可选，默认为BeeHive.bundle/BeeHive.plist\n[BHContext shareInstance].serviceConfigName = @\"BeeHive.bundle/BHService\";\n```\n\n#### 在`BHContext.m`的代码中可以看出来，这个对象也是个单例，在这个单例的init方法中：\n\n```\n-(instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.modulesByName  = [[NSMutableDictionary alloc] initWithCapacity:1];\n        self.servicesByName  = [[NSMutableDictionary alloc] initWithCapacity:1];\n        self.moduleConfigName = @\"BeeHive.bundle/BeeHive\";\n        self.serviceConfigName = @\"BeeHive.bundle/BHService\";\n\n#if __IPHONE_OS_VERSION_MAX_ALLOWED > 80400\n        self.touchShortcutItem = [BHShortcutItem new];\n#endif\n\n        self.openURLItem = [BHOpenURLItem new];\n        self.notificationsItem = [BHNotificationsItem new];\n        self.userActivityItem = [BHUserActivityItem new];\n    }\n\n    return self;\n}\n\n```\n\n1. 定义了`modulesByName`、`servicesByName`为`NSMutableDictionary`的对象，只能容纳一个元素。\n2. 定义了`moduleConfigName`、`serviceConfigName`为String的对象。\n3. 在系统大于8.0.4的时候，支持3D touch的话，会额外设置一个对象，这个对象里面就两个对象，一个是`UIApplicationShortcutItem *shortcutItem;`, 一个是`typedef void (^shortcutItemCompletionHandler)(BOOL);`,都是在调用3D touch的时候会调用到。\n4. 涉及到了另一个对象`BHOpenURLItem`,这个对象含有三个变量`NSURL *openURL;`,`NSString *sourceApplication;`,`NSDictionary *options;`。\n5. 设计了通知的一个对象`BHNotificationsItem`,这个对象含有五个变量：`NSError *notificationsError;`,`NSData *deviceToken;`,`NSDictionary *userInfo;`,`typedef void (^notificationResultHandler)(UIBackgroundFetchResult);`,`UILocalNotification *localNotification;`。\n6. 还有一个涉及到用户信息的一个对象：`BHUserActivityItem`,含有四个变量：`NSString *userActivityType;`,`NSUserActivity *userActivity;`,`NSError *userActivityError;`, `typedef void (^restorationHandler)(NSArray *);`。\n7. 总体看来这个对象完成的功能很多，并且以后很多类似3D touch 这种针对某种系统的新功能都可以在这个类中来拓展，而且很方便使用。\n\n#### 在本类的`shareInstance`的方法中：\n\n```\ndispatch_once(&p, ^{\n        BHInstance = [[[self class] alloc] init];\n        if ([BHInstance isKindOfClass:[BHContext class]]) {\n            ((BHContext *) BHInstance).config = [BHConfig shareInstance];\n        }\n    });\n```\n\n1. 这里在设置`config`的变量之前判断`if ([BHInstance isKindOfClass:[BHContext class]]) {}`这个说实话，我没太明白这么做的原因是什么，上面都已经`BHInstance = [[[self class] alloc] init];`调用了，那这个判断还有什么意思吗？并且这个对象是继承的`NSObject`的对象。\n2. 这里的`BHConfig`对象，从代码上看也是一个单例，并且定义了一系列存储，判断是否存在，在.m的文件中定义了一个`NSMutableDictionary *config;`的对象，统一存储在这个里面，可以是对象类型，也可以是一些基础的数据类型。\n\n```\n[BHContext shareInstance].application = application;\n[BHContext shareInstance].launchOptions = launchOptions;\n[BHContext shareInstance].moduleConfigName = @\"BeeHive.bundle/BeeHive\";//可选，默认为BeeHive.bundle/BeeHive.plist\n[BHContext shareInstance].serviceConfigName = @\"BeeHive.bundle/BHService\";\n```\n1. 现在可以看出来，首先这4行代码就是简单的赋值的动作，有些类的值你可以不赋值，类似的有：`moduleConfigName`,`serviceConfigName`,因为在对象实例化的时候，就已经进行了赋值。\n\n#### 紧接着在下面的两行代码中涉及到了一个新的对象：\n\n```\n [BeeHive shareInstance].enableExpection = YES;\n [[BeeHive shareInstance] setContext:[BHContext shareInstance]];\n```\n```\n#pragma mark - Private\n\n-(void)setContext:(BHContext *)context\n{\n    _context = context;\n\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        [self loadStaticServices];\n        [self loadStaticModules];\n    });\n}\n```\n\n1. 首先在`BeeHive.m`的文件中，可以看出来，这个对象也是个单例。\n2. 紧接着在public的属性中，设置了全局了`BHContext`的对象，并且将它保存下来，并且在这里复写了`Setter`的方法,并且在`Setter`方法的时候,又调用了两个新的方法，并且这两个方法有且仅调用一次。\n\n```\n-(void)loadStaticServices\n{\n    [BHServiceManager sharedManager].enableException = self.enableExpection;\n\n    [[BHServiceManager sharedManager] setWholeContext:self.context];\n\n    [[BHServiceManager sharedManager] registerLocalServices];\n\n}\n```\n\n1. 在`loadStaticServices`的方法中，又创建了一个`BHServiceManager`的单例对象。\n2. 在`BHServiceManager`中设计了`enableException`的属性。\n3. 在`BHServiceManager`中设置了`BHContext`的对象，将`BHContext`对象也能够在`BHServiceManager`中能够持有这个对象。\n4. 最后调用到了`loadStaticServices`中的`registerLocalServices`的方法。方法如下：\n\n```\n- (void)registerLocalServices\n{\n    NSString *serviceConfigName = self.wholeContext.serviceConfigName;\n\n    NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName  ofType:@\"plist\"];\n    if (!plistPath) {\n        return;\n    }\n\n    NSArray *serviceList = [[NSArray alloc] initWithContentsOfFile:plistPath];\n\n    [self.lock lock];\n    [self.allServices addObjectsFromArray:serviceList];\n    [self.lock unlock];\n}\n```\n1. 通过传入的`context`找到`serviceConfigName`的变量，拼接成plist文件名，如果项目中确实存在的话，就打开这个文件的内容。\n2. 这里通过锁，来将plist文件中取到的变量NSArray，存储到`allServices`私有变量中去。\n\n#### 另一个方法：\n\n```\n- (void)loadStaticModules\n{\n    [[BHModuleManager sharedManager] setWholeContext:self.context];\n\n    [[BHModuleManager sharedManager] loadLocalModules];\n\n    [[BHModuleManager sharedManager] registedAllModules];\n}\n```\n1. 上面已经分析过了，这个`BHModuleManager`也是一个单例。首先将全局的`context`的变量设置上去，并且将`context中的moduleConfigName`的变量赋值给`modulesConfigFilename`。\n2. 将刚才的变量`modulesConfigFilename`拼接成`plist`文件，然后将取得的数据放入到数组中。\n3. 在`registedAllModules`的方法中，听过比较字典中的`moduleLevel`的value值，进行比较、排序，然后通过枚举，挨个实例化对象之后，在存入`BHModules`的可变数组中。\n\n```\nid<HomeServiceProtocol> homeVc = [[BeeHive shareInstance] createService:@protocol(HomeServiceProtocol)];\n```\n```\n- (id)createService:(Protocol *)service\n{\n    id implInstance = nil;\n\n    if (![self checkValidService:service] && self.enableException) {\n        @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@\"%@ protocol does not been registed\", NSStringFromProtocol(service)] userInfo:nil];\n    }\n\n    Class implClass = [self serviceImplClass:service];\n\n    implInstance = [[implClass alloc] init];\n\n    if (![implInstance respondsToSelector:@selector(singleton)]) {\n        return implInstance;\n    }\n\n    NSString *serviceStr = NSStringFromProtocol(service);\n\n    if ([implInstance singleton]) {\n        id protocol = [[BHContext shareInstance].servicesByName objectForKey:serviceStr];\n\n        if (protocol) {\n            return protocol;\n        } else {\n            [[BHContext shareInstance].servicesByName setObject:implInstance forKey:serviceStr];\n        }\n\n    } else {\n        [[BHContext shareInstance].servicesByName setObject:implInstance forKey:serviceStr];\n    }\n\n    return implInstance;\n}\n```\n\n\n1. 紧接着调用了`BeeHive`的public的方法：`- (id)createService:(Protocol *)proto;`传入一个protocol，返回一个id类型的对象。\n2. 其实这里`self checkValidService:service`值是判断之前`registerLocalServices`这个里面有没有遵循这个protocol的，假如没有，并且开启`self.enableException`的话，他就会抛出一个`NSException`。\n3. 否则就会遵循这个protocol的类，并且返回。\n4. 判断这个类有没有遵循`BHServiceProtocol`这个协议的`singleton`,并且实现，假如没有实现的话，就直接返回这个对象，不再往下执行了。\n5. 根据这个protocol在`[BHContext shareInstance].servicesByName`字典中查找有没有对应value值，如果有的话，就直接放回这个对象，如果没有的话，放回对象的同时，将这个protocol存储到这个`[BHContext shareInstance].servicesByName`字典中。\n6. 最后讲个homeVC设置为Appdelegate的RootWindow。\n","tags":["学习"],"categories":["日志"]},{"title":"学习阿里开源项目BeeHive(-)","url":"/2016/11/25/20161125/","content":"\n\n## 学习阿里开源 `BeeHive` ,每次学习别人写的框架，或者好东西都会让自己学到很多东西，废话不多说，直接扯代码。\n\n## 源码中的几个小问题：\n\n### 1. 在Example中，程序的入口文件`TestAppDelegate`,你就惊奇地发现，他不是继承了UIAppDelegate，也不是继承了UIAppDelegate的子类，而是自己写了一个`\"AppDelegate\"`\n\n<!-- more -->\n\n```\n@interface TestAppDelegate : BHAppDelegate <UIApplicationDelegate>\n```\n在 `BHAppDelegate.m`的文件中，我们发现这个类实现了很多appDelegae的很多代理方法\n\n```\n- (void)applicationWillResignActive:(UIApplication *)application\n{\n    [[BHModuleManager sharedManager] tiggerEvent:BHMWillResignActiveEvent];\n}\n\n- (void)applicationDidEnterBackground:(UIApplication *)application\n{\n    [[BHModuleManager sharedManager] tiggerEvent:BHMDidEnterBackgroundEvent];\n}\n\n- (void)applicationWillEnterForeground:(UIApplication *)application\n{\n    [[BHModuleManager sharedManager] tiggerEvent:BHMWillEnterForegroundEvent];\n}\n\n- (void)applicationDidBecomeActive:(UIApplication *)application\n{\n    [[BHModuleManager sharedManager] tiggerEvent:BHMDidBecomeActiveEvent];\n}\n\n- (void)applicationWillTerminate:(UIApplication *)application\n{\n    [[BHModuleManager sharedManager] tiggerEvent:BHMWillTerminateEvent];\n}\n```\n\n####当然这里先忽略，我们一点点说：\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n#ifdef DEBUG\n    self.timeProdiler = [BHTimeProfiler sharedTimeProfiler];\n#endif\n\n    [[BHModuleManager sharedManager] tiggerEvent:BHMSetupEvent];\n    [[BHModuleManager sharedManager] tiggerEvent:BHMInitEvent];\n\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[BHModuleManager sharedManager] tiggerEvent:BHMSplashEvent];\n    });\n\n#ifdef DEBUG\n    [self.timeProdiler printOutTimeProfileResult];\n    [self.timeProdiler saveTimeProfileDataIntoFile:@\"BeeHiveTimeProfiler\"];\n#endif\n\n    return YES;\n}\n```\n\n#### 在debug状态下，这个程序启动的方法创建了一个`timeProdiler`的实例，并且在return之前执行了`timeProdiler`的两个方法。\n\n##### 进入到 `BHTimeProfiler.m`的文件里面发现，这个类是一个单例。在这个类的init的方法中发现\n\n```\n- (instancetype)initTimeProfilerWithMainKey:(NSString *)mainKey\n{\n    self = [super init];\n    if (self) {\n        _mainIdentifier = [mainKey copy];\n        _lastTime = CACurrentMediaTime();\n        _recordStartTime = CACurrentMediaTime();\n    }\n    return self;\n}\n```\n1. 用一个字符串对私有的_mainIdentifier的字符串类型进行了赋值。\n2. 创建了一个时间的值赋给了_lastTime。\n3. 创建了一个时间的值赋给了_recordStartTime。`这里的时间类型并没有用NSDate去实例化，而是用了CACurrentMediaTime，这个时间在设备上所有进程都是全局的，并且在设备休眠的状态的时候，这个值会暂停`\n\n```\n- (void)recordEventTime:(NSString *)eventName\n{\n#ifdef DEBUG\n    NSString *keyName = [eventName copy];\n\n    [self.identifiers addObject:keyName];\n    [self.timeDataDic setObject:@(CACurrentMediaTime()) forKey:keyName];\n#endif\n}\n```\n1. 只有在debug的状态下调用这个public的方法才有意义。这个方法很简单，其实就是用mutableArray来存储`keyName`,并且将时间的值作为value存储在MutableDictionary中。这其实没什么好说的，但是这里有一点却引起了我的注意：\n\n```\n#if __has_feature(objc_generics)\n#   define TM__GENERICS(class, ...)         class<__VA_ARGS__>\n#else\n#   define TM__GENERICS(class, ...)         class\n#endif\n\n#define TMMutableArrayWith(valueType)                   TM__GENERICS(NSMutableArray, valueType)\n#define TMMutableDictionaryWith(keyType, valueType)     TM__GENERICS(NSMutableDictionary, keyType, valueType)\n```\n1. `__has_feature(objc_generics)`判断是否支持Obj-C泛型的特征。\n2. `...`表示，这个表示符里面可以接受0个，或者1个，或者多个参数。\n3. 除了第一个class的参数，其他的参数作为一个整体在`__VA_ARGS__`里面返回。\n\n```\n- (void)printOutTimeProfileResult\n{\n#ifdef DEBUG\n    for (NSString *eventName in self.identifiers) {\n        NSAssert([self.timeDataDic objectForKey:eventName] != nil &&\n                 [[self.timeDataDic objectForKey:eventName] isKindOfClass:[NSNumber class]], @\"Save Wrong Type TimeStamp\");\n\n        CFTimeInterval current = [[self.timeDataDic objectForKey:eventName] doubleValue];\n        printf(\"[%s] time stamp: %gms and execute for %gms -> \\n\", [eventName UTF8String], (current - self.recordStartTime) * 1000, (current - self.lastTime) * 1000);\n\n        self.lastTime = current;\n    }\n#endif\n}\n```\n1. 遍历keyName的数组，拿到每个keyName，先去字典中找对应的时间值，假如没有的话，就只会断点断住。\n2. 算出现在的时间值，与lastTime,recordTime的值得差值。\n3. 最后加lastTime的值重新设置为当前的值。\n\n```\n- (void)saveTimeProfileDataIntoFile:(NSString *)fileName\n{\n    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];\n    NSString *filePath =  [documentPath stringByAppendingPathComponent:[fileName stringByAppendingPathExtension:@\"txt\"]];\n\n    NSLog(@\"TMTimeProfiler::SaveFilePath is %@\", filePath);\n\n    BOOL res=[[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:nil];\n    if (!res) {\n        return;\n    }\n\n    NSFileHandle *handle = [NSFileHandle fileHandleForWritingAtPath:filePath];\n\n    for (NSString *eventName in self.identifiers)\n    {\n        CFTimeInterval current = [[self.timeDataDic objectForKey:eventName] doubleValue];\n\n        NSString *output = [NSString stringWithFormat:@\"%@ time stamp  %g and execute for  %g\\n\", eventName, current, (current - self.lastTime) * 1000];\n\n        [handle writeData:[output dataUsingEncoding:NSUTF8StringEncoding]];\n\n        self.lastTime = current;\n    }\n\n    [handle closeFile];\n\n\n}\n```\n1. 这个函数的作用就是传入一个文件的名字，然后将启动时间，record时间，记录下来，这个没什么好说的。\n\n```\n\n- (void)postTimeProfileResultNotification\n{\n    NSMutableArray *logArray  = [NSMutableArray array];\n\n    for (NSString *eventName in self.identifiers)\n    {\n        CFTimeInterval current = [[self.timeDataDic objectForKey:eventName] doubleValue];\n\n\n        [logArray addObject: @{@\"eventName\":eventName,@\"costTime\": @((current - self.lastTime) * 1000)}];\n\n        self.lastTime = current;\n    }\n\n\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTimeProfilerResultNotificationName object:nil userInfo:@{kNotificationUserInfoKey:logArray}];\n}\n```\n1.用NSNotificationCenter，将上次lastTime与现在时间的差值作为NSNotificationCenter中的userInfo的参数传输出去。这样只要监听这个NSNotificationCenter，你每次post就能接受到这个全局的通知。光这一个时间的统计功能，产品、技术上就能做好多文章。\n","tags":["学习"],"categories":["日志"]},{"title":"创建私有的Cocoapods","url":"/2016/10/28/20161028/","content":"\n\n### 创建私有Cocoapods,最近一直想将自己的App模块化，就想就App拆成每个模块组件，比如：登录模块、网络模块、消息模块、用户中心模块...但是基于这些想法，我首先要先搞定私有化Cocoapods的问题，这样团队中新人，想调用的时候，就能够快速，便捷的调用了，只需要  *pod xxx*\n\n\n> 1.先到自己的git账号，创建一个新的仓库 ，我们取名字 *GH*\n\n<!-- more -->\n\n> 2.开始终端，找到一个合适的位置：\n\n```\ncd ~/Desktop\n```\n\n> 3.初始化pod\n\n```\npod lib create GH\n```\n\n> 4.接着系统会问一下问题，你可以自己按照项目需求来回答，也可以参照我的\n\n```\n\nWhat language do you want to use?? [ Swift / ObjC ]\n > ObjC\n\nWould you like to include a demo application with your library? [ Yes / No ]\n > Yes\n\nWhich testing frameworks will you use? [ Specta / Kiwi / None ]\n > None\n\nWould you like to do view based testing? [ Yes / No ]\n > No\n\nWhat is your class prefix?\n > GG\n```\n\n> 5.修改一下pod的配置文件,pod的配置文件应该都是一样的后缀名，我这里叫 *Gh.podspec*\n\n### steps\n\n#### 1.这里我先讲description的描述内容注释掉\n\n```\n #s.description      = <<-DESC\n #TODO: Add long description of the pod here.\n #                        DESC\n```\n\n#### 2.修改homepage的路径，在第24行\n\n```\ns.homepage         = 'https://github.com/Ghstart/Gh'\n```\n\n#### 3.修改git的路径，在第28行\n```\ns.source           = { :git => 'https://github.com/Ghstart/Gh.gi    t', :tag => s.version.to_s }\n```\n\n> 5.保存好退出，再次进入到那个文件夹中，将文件内容提交到github上,我这里选择的是命令的方式，你也可以用github客户端\n\n```\ncd Gh\ngit init\ngit remote add origin https://github.com/Ghstart/GH.git // 这个路径在你刚才新建仓库的那个页面就能找到\ngit add .\ngit commit -m 'Gh first creats private own cocoapods'\ngit tag 0.1.0 // 这里的0.1.0在刚才的配置文件里有，对应起来就好了\ngit push -u origin master --tags\n```\n\n> 最后再去你刚才新建仓库的页面刷新一下，就会发现奇迹。。\n\n### 现在开始添加自己的类\n\n> 找到存放类的目录下，*/Users/*自己的mac名字*/Desktop/Gh/Gh/Classes*，在这个文件夹下面，你会发现一个名字叫做*ReplaceMe.m*，这个真是太贴心了，cocoapods都已经为我们想到了，在这里你先删除这个类，然后添加自己想要的类，然后在走一下下面的命令。\n\n> 我觉得这里，你既然已经修改了内容，或者想发布第一版本，那么修改配置文件的tags修改为*0.1.1*\n\n```\ngit add .\ngit commit -m\"add files\"\ngit tag 0.1.1\ngit push -u origin master --tags\n```\n\n> 现在到自己的github页面熟悉一下，就会发现自己创建的0.1.1的版本，以及新添加的文件。下面我们需要将我们自己创建的这个cocoapods提交给cocoapods审核，并且发布。\n\n```\npod lib lint Gh.podspec // 认证通过\npod trunk push    // 提交\n```\n\n```\n在最后 pod trunk push 时候如果报错 如：\n[!] Authentication token is invalid or unverified. Either verify it with the email that was sent or register a new session.\n\n这说明你之前的认证token已经失效了，重新注册一下就好了，输入以下命令：\n          pod trunk register gonghuan2020@gmail.com 'gonghuan'\n然后在重新  pod trunk push 就可以了。\n```\n\n```\n如果弹 [!] The spec did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it).\n\npod trunk push --allow-warnings\n\n如果弹 You can use the `--no-clean` option to inspect any issue.\npod lib lint GateWayObject.podspec --allow-warnings --no-clean\n```\n\n大功告成！！*这里cocoapods是一个很关键的问题，尤其你刚跟新pod或者xcode，那问题会很多，建议出现一些奇葩的问题，可以先卸载cocoapods，然后再装最新的稳定版本。*\n","tags":["学习","Cocoapods"],"categories":["日志"]},{"title":"React-Native 实战(-)","url":"/2016/10/21/20161021/","content":"\n## 实战(-) React-Native 重写红狮物流App的项目。下面的的几次博客我会以完成一个现有的项目，将它整体都用React重写。项目我已经上传到github[https://github.com/Ghstart/HongshiWuliuRN]\n\n\n### 首先找到`index.ios.js`文件，由于我们的app的架构就是主流的tab的这种，所以我这里用到了TabBarIOS的主件，代码如下：\n\n<!-- more -->\n\n```\nimport React, { Component } from 'react';\nimport {\n  AppRegistry,\n  StyleSheet,\n  Text,\n  View,\n  TabBarIOS\n} from 'react-native';\n\nimport Task     from './ios_views/task';\nimport Goods    from './ios_views/goods'\nimport Home     from './ios_views/home'\nimport Message  from './ios_views/message'\nimport Setting  from './ios_views/setting'\n\nclass HongshiWuLiuRN extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      selected: 'home'\n    }\n  }\n\n  _renderView(moduleName) {\n    switch (moduleName) {\n      case 'task':\n        return (\n          <Task/>\n        );\n        break;\n      case 'goods':\n        return (\n          <Goods/>\n        );\n        break;\n      case 'home':\n        return (\n          <Home/>\n        );\n        break;\n      case 'message':\n        return (\n          <Message/>\n        );\n        break;\n      case 'setting':\n        return (\n          <Setting/>\n        );\n        break;\n      default:\n        return ( <View></View> );\n        break;\n    }\n  }\n\n  render() {\n    return(\n      <TabBarIOS\n        tintColor = '#e23f42'\n      >\n        <TabBarIOS.Item\n          title = \"任务\"\n          selected = { this.state.selected === 'task' }\n          icon = {require('./images/mission@2x.png')}\n          selectedIcon={require('./images/mission-1@2x.png')}\n          onPress = {() => {\n            this.setState({\n              selected: 'task'\n            })\n          }}>\n\n          {this._renderView(this.state.selected)}\n\n\n        </TabBarIOS.Item>\n\n        <TabBarIOS.Item\n          title = \"货源\"\n          selected = { this.state.selected === 'goods' }\n          icon = {require('./images/goods@2x.png')}\n          selectedIcon={require('./images/goods-1@2x.png')}\n          onPress = {() => {\n            this.setState({\n              selected: 'goods'\n            })\n          }}>\n\n\n          {this._renderView(this.state.selected)}\n\n        </TabBarIOS.Item>\n\n        <TabBarIOS.Item\n          title = \"首页\"\n          selected = { this.state.selected === 'home' }\n          icon = {require('./images/home@2x.png')}\n          selectedIcon={require('./images/home-1@2x.png')}\n          onPress = {() => {\n            this.setState({\n              selected: 'home'\n            })\n        }}>\n\n          {this._renderView(this.state.selected)}\n\n        </TabBarIOS.Item>\n\n        <TabBarIOS.Item\n          title = \"消息\"\n          selected = { this.state.selected === 'message' }\n          icon = {require('./images/news@2x.png')}\n          selectedIcon={require('./images/news-1@2x.png')}\n          onPress = {() => {\n            this.setState({\n              selected: 'message'\n            })\n          }}>\n\n          {this._renderView(this.state.selected)}\n\n        </TabBarIOS.Item>\n\n        <TabBarIOS.Item\n          title = \"设置\"\n          selected = { this.state.selected === 'setting' }\n          icon = {require('./images/user@2x.png')}\n          selectedIcon={require('./images/user-1@2x.png')}\n          onPress = {() => {\n            this.setState({\n              selected: 'setting'\n            })\n          }}>\n\n          {this._renderView(this.state.selected)}\n\n        </TabBarIOS.Item>\n      </TabBarIOS>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n\n});\n\nAppRegistry.registerComponent('HongshiWuLiuRN', () => HongshiWuLiuRN);\n\n```\n\n### 首先你先不要运行，我先解释一下几点比较重要的问题：\n\n> 引入系统主件(**关于系统主件，你可以直接copy就好，这里我的意见就是官方建议那种写法，你就以这种写法为主**)、第三方主件、以及自己定义的主件(**这里一定要理清楚自己写的主件的路径**)。\n\n```\n// 引入系统主件\nimport React, { Component } from 'react';\nimport {\n  AppRegistry,\n  StyleSheet,\n  Text,\n  View,\n  TabBarIOS\n} from 'react-native';\n\n// 引入自定义的主件\nimport Task     from './ios_views/task';\nimport Goods    from './ios_views/goods'\nimport Home     from './ios_views/home'\nimport Message  from './ios_views/message'\nimport Setting  from './ios_views/setting'\n```\n\n> 如何定义主件,这里我目前写了两个方法，也是最常使用的两个方法：**其中constructor是这个主件的实例化方法，而真正让视图渲染到屏幕上的是render的方法，你可以在这里添加想渲染上去的视图内容。**\n\n```\nclass HongshiWuLiuRN extends Component {\n  constructor() {\n    super();\n  }\n\n\trender() {\n\n\t}\n}\n```\n\n> 如何定义主件视图的样式，**这里我们就需要用到stylesheet 所创创建的对象，在这里你就可以像写CSS样式一样，来定义视图了。**\n\n```\nconst styles = StyleSheet.create({\n\n});\n```\n\n> 如何定义应用的入口文件，**就想C函数一样，需要一个main函数作为入口文件，在RN中，我需要使用AppRegistry来注册这个主件，同时也作为入口文件。**\n\n```\nAppRegistry.registerComponent('HongshiWuLiuRN', () => HongshiWuLiuRN);\n```\n\n> 如何添加图片，你可以发现这段代码 **导入图片和自定义的主件是一样，需要写清楚图片所在的路径，这里为了调试，你可以先注释到**：\n\n```\n  icon = {require('./images/news@2x.png')}\n  selectedIcon={require('./images/news-1@2x.png')}\n```\n\n> 整个TabBar的功能，是由**TabBarIOS**来实现的，具体在这里，我们可以通过设置**tintColor = '#e23f42'**可以设置TabBar点选适合的颜色，而具体的图片的样式，文字，以及点击的方法就需要在**TabBarIOS.Item**来进行设置,重点说一下这个这段代码：这里定义一个私有方法，传入了一个字符串类型的参数，在拿到的参数的时候，我用**swich**的的方法，根据传入不同的参数，返回不同的**自定义的主件**\n\n```\n{this._renderView(this.state.selected)}\n\n _renderView(moduleName) {\n    switch (moduleName) {\n      case 'task':\n        return (\n          <Task/>\n        );\n        break;\n      case 'goods':\n        return (\n          <Goods/>\n        );\n        break;\n      case 'home':\n        return (\n          <Home/>\n        );\n        break;\n      case 'message':\n        return (\n          <Message/>\n        );\n        break;\n      case 'setting':\n        return (\n          <Setting/>\n        );\n        break;\n      default:\n        return ( <View></View> );\n        break;\n    }\n  }\n\n```\n\n> 这里根据自定义主件的路径，可以猜到，我在同级目录下创建一个**ios_views**的文件夹，在**ios_views**的文件下我有创建了四个js文件： **goods.js**、**home.js**、**message.js**、**setting.js**、**task.js**,代码如下,这个五个文件，你目前可以一样的代码，只需要修改相应的名字，就可以了：\n\n\n```\nimport React, { Component } from 'react';\nimport {\n  StyleSheet,\n  View,\n  NavigatorIOS\n} from 'react-native';\n\n\nclass home_views extends Component {\n  render() {\n    return (\n      <View>\n\n      </View>\n    );\n  }\n}\n\nclass home extends Component {\n  render() {\n    return(\n      <NavigatorIOS\n          initialRoute={{\n          component: home_views,\n          title: \"红狮物流\",\n          titleTextColor: '#fff',\n          barTintColor: '#e23f42',\n        }}\n      />\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n\n});\n\nmodule.exports = home\n\n```\n\n> 这里用到了**NavigatorIOS**的主件，这个就是强大的路由主件。你可以看到，在里面必须要定义初始路由对应于哪个主件，以及nav的背景色，title，字体颜色等等。\n","tags":["学习","React Native"],"categories":["日志"]},{"title":"学习React Native中","url":"/2016/08/24/20160824/","content":"\n\n\n## 其实从去年我就一直看学习并看React Native,开始学习只是为了兴趣，现在项目中用到了有些更新的功能，我就是用React native 来做的。其实还是蛮好的，但是我发现更新实在是太快了，现在官网的稳定版本是[0.31版本](https://facebook.github.io/react-native/)\n\n<!-- more -->\n\n### 使用\n> 打开terminal, cd到某个路径下，执行命令 `react-native init helloworld`[^这里的helloword就是你创建的项目名字]\n> 如果出现这样的代码就代码创建成功。\n\n```\nTo run your app on iOS:\n   cd /Users/gonghuan/Desktop/helloworld\n   react-native run-ios\n   - or -\n   Open /Users/gonghuan/Desktop/helloworld/ios/helloworld.xcodeproj in Xcode\n   Hit the Run button\nTo run your app on Android:\n   Have an Android emulator running (quickest way to get started), or a device connected\n   cd /Users/gonghuan/Desktop/helloworld\n   react-native run-android\n```\n> 此时你可以通过类似`react-native run-ios`可以直接调起iOS模拟器，此时你可以看到你的终端不断在解析，然后就可以成功运行了。\n> 说到这里，应该你已经可以运行你的app了，至于之前要安装 brew node等等，我这里就不再多说了，你可以去官网上走一遍，很简单。\n---\n\n### 工具\n> 我这里我选用的是atom，这里说一个我遇到的小问题，也许你也会遇到，在我们使用atom的时候，需要安装一些插件来帮助我们能够更加高效的写代码，就比如facebook开发的[Nuclide](https://nuclide.io/docs/editor/setup/#quick-install)\n\n 1. 按照官方install的说明，我们可以知道有两种安装的方式，一种就是通过直接在终端输入`apm install nuclide`,但是说实话，我就成功过一次，而且还是要挂vpn，之后就一直没有成功过了，这我就呵呵了。\n 2. 官方建议第二种方式：直接在atom->Setting Views->Manage Packages,搜索Nuclide，直接安装。\n 3. 第三种：通过这种方式你可以安装Themes、packages\n\n ```\n cd ~/.atom/packages\ngit clone [packgae-url] # git clone https://github.com/facebook/nuclide\ncd [package] #nuclide\nnpm install\n ```\n ---\n\n###好了，到目前为止，你已经可以，我们已经可以开始运行，并且可以安装自己喜欢的插件，已经修改自己喜欢的主题了。下面我们开始coding,我们先通过atom打开我们之前创建的helloworld的项目，并且找到`index.ios.js`,删除里面所有的代码，不要着急，我们会慢慢的添加进去所有的代码。\n\n```\nclass firstRN extends Component {\n  render() {\n    return(\n      <Text>\n        Hello world\n      </Text>\n    );\n  }\n}\n\nAppRegistry.registerComponent('helloworld', ()=>firstRN);\n\n```\n1. 这里我们先创建一个firstRN的类，继承自Component对象，这里你先不要管，我们后面都会解释的。\n2. 第二步，我们用AppRegistry这个注册一个对象，这个对象的名字是我们应用的名字‘helloworld’，第二个参数指向的是我们刚才创建的firstRN类。\n3. 我们点击模拟器，发现报错，`Unhandled JS Exception:xxxx: Can't find variable: Component`,在文件头部添加\n\n```\nimport React, { Component } from 'react';\nimport { AppRegistry, Text } from 'react-native';\n```\n> The AppRegistry just tells React Native which component is the root one for the whole application. You won't be thinking about AppRegistry a lot - there will probably just be one call to AppRegistry.registerComponent in your whole app. It's included in these examples so you can paste the whole thing into your index.ios.js or index.android.js file and get it running.----这里是官方给的AppRegistry，其实AppRegistry只做了一件事情，就是告诉这个应用，谁是整个应用的根控制器，这样你可以通过修改index.ios.js来修改iOS的根控制器是啥？安卓也是一样，修改的index.android.js\n> 再次刷新模拟器，就会发现左上角会出现我们写的Hello world的文字。\n> 这里我们觉得样式好丑，那该怎么办，没事，RN也是可以做到修改的。\n\n```\nimport React, { Component } from 'react';\nimport { AppRegistry, Text , StyleSheet } from 'react-native';\n\nclass firstRN extends Component {\n  render() {\n    return(\n      <Text style = {styles.helloWorldStyle}>\n        Hello world\n      </Text>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  helloWorldStyle: {\n    color:'red',\n    fontSize:30,\n    fontWeight:'bold'\n  }\n})\n\n\nAppRegistry.registerComponent('helloworld', ()=>firstRN);\n```\n\n> 这里我们需要在import中导读 StyleSheet,因为我们需要在后面的设置样式的时候，用到这个类。\n> 直接在text后面添加style的样式熟悉\n> 直接在后面创建styles的属性，通过StyleSheet来创建。\n> 再次刷新模拟器，你就可以看到效果了。\n\n\n---\n\n ### 先说这么多，后期我们还会说到很多在app开发中遇到的各种问题，导航栏，网络请求，传值等等。\n","tags":["学习","React Native"],"categories":["日志"]},{"title":"因为我不想打卡，不要问我为什么？？","url":"/2016/08/15/20160815/","content":"\n### 最近一直没啥时间来整理一些学习资料以及学习的内容，感觉这样不是很好。又由于公司要打卡了，所以我就写写我是怎么不打卡的吧！O(∩_∩)O~~~\n\n<!-- more -->\n\n1. mac电脑先安装抓包神器：Charles (网上有很多这个使用教程，我就不多说了，毕竟是工具，没啥难度)\n2. 点击Help->Local IP Address,将本机的IP打印出来，然后在手机里面设置代理为相应的IP，端口为：8888\n3. 此时你就可以开始看到数据的返回、和请求了。\n\n\n\t![1.pi](media/14712518179704/1.pic.jpg)\n\n1. 然后你就可以看到你想要的代码请求了，其实这个Android和iOS,还有点不同，Android返回的代码不是text/json,而是text/html,我在我代码中加入了代码格式的转换。\n\n``` Object-c\n\n\t __block NSDictionary *par = @{@\"employeeNo\":pp.employeeNo,@\"coord\":@\"30.249812,120.211494\",@\"img_ids\":@\"\",@\"identifier\": pp.identifier,@\"type\": @\"0\"}};\n\n     AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];\n            [manager POST:@\"http://xxxx/HSSCM/appmail/employeeRecordManage/sign.do\" parameters:par success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {\n                NSLog(@\"%@\",operation);\n                NSLog(@\"%@\",responseObject);\n            } failure:^(AFHTTPRequestOperation * _Nullable operation, NSError * _Nonnull error) {\n                NSLog(@\"%@\",operation);\n                NSLog(@\"%@\",error);\n            }];\n\n```\n1.  你或许已经发现了参数的规律了，这里的employeeNO就是我们之前抓包的用户唯一标示符（安卓这边还耍了个心眼，取了一个很怪的名字，视图误导我们）\n2. coord就是经纬度，用逗号链接起来的一个字符串\n3. img_ids我不知道是个什么东西，反正可有可无\n4. identifior是手机的udid（iOS中这样称呼吧）,这里我猜想他的employeeNO与手机identifior是一一对应的，<strong>所以这也就解释了为什么我在换手机的时候，会报错</strong>\n5. type:0--就是签出，1--就是签到\n\n\n\n-------\n##现在问题都已经分析完了，我们该用什么对策来自动帮我们打卡呢。\n####由于必须需要内网才能打卡，我们不能外网或者4G的条件下打卡，折让我们很蛋疼，这里我想到几个解决方案：\n1. 安卓的手机，可以借用一款叫做<按键精灵>的app,但是有个条件就是你必须拿到root权限，这样就可以录制你按键的动作，你可以指定时间执行。\n2. 公司的电脑、或者测试机，安装一个teamViewer，这样你就可以在家里远程操控他。\n3. 公司的测试机充当服务器的功能、一直在跑，这样我需要关心的只有一件事：手机有电。\n\n```\n\n\t- (NSArray *)setUPDatas:(TypeStatus)typeStatus {\n     NSMutableArray *datas = [NSMutableArray new];\n\n     NSArray *employeeNos = @[@\"31330034\", @\"31330040\", @\"31330035\"];\n     NSArray *identifiers = @[@\"05B7A575-2D2A-4006-890A-D0994EFF3DAC\", @\"a000004f73cb94\", @\"1B65EB63-487B-49BF-B751-F2D544175BE7\"];\n     for (int i = 0 ; i < employeeNos.count ; i++) {\n         People *people = [[People alloc] init];\n         people.employeeNo = employeeNos[i];\n         people.coord = @\"30.249812,120.211494\";\n         people.img_ids = @\"\";\n         people.identifier = identifiers[i];\n         if (typeStatus == LogIn) {\n             people.type = @\"1\";\n         } else {\n             people.type = @\"0\";\n         }\n\n         people.random_signInMin = [self getRandomNumber:5 to:25];\n         people.random_signInSec = [self getRandomNumber:1 to:59];\n         people.random_signOutMin = [self getRandomNumber:5 to:25];\n         people.random_signOutSec = [self getRandomNumber:1 to:59];\n\n         [datas addObject:people];\n     }\n\n     return [datas copy];\n \t}\n\n\n\n \t- (int)getRandomNumber:(int)from to:(int)to {\n     return (int)(from + (arc4random() % (to - from + 1)));\n \t}\n\n#### 我在这里实例化了用户的对象，在这个对象生成的同事，就已经确定这个对象签到的时间，和签出的时间（在某个数范围内随机生成）。\n\n\nif (hour == signOutHour) { // 签出--0\n\n             if (self.needSignOut.count == 0) return;\n\n             for (int i = 0 ; i < self.needSignOut.count; i++) {\n                 People *pp = self.needSignOut[i];\n\n                 if (pp.random_signOutMin < min || (pp.random_signOutMin == min && pp.random_signOutSec <= sec)) {\n                     par = @{\n                             @\"employeeNo\":pp.employeeNo,\n                             @\"coord\": @\"30.249812,120.211494\",\n                             @\"img_ids\":@\"\",\n                             @\"identifier\": pp.identifier,\n                             @\"type\": pp.type};\n\n                     [self SignOrSignOut:par week:week time:[NSString stringWithFormat:@\"%ld:%ld:%ld\",(long)hour,(long)min,(long)sec]];\n                 }\n             }\n            }\n\n```\n\n\n-------\n\n\n\n```\n- (void)needToRemove:(TypeStatus)status identifior:(NSString *)identifior realtime:(NSString *)realtime{\n if (status == LogIn) {\n     for (int i = 0 ; i < self.needSignIn.count; i++) {\n         NSMutableDictionary *tempDic = [NSMutableDictionary new];\n         People *pp = self.needSignIn[i];\n         if ([pp.identifier isEqualToString:identifior] && ![identifior isEqualToString:@\"\"]) {\n             NSLog(@\"移除people:%@---loginMin:%ld----loginSec:%ld\",pp.identifier,(long)pp.random_signInMin, (long)pp.random_signInSec);\n\n             [self.needSignIn removeObject:pp];\n\n\n             if (pp.identifier != nil) [tempDic setObject:pp.identifier forKey:@\"iden\"];\n             [tempDic setObject:[NSString stringWithFormat:@\"签到时间:%ld:%ld:%ld\", signInHour, pp.random_signInMin, pp.random_signInSec] forKey:@\"time\"];\n             if (realtime != nil) [tempDic setObject:realtime forKey:@\"realtime\"];\n\n             if (tempDic != nil) [self.tableViewDatas addObject:tempDic];\n\n         }\n     }\n```\n\n1. 这里你会发现我在遍历的同事，又对mutableArray对象进行的操作，开始一直crash，会报这个错：<strong>collection __nsarraym was mutated while being enumerated</strong>\n2. 意思就是说，你在遍历这个对象的同事，又对这个对象进行了添加、删除的操作。这里给你三种解决的思路。\n\n> 1\n\n```\nfor (int i = 0 ; i < self.needSignIn.count; i++) {}\n```\n替换\n\n```\nfor (People *pp in self.needSignIn) {}\n```\n\n> 2\n\n```\nNSSortDescriptor *sd1 = [NSSortDescriptor sortDescriptorWithKey:nil ascending:NO];//yes升序排列，no,降序排列\nNSArray *myary = [ary sortedArrayUsingDescriptors:[NSArray arrayWithObjects:sd1, nil]];//注意这里的ary进行排序后会生产一个新的数组指针，myary，不能在用ary,ary还是保持不变的。\nfor (People *pp in myary) {}\n```\n\n> 3\n\n```\n生成一个零时的数组，用来遍历，之前的数据用来操作。\n```\n\n<strong>其实这里有个问题，想了好久才想明白：为什么正序排列不行，倒序就可以呢？？,为什么for不行，但是forin的可以呢？</strong>\n\n####其实for的语句可以等同于：假如说我有10个元素，在第一个的时候，我就remove了，那是不是到了第九个的时候就越界了呢？？\n\n```\nint count =  arr.count; for (i=0;i<count;i++) {}\n```\n\n<strong>倒序同样的道理：</strong>\n\n```\nint count =  arr.count;\nfor (i = count - 1;i>=0 ;i—) {}\n```\n\n#### 当我移除当前这个的时候，其实比不影响我其他的元素布局。\n\n<strong>但是这两种情况，假如你使用for的语句格式，就不会有问题了</strong>\n\n```\nfor (int i = 0 ; i < self.needSignIn.count; i++) {}\n```\n\n###总结一句话：\n1. 当我们正序遍历时,如果删除了一个,那么没有遍历到的元素位置都会往前移动一位,这样系统就无法确定接下来遍历是从删除位置开始呢,还是从删除位置下一位开始呢\n2. 对于逆序遍历就不会,因为我们逆序遍历时,遇到匹配的元素删除后,位置改变的是遍历过得元素,而没有遍历到的元素位置却没有改变,所以遍历能够正常进行.\n","tags":["学习","Obeject-c"],"categories":["日志"]},{"title":"搭建SDK中所遇到的坑","url":"/2016/05/10/20160510/","content":"\n## 其实开始之前，我找到一篇很不错的文章，想翻译的，但是google了一下，发现已经有好多人翻译过这篇文章了，这里我就不再多说什么了，把原文的链接贴出来。<https://www.raywenderlich.com/65964/create-a-framework-for-ios>,这里我就说一下，我在搭建sdk的时候，遇到的坑吧。\n\n<!-- more -->\n\n\n1. 其实你要是能够走完上面的流程，你基本上已经完成了80%了，剩下的就是发现问题，再去打包。\n\n### 第一个错误\n\n`*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Could not find a storyboard named 'XXXXname' in bundle NSBundle `\n\n* 这个错误可能直接就会导致app起不来，一启动就会crash，这里需要将所有你用到xib，storyboard的文件都统一作出修改。`其实这个问题在遇到用xib/SB创建的cell的时候、在xib/SB中添加图片的时候需要将[UIImage imageNamed:@\"\"] =======> 修改为 [UIImage imageNamed:@\"xxxx.bundle/xxxxName\"]`\n\n\n```\nUIStoryboard *main = [UIStoryboard storyboardWithName:@\"xxxxName\" bundle:[NSBundle mainBundle]];\n\n修改为===============================\n\nUIStoryboard *main = [UIStoryboard storyboardWithName:@\"xxxx.bundle/xxxxName\" bundle:[NSBundle mainBundle]];\n\n```\n\n### 第二个错误\n\n`可能会在Iphone4的时候，直接无法build,直接报这个错： dyld: Symbol not found: ___NSDictionary0__`\n\n\n```\n需要将项目中的build Phases 中的core foundation的stastu的状态 从Required修改为Optional\n```\n\n\n`后续如果还有其他的bug，我再贴出来吧！`\n","tags":["Obeject-c","项目"],"categories":["日志"]},{"title":"关于学习UITableViewCell的高度计算的框架-UITableView-FDTemplateLayoutCell。","url":"/2016/05/05/20160505/","content":"\n\n## 学习UITableView的高度计算的框架\n<!-- more -->\n## 这里学习的是UITableView-FDTemplateLayoutCell<https://github.com/forkingdog/UITableView-FDTemplateLayoutCell>你也可以自己去下载并且学习。\n\n\n\n* 他的文件很简单，直接在UITableView的高度放回中去调用方法：直接调用UITableView 中(FDTemplateLayoutCell)的category的方法,其实他的category里面一共写了三种可以计算高度的方法，这是其中的一种：\n\n```\n- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration {\n\t\t//1.\n\t    if (!identifier) {\n        return 0;\n    }\n\n    //2.\n    UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];\n\n    // Manually calls to ensure consistent behavior with actual cells. (that are displayed on screen)\n    [templateLayoutCell prepareForReuse];\n\n    //8.\n    // Customize and provide content for our template cell.\n    if (configuration) {\n        configuration(templateLayoutCell);\n    }\n\n    return [self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];\n\n\n//2.\n- (__kindof UITableViewCell *)fd_templateCellForReuseIdentifier:(NSString *)identifier {\n\t//....\n\t\t//4.\n\t    if (!templateCellsByIdentifiers) {\n        templateCellsByIdentifiers = @{}.mutableCopy;\n        objc_setAssociatedObject(self, _cmd, templateCellsByIdentifiers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    }\n\n    \t//5.\n        if (!templateCell) {\n        templateCell = [self dequeueReusableCellWithIdentifier:identifier];\n        NSAssert(templateCell != nil, @\"Cell must be registered to table view for identifier - %@\", identifier);\n        //6.\n        templateCell.fd_isTemplateLayoutCell = YES;\n        templateCell.contentView.translatesAutoresizingMaskIntoConstraints = NO;\n        templateCellsByIdentifiers[identifier] = templateCell;\n        [self fd_debugLog:[NSString stringWithFormat:@\"layout cell created - %@\", identifier]];\n    }\n\n\t//....\n)\n\n//3.\n/**\n * Returns the value associated with a given object for a given key.\n *\n * @param object The source object for the association.\n * @param key The key for the association.\n *\n * @return The value associated with the key \\e key for \\e object.\n *\n * @see objc_setAssociatedObject\n */\nOBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)\n\n//6.\n/// Indicate this is a template layout cell for calculation only.\n/// You may need this when there are non-UI side effects when configure a cell.\n/// Like:\n///   - (void)configureCell:(FooCell *)cell atIndexPath:(NSIndexPath *)indexPath {\n///       cell.entity = [self entityAtIndexPath:indexPath];\n///       if (!cell.fd_isTemplateLayoutCell) {\n///           [self notifySomething]; // non-UI side effects\n///       }\n///   }\n///\n@property (nonatomic, assign) BOOL fd_isTemplateLayoutCell;\n\n//7.\n- (BOOL)fd_isTemplateLayoutCell {\n    return [objc_getAssociatedObject(self, _cmd) boolValue];\n}\n\n- (void)setFd_isTemplateLayoutCell:(BOOL)isTemplateLayoutCell {\n    objc_setAssociatedObject(self, @selector(fd_isTemplateLayoutCell), @(isTemplateLayoutCell), OBJC_ASSOCIATION_RETAIN);\n}\n\n\n```\n1. 这里假如不传入identifior的值得话，他就直接直接返回0，表示不计算高度了。\n2. 这里根据传入的identifior的值，来找到相应的UITableViewCell\n3. 这里是runtime源码中所申明的，可以看到这个是根据给的Object以及给的Key来返回一个对象\n4. 第一次申明的话，它就会创建一个空的可变字典对象,字典的对象是{<NSString *, UITableViewCell *>},key是String, value是UITableViewCell。\n5. 当第一次没有UITableViewCell的对象的时候，就开始在重用池中，找UITableViewCell的对象,并将UITableViewCell对象塞进之前的字典对象。\n6. 这边在塞入UITableViewCell对象的时候，通过category(7.)来这是这个UITableViewCell的属性，这个作者的用意就是表明这个只是用计算高度的。\n8. 如果需要在cell中设置cell元素中的值，就在这里设置。最后拿到UITableViewCell的对象。\n\n## 最后将拿到的UITableViewCell的对象丢到这个函数中计算\n```\n- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell {\n\t  // Auto layout engine does its math\n\t  // 6.\n        fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;\n        [cell.contentView removeConstraint:widthFenceConstraint];\n}\n\n```\n1. 这里首先获得这个UITableViewCell的宽度，赋值给contentViewWidth的对象。\n2. 下面判断这个cell中有没有设置accessoryView的这个view，如果设置了accessoryView的话，这个cell的宽度按会稍微小一点（16 + CGRectGetWidth(cell.accessoryView.frame)）\n3. 否则会根据accessoryView的类型不同，需要减去不同的宽度。\n4. fd_enforceFrameLayout是用autolayout的、还是使用的frame的布局。\n5. 通过NSLayoutConstraint，将cell.contentView的宽度设置为contentViewWidth。\n6. `直接返回高度，并将约束移除掉。这里我不是很明白，为什么要这样做。`\n7. 如果这里的UITableview的格式如果不是UITableViewCellSeparatorStyleNone，高度可能会有点偏差，加上这个偏差（1.0 / [UIScreen mainScreen].scale）\n\n##Demo中第二种方法，其他参数都是一样的，就是多了一个cacheByIndexPath,就是根据IndexPath的对象来存储刚才计算的高度。\n```\n/// This method does what \"-fd_heightForCellWithIdentifier:configuration\" does, and\n/// calculated height will be cached by its index path, returns a cached height\n/// when needed. Therefore lots of extra height calculations could be saved.\n///\n/// No need to worry about invalidating cached heights when data source changes, it\n/// will be done automatically when you call \"-reloadData\" or any method that triggers\n/// UITableView's reloading.\n///\n/// @param indexPath where this cell's height cache belongs.\n///\n- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration {\n\n\t    // Hit cache\n\t    //1.\n    if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) {\n        [self fd_debugLog:[NSString stringWithFormat:@\"hit cache by index path[%@:%@] - %@\", @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];\n        return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];\n    }\n    //9.\n     CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];\n    [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];\n    [self fd_debugLog:[NSString stringWithFormat: @\"cached by index path[%@:%@] - %@\", @(indexPath.section), @(indexPath.row), @(height)]];\n\n    return height;\n}\n\n//2.\n- (BOOL)existsHeightAtIndexPath:(NSIndexPath *)indexPath {\n\t//6.\n\t NSNumber *number = self.heightsBySectionForCurrentOrientation[indexPath.section][indexPath.row];\n    return ![number isEqualToNumber:@-1];\n}\n\n//3.\n- (void)buildCachesAtIndexPathsIfNeeded:(NSArray *)indexPaths {\n\t  [indexPaths enumerateObjectsUsingBlock:^(NSIndexPath *indexPath, NSUInteger idx, BOOL *stop) {\n\t  //4.\n        [self buildSectionsIfNeeded:indexPath.section];\n      //5.\n        [self buildRowsIfNeeded:indexPath.row inExistSection:indexPath.section];\n    }];\n}\n\n- (void)buildSectionsIfNeeded:(NSInteger)targetSection {\n    [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) {\n        for (NSInteger section = 0; section <= targetSection; ++section) {\n            if (section >= heightsBySection.count) {\n                heightsBySection[section] = [NSMutableArray array];\n            }\n        }\n    }];\n}\n\n- (void)buildRowsIfNeeded:(NSInteger)targetRow inExistSection:(NSInteger)section {\n    [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) {\n        NSMutableArray<NSNumber *> *heightsByRow = heightsBySection[section];\n        for (NSInteger row = 0; row <= targetRow; ++row) {\n            if (row >= heightsByRow.count) {\n                heightsByRow[row] = @-1;\n            }\n        }\n    }];\n}\n\n//6.\ntypedef NSMutableArray<NSMutableArray<NSNumber *> *> FDIndexPathHeightsBySection;\n\n//7.\n- (CGFloat)heightForIndexPath:(NSIndexPath *)indexPath {\n    [self buildCachesAtIndexPathsIfNeeded:@[indexPath]];\n    NSNumber *number = self.heightsBySectionForCurrentOrientation[indexPath.section][indexPath.row];\n}\n\n//8.\n- (FDIndexPathHeightsBySection *)heightsBySectionForCurrentOrientation {\n    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation) ? self.heightsBySectionForPortrait: self.heightsBySectionForLandscape;\n}\n\n```\n1. 和上面方法一样的我就不说了，这里的高度缓存部分还是蛮有意思的，这里新建了一个fd_indexPathHeightCache的对象，这个对象就是用来管理缓存的部分，对象继承的是NSObject\n2. 通过传入的indexPath来返回这个对象是否已经缓存进去了。\n3. 在将indexPath的对象打包成NSArray的对象，对到下一个函数中\n4. 将indexPath.section,如果数组中不含有这个section的话，那就新建一个，通过6.可以知道，这个是个二位数组，最外层数组的index的数目就是section\n5. 下一个方法就是根据section，找到里面一层的数组，这个数组放的就是对应的rows的对象，如果没有就会默认塞入一个-1的值。\n6. 再根据同样的方法，到二维数组中查找对象，如果不是我们之前塞入的-1,那就是true，否则就是false。\n7. `这里我没看懂，已经知道在缓存中存在了，为什么还要再掉一遍[self buildCachesAtIndexPathsIfNeeded:@[indexPath]];`\n8. 这里可以知道，作者根据横竖屏设置了两个不同的数据，就是为了分别存储、提取。\n9. 如果之前没有缓存的话，它会先去调用一遍之前计算高度的方法，然后将计算出来的高度，丢到之前的二维数组中去。\n\n###第三种的计算方式，就是根据每个model设置不同key值来存储高度。\n```\n/// This method caches height by your model entity's identifier.\n/// If your model's changed, call \"-invalidateHeightForKey:(id <NSCopying>)key\" to\n/// invalidate cache and re-calculate, it's much cheaper and effective than \"cacheByIndexPath\".\n///\n/// @param key model entity's identifier whose data configures a cell.\n///\n- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id<NSCopying>)key configuration:(void (^)(id cell))configuration {\n\t//1.\n\t   // Hit cache\n    if ([self.fd_keyedHeightCache existsHeightForKey:key]) {\n        CGFloat cachedHeight = [self.fd_keyedHeightCache heightForKey:key];\n        [self fd_debugLog:[NSString stringWithFormat:@\"hit cache by key[%@] - %@\", key, @(cachedHeight)]];\n        return cachedHeight;\n    }\n\n    //2.\n    @property (nonatomic, strong) NSMutableDictionary<id<NSCopying>, NSNumber *> *mutableHeightsByKeyForPortrait;\n}\n\n```\n\n1. 作者也说了，这个效率会比之前按照indexPath的计算效率要高。\n2. 通过这个，我们大概就知道，作者所谓的效率高，应该就是这个意思，这里不是什么二维数组，而是一个NSMutableDictionary对象。其他基本上类似。\n\n`最后说一下自己的一个疑问：第二种方法中，作者为什么不将key和value经过简单的运算，作为key，来用NSDictionary来存储数据呢？作者的解释是：里面要配合 section row 的insert remove的话，会比较麻烦。所以作者最后还是选择的二维数组。`\n","tags":["学习","Obeject-c"],"categories":["日志"]},{"title":"关于图片圆角的功能学习。","url":"/2016/04/19/20160418/","content":"\n### 图片的性能问题，基本上面试的时候，都会被问到，现在在自己的app中，我也是为了解决的性能的问题，所以了解了一些关于图片性能的库，看一下源码, 现在应该有很多这种库了。我看的是这个：<https://github.com/CoderJackyHuang/HYBImageCliped>\n\n<!-- more -->\n\n* 这个库是通过Category来分别实现这些功能，首先看看UIView的Category,是怎么实现的UIView的圆角。\n\n```\n/**\n *\t使用指定的图片来填充，但是生成的是圆形图片，背景颜色为白色。\n *\n *\t@param image\t\t\t图片名称或者图片对象，甚至支持NSData\n *\t@param targetSize\t生成指定大小的图片\n *\t@param isEqualScale\t是否等比例缩放图片\n *  @param backgroundColor 默认取最顶层父视图的背景色，若为透明，则取本身背景色，若也为透明，则取白色\n *  @parma callback   只有当图片真正被裁剪成功后，才会回调，返回裁剪后的图片\n *\n *\t@return 裁剪前的图片\n */\n\n- (UIImage *)hyb_setCircleImage:(id)image\n                           size:(CGSize)targetSize\n                   isEqualScale:(BOOL)isEqualScale\n                 backgrounColor:(UIColor *)backgroundColor\n                       onCliped:(HYBClipedCallback)callback;\n```\n* 这只是其中一种Public的方法，我是按照Demo来看的。但是无论哪一种Public的方法，最终调用的都是统一的一个Private 的方法。\n\n```\n- (UIImage *)hyb_private_setImage:(id)image\n                             size:(CGSize)targetSize\n                     cornerRadius:(CGFloat)cornerRadius\n                      rectCorener:(UIRectCorner)rectCorner\n                  backgroundColor:(UIColor *)bgColor\n                     isEqualScale:(BOOL)isEqualScale\n                         isCircle:(BOOL)isCircle\n                         onCliped:(HYBClipedCallback)callback\n```\n\n\n * 里面有个这个方法：可以看出来，假如你不设置bgColor这个属性的话，他会遍历循环，一直会找到最顶层的父类，去除父类的颜色。`所以我觉得你要是没事话，还是自己设置一下颜色吧！这边假如层级很复杂，并且元素很多的话，这个性能可能会让你哭吧...`\n\n ```\n   if (bgColor == nil || CGColorEqualToColor(bgColor.CGColor, [UIColor clearColor].CGColor)) {\n    UIView *superview = self.superview;\n    while (superview.backgroundColor == nil || CGColorEqualToColor(superview.backgroundColor.CGColor, [UIColor clearColor].CGColor)) {\n      if (!superview) {\n        break;\n      }\n\n      superview = [superview superview];\n    }\n\n    bgColor = superview.backgroundColor;\n  }\n ```\n\n * 好吧，下面这段代码又要提到面试宝典中啥经典话题了，`如何在category中给现有的类添加属性呢？`\n<http://nshipster.com/associated-objects/>Matt 大神曾经写过，你可以看一下。\n\n\n```\n__block UIImage *clipedImage = nil;\n\t//1.\n  dispatch_async(dispatch_get_global_queue(0, 0), ^{\n  //2.\n    willBeClipedImage.hyb_pathColor = self.hyb_pathColor;\n    willBeClipedImage.hyb_pathWidth = self.hyb_pathWidth;\n    willBeClipedImage.hyb_borderColor = self.hyb_borderColor;\n    willBeClipedImage.hyb_borderWidth = self.hyb_borderWidth;\n  });\n\n```\n\n```\n这里涉及到的pathColor,pathWidth,borderColor,borderWidth,都是通过在runtime的特性，在已有的类中添加属性的方式来存储和使用的。\n- (UIColor *)hyb_pathColor {\n  UIColor *color = objc_getAssociatedObject(self, s_hyb_image_pathColorKey);\n\n  if (color) {\n    return color;\n  }\n\n  return [UIColor whiteColor];\n}\n\n//...下面都是换汤不换药的。\n\n```\n\n\n\n`下面涉及到真正的画图部分了`\n\n\n\n\n1. 这里另起一个线程来绘制圆角。这里我有个问题：`每个图片都创建一个线程，这个是不是有点问题。而且这个dispatch_get_global_queue也有问题，Global Dispatch Queue创建的队列,其线程数目是不定的,是根据XNU内核决定的。我觉得这一点，源码中没有解释。`\n\n\n* 绘制圆角的核心函数是这个。\n\n```\n//1.\n- (UIImage *)hyb_private_clipImageToSize:(CGSize)targetSize\n                            cornerRadius:(CGFloat)cornerRadius\n                                 corners:(UIRectCorner)corners\n                         backgroundColor:(UIColor *)backgroundColor\n                            isEqualScale:(BOOL)isEqualScale\n                                isCircle:(BOOL)isCircle {}\n\n                                CGContextRef ctx = UIGraphicsGetCurrentContext();\n\n\n\n    //2.\n    if (isCircle) {\n      CGContextAddEllipseInRect(ctx, rect);\n    } else {\n      CGContextAddRect(ctx, rect);\n    }\n\n    CGContextClip(ctx);\n    [self drawInRect:rectImage];\n\n    //3.\n\n        CGContextSetStrokeColorWithColor(ctx, [borderColor CGColor]);\n    CGContextSetLineWidth(ctx, borderWidth);\n\n    if (isCircle) {\n      CGContextStrokeEllipseInRect(ctx, rectImage);\n      CGContextStrokeEllipseInRect(ctx, rect);\n    } else if (cornerRadius == 0) {\n      CGContextStrokeRect(ctx, rectImage);\n      CGContextStrokeRect(ctx, rect);\n    }\n\n    //4.\n     UIBezierPath *path2 = [UIBezierPath bezierPathWithRoundedRect:rect\n                                                byRoundingCorners:corners\n                                                      cornerRadii:CGSizeMake(cornerRadius + minusPath1 ,cornerRadius + minusPath1)];\n\n\n    //5.\n    UIImage *finalImage = UIGraphicsGetImageFromCurrentImageContext();\n\n    return finalImage;\n```\n\n1. 里面更新size做了一些文章。是到底要做截成一个正圆，还是只截在哪个角的圆。\n2. 如果是正圆、并且不带圆角的话，就用core graphic来画。\n3. 内线和外线的绘制、以及粗细、颜色。\n4. 如果不是正圆、带圆角的多边形的图形，用UIBezierPath 曲线来绘制。关键是第二个参数，是一个枚举类型，代表哪一个或者哪一些圆角需要绘制、苹果官方的文档为`corners:\nA bitmask value that identifies the corners that you want rounded. You can use this parameter to round only a subset of the corners of the rectangle.`\n\n5. 最后直接将绘制的图形返回出来。\n6. 最后说一点、无论是UIbutton、UIImage、还是什么、笔者的思路都是先在UIView中添加方法、再在UIImage添加方法、并且进行调用、绘制图形，并且返回。\n","tags":["学习","Obeject-c"],"categories":["日志"]},{"title":"学习YYModel","url":"/2016/04/01/20160401/","content":"\n### 以YYModel的例子，它以类的方式调用\n<!-- more -->\n\n```{bash}\n+ (instancetype)yy_modelWithJSON:(id)json {\n    NSDictionary *dic = [self _yy_dictionaryWithJSON:json];\n    return [self yy_modelWithDictionary:dic];\n}\n\n<!-- 1. 直接将json的格式丢给这个函数 -->\n<!-- 2. 然后调用下面的这个函数，主要是讲这个json转化为NSDictionary的格式，如果是字符串会将字符串转化为NSData,然后再转化为NSDictionary -->\n```\n\n```{bash}\n+ (NSDictionary *)_yy_dictionaryWithJSON:(id)json {\n```\n\n* 现在开始进入最重要的函数部分了\n\n```{bash}\n//这个函数里获取model元是通过调用下面的方法，cls是获取本类而得到的Class类型\n+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary {}\n```\n\n```{bash}\n[_YYModelMeta metaWithClass:cls]\n```\n\n```{bash}\n+ (instancetype)metaWithClass:(Class)cls {\n    if (!cls) return nil;\n    static CFMutableDictionaryRef cache;\n    static dispatch_once_t onceToken;\n    //1..\n    static dispatch_semaphore_t lock;\n    dispatch_once(&onceToken, ^{\n        cache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n        lock = dispatch_semaphore_create(1);\n    });\n    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);\n    _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls));\n    dispatch_semaphore_signal(lock);\n    if (!meta || meta->_classInfo.needUpdate) {\n        meta = [[_YYModelMeta alloc] initWithClass:cls];\n        if (meta) {\n            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);\n            CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta));\n            dispatch_semaphore_signal(lock);\n        }\n    }\n    return meta;\n}\n```\n\n```{bash}\n <!-- //以信号量的方式保持同步，作用是为了从cache的内存中获取meta的数据是同步的。 -->\n dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);\n    _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls));\n    dispatch_semaphore_signal(lock);\n ```\n\n\n```{bash}\n <!-- //或者在讲meta的值塞入内存中保持同步 -->\n \t    if (!meta || meta->_classInfo.needUpdate) {\n        meta = [[_YYModelMeta alloc] initWithClass:cls];\n        if (meta) {\n            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);\n            CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta));\n            dispatch_semaphore_signal(lock);\n        }\n    }\n ```\n\n\n\n```{bash}\n <!-- 其中创建meta的时候回调用 -->\n meta = [[_YYModelMeta alloc] initWithClass:cls];\n\n - (instancetype)initWithClass:(Class)cls {\n    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];\n  \t.....  \n  }\n ```\n\n\n```{bash}\n <!-- 这里涉及到YYClassInfo的实例化方法,通过runtime的一些方法，找到本类，父类，元类。 -->\n - (instancetype)initWithClass:(Class)cls {\n    if (!cls) return nil;\n    self = [super init];\n    _cls = cls;\n    _superCls = class_getSuperclass(cls);\n    _isMeta = class_isMetaClass(cls);\n    if (!_isMeta) {\n        _metaCls = objc_getMetaClass(class_getName(cls));\n    }\n    _name = NSStringFromClass(cls);\n    [self _update];\n\n    _superClassInfo = [self.class classInfoWithClass:_superCls];\n    return self;\n}\n```\n\n* 然后在_update的方法中\n\n```{bash}\n<!-- 这里讲model中的方法、属性，ivar以key-value的形式存放在字典中。本类调用完后会在父类中调用再调用一遍。 -->\n  Class cls = self.cls;\n    unsigned int methodCount = 0;\n    Method *methods = class_copyMethodList(cls, &methodCount);\n    if (methods) {\n        NSMutableDictionary *methodInfos = [NSMutableDictionary new];\n        _methodInfos = methodInfos;\n        for (unsigned int i = 0; i < methodCount; i++) {\n            YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:methods[i]];\n            if (info.name) methodInfos[info.name] = info;\n        }\n        free(methods);\n    }\n    unsigned int propertyCount = 0;\n    objc_property_t *properties = class_copyPropertyList(cls, &propertyCount);\n    if (properties) {\n        NSMutableDictionary *propertyInfos = [NSMutableDictionary new];\n        _propertyInfos = propertyInfos;\n        for (unsigned int i = 0; i < propertyCount; i++) {\n            YYClassPropertyInfo *info = [[YYClassPropertyInfo alloc] initWithProperty:properties[i]];\n            if (info.name) propertyInfos[info.name] = info;\n        }\n        free(properties);\n    }\n....\n\n```\n\n***\n\n\n```{bash}\n <!-- * 最最关键的映射来了，YYModel把这个功能用一个递归函数来实现了。 -->\n // create mapper\n    NSMutableDictionary *mapper = [NSMutableDictionary new];\n    NSMutableArray *keyPathPropertyMetas = [NSMutableArray new];\n    NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new];\n\n    if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) {\n        NSDictionary *customMapper = [(id <YYModel>)cls modelCustomPropertyMapper];\n        [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) {\n            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];\n            if (!propertyMeta) return;\n            [allPropertyMetas removeObjectForKey:propertyName];\n\n            if ([mappedToKey isKindOfClass:[NSString class]]) {\n                if (mappedToKey.length == 0) return;\n\n                propertyMeta->_mappedToKey = mappedToKey;\n                NSArray *keyPath = [mappedToKey componentsSeparatedByString:@\".\"];\n                if (keyPath.count > 1) {\n                    propertyMeta->_mappedToKeyPath = keyPath;\n                    [keyPathPropertyMetas addObject:propertyMeta];\n                }\n                propertyMeta->_next = mapper[mappedToKey] ?: nil;\n                mapper[mappedToKey] = propertyMeta;\n\n            } else if ([mappedToKey isKindOfClass:[NSArray class]]) {\n\n                NSMutableArray *mappedToKeyArray = [NSMutableArray new];\n                for (NSString *oneKey in ((NSArray *)mappedToKey)) {\n                    if (![oneKey isKindOfClass:[NSString class]]) continue;\n                    if (oneKey.length == 0) continue;\n\n                    NSArray *keyPath = [oneKey componentsSeparatedByString:@\".\"];\n                    if (keyPath.count > 1) {\n                        [mappedToKeyArray addObject:keyPath];\n                    } else {\n                        [mappedToKeyArray addObject:oneKey];\n                    }\n\n                    if (!propertyMeta->_mappedToKey) {\n                        propertyMeta->_mappedToKey = oneKey;\n                        propertyMeta->_mappedToKeyPath = keyPath.count > 1 ? keyPath : nil;\n                    }\n                }\n                if (!propertyMeta->_mappedToKey) return;\n\n                propertyMeta->_mappedToKeyArray = mappedToKeyArray;\n                [multiKeysPropertyMetas addObject:propertyMeta];\n\n                propertyMeta->_next = mapper[mappedToKey] ?: nil;\n                mapper[mappedToKey] = propertyMeta;\n            }\n        }];\n    }\n\n\n    <!-- * 源码中就可以看出，这个映射的函数，你需要复写modelCustomPropertyMapper 这个函数\n    * 映射这个函数，你可以定义一个NSString的字符串，假如你得字符串中含有“.”这个的话，他就会将这个字符串以“.”分隔成NSArray,然后存入到_mappedToKeyPath 这个变量中。\n    * 映射也可以是一个NSArray,这样就可以实现同一个model映射到不同的key上了。 -->\n```\n","tags":["学习","Obeject-c"],"categories":["日志"]},{"title":"新的开始","url":"/2016/03/28/20160328/","content":"\n\n最近身边发生了太多太多事情，让我认识到了生命是多么的脆弱。满怀期望等待着一个什么的到来、可惜Ta却悄悄地离开了我们。我现在只想好好爱着我身边肉丝，一辈子都呵护在她身边，一直保护她，爱护她，不要让她收到一点点的伤害。 为了Rose、我了这个家、为了TA到来。我要好好鼓励工作，给你们最好的未来。\n\n```{bash}\nwhile(!isSuccess){\n    func keepMoving()\n}\n```\n","tags":["学习","我"],"categories":["日志"]}]