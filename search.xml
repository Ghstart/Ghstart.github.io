<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于RxSwift信息量的一些问题(二)]]></title>
    <url>%2F2017%2F10%2F11%2F20171011%2F</url>
    <content type="text"><![CDATA[在之前的文章中，已经介绍了一些，过滤、筛选信号量的操作符，现在列举一些复杂操作符。 首先要说的一个操作符叫做Scan，看到在官方文档中，Scan是属于在Transforming，也就可以猜到，这个操作符，其实也是信号转换的部分。 先看一下官方的介绍 The Scan operator applies a function to the first item emitted by the source Observable and then emits the result of that function as its own first emission. It also feeds the result of the function back into the function along with the second item emitted by the source Observable in order to generate its second emission. It continues to feed back its own subsequent emissions along with the subsequent emissions from the source Observable in order to create the rest of its sequence. 在看一下github上代码的： 1234567891011121314151617181920public func scan&lt;A&gt;(_ seed: A, accumulator: @escaping (A, E) throws -&gt; A) -&gt; Observable&lt;A&gt; &#123; return Scan(source: self.asObservable(), seed: seed, accumulator: accumulator)&#125;...final fileprivate class Scan&lt;Element, Accumulate&gt;: Producer&lt;Accumulate&gt; &#123;typealias Accumulator = (Accumulate, Element) throws -&gt; Accumulate fileprivate let _source: Observable&lt;Element&gt;fileprivate let _seed: Accumulatefileprivate let _accumulator: Accumulator init(source: Observable&lt;Element&gt;, seed: Accumulate, accumulator: @escaping Accumulator) &#123; _source = source _seed = seed _accumulator = accumulator&#125;&#125; 这就可以根据官方的介绍可以知道，什么是Scan Scan操作符，需要接受两个参数，一个参数是泛型A, 第二个参数是block，block的参数类型以及返回值的类型是(A, Element) -&gt; A. 这里的Element，是在也不是随编的泛型，可以看源码中知道，Scan在实例化的时候，出入了三个参数，其中第一个参数，是讲自己转化为可订阅的对象self.asObservable(),在入参中Observable&lt;Element&gt;,这就说明了，这个Element的类型，和你起初的订阅的对象的订阅类型是同一个类型。 看一下demo： 1234567891011121314151617181920212223242526272829303132333435// 这里只是将字符打印出来let bag = DisposeBag()let subject = PublishSubject&lt;String&gt;() _ = subject .subscribe(onNext: &#123;print($0)&#125;) .addDisposableTo(bag) subject.onNext("gong")subject.onNext("h")//终端输出gongh---// 这里是用来计算我输入字符长度的累加let bag = DisposeBag()let subject = PublishSubject&lt;String&gt;() _ = subject .scan(0) &#123;(count: Int, content: String) in return count + content.characters.count &#125; .subscribe(onNext: &#123;print($0)&#125;) .addDisposableTo(bag) subject.onNext("gong")subject.onNext("h")//终端输出45--- 你可以试试，看看能不能将Content的类型修改任意类型呢？答案是肯定不行的，之前在看源码的时候，我已经解释过为什么了，这里的content的类型必须要和我们制定定义subject的类型相同。 skpiWhile之前一直没有绕清楚，今天还是打算看一下源码，这只我已经说了，这个是用来筛选信号的时候用的，之前一直不清楚为什么为true的时候，就会过滤信号呢？ 查看github上代码，可以看到在，关键的代码： 123456789101112131415161718192021func on(_ event: Event&lt;Element&gt;) &#123; switch event &#123; case .next(let value): if !_running &#123; do &#123; _running = try !_parent._predicate(value) &#125; catch let e &#123; forwardOn(.error(e)) dispose() return &#125; &#125; if _running &#123; forwardOn(.next(value)) &#125; case .error, .completed: forwardOn(event) dispose() &#125;&#125; 看到代码就知道，除非是.onError()/onCompleted()事件，其他.onNext()的时间，都会先执行，你传入的block,看看你的返回值是什么？如果是true的话，就会执行forwardOn()的函数： 123456789101112131415final func forwardOn(_ event: Event&lt;O.E&gt;) &#123; #if DEBUG if AtomicIncrement(&amp;_numberOfConcurrentCalls) &gt; 1 &#123; rxFatalError("Warning: Recursive call or synchronization error!") &#125; defer &#123; _ = AtomicDecrement(&amp;_numberOfConcurrentCalls) &#125; #endif if _disposed &#123; return &#125; _observer.on(event)&#125; 这里可以看到，他讲下一个值有递归传到同一个函数中了，这样就起到了过滤的效果。 还有一些关于信号转换的问题，如何转化为数组类型,这里我用到toArray(),Demo: 这种转化是一次性的，并当你下次发送.onNext()的时候，他是不会转化，也就不会接受到.onNext()的回调. 如果在调用.onNext()值之前，你已经转化为Array，在你下次转化的时候，就无法再转化了。 1234567891011121314Observable.of(1,2,3,4) .toArray() .subscribe(onNext: &#123; dump(type(of: $0)) dump($0) &#125;) //终端输出- Swift.Array&lt;Swift.Int&gt; #0▿ 4 elements- 1- 2- 3- 4 操作符map的操作，也是接受一个block，这里直接上代码： 123456789func on(_ event: Event&lt;SourceType&gt;) &#123; switch event &#123; case .next(let element): do &#123; let mappedElement = try _transform(element) forwardOn(.next(mappedElement)) &#125; ....&#125; 这里可以看到我们出入的block 就像一个加工厂一样，会将接受到的element的参数，经过我们传入的block加工后，会返回一个新的值，然后又会回传给自己。这样每次接受到的就是新值了。 而操作符mapWithIndex会回传回来两个参数，一个value值，一个是index值，这里又是什么意思呢？看一下源代码： 1234567891011121314151617181920212223242526....private var _index = 0...func on(_ event: Event&lt;SourceType&gt;) &#123; switch event &#123; case .next(let element): do &#123; let mappedElement = try _selector(element, try incrementChecked(&amp;_index)) forwardOn(.next(mappedElement)) &#125; ... func incrementChecked(_ i: inout Int) throws -&gt; Int &#123; if i == Int.max &#123; throw RxError.overflow &#125; defer &#123; i += 1 &#125; return i&#125; ... 很明显了，index初始值是从0开始，每次都会拿到指针，进行累加，然后回传回去，也就是我们所说的index了。 下面一个比较难理解的操作符叫做flatMap,看官网上的介绍为是这样的： transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable 这句话其实非常绕，可能不理解的人可能一直读不懂。首先理解第一句话，transform the items emitted by an Observable into Observables: 我的理解是，由一个可被订阅的对象发出的多个值，通过我们传入的block,来变换为多个可订阅的对象 12345678910111213141516171819202122232425let bag = DisposeBag()let subject = PublishSubject&lt;GHObject&gt;() _ = subject .flatMap&#123; $0.gh_value.asObservable() &#125; .subscribe(onNext: &#123; print(type(of: $0)) dump($0) &#125;).addDisposableTo(bag) let gh1 = GHObject(gh_value: Variable(10)) subject.onNext(gh1)gh1.gh_value.value = 11...struct GHObject &#123; var gh_value: Variable&lt;Int&gt;&#125;//终端输出- 10- 11 那第二句话怎么理解呢？then flatten the emissions from those into a single Observable,通过上面的代码已经知道了，我们通过flatMap操作符，已经将GHObject-&gt;Int，如果我存在多个GHObject的对象，同事发出值，此时我们就可以看做是将多个Int的值发送了出来，至于是哪个GHObject发送出来的，我们不需要关心： 123456789101112131415161718192021222324252627282930let bag = DisposeBag()let subject = PublishSubject&lt;GHObject&gt;() _ = subject .flatMap&#123; $0.gh_value.asObservable() &#125; .subscribe(onNext: &#123; dump($0) &#125;).addDisposableTo(bag) let gh1 = GHObject(gh_value: Variable(10)) subject.onNext(gh1)gh1.gh_value.value = 11 let gh2 = GHObject(gh_value: Variable(100))subject.onNext(gh2) gh1.gh_value.value = 12gh2.gh_value.value = 101gh2.gh_value.value = 102//终端输出- 10- 11- 100- 12- 101- 102 至于和flatMap类似的一个操作符,我们叫做flatMapLatest,我是这么李操操作符的：一点接受了一个新的GHObject发的gh_value值之后，之前旧的GHObject_value发出的gh_value我们都会统统过滤掉，Demo: 12345678910111213141516171819202122232425262728293031323334let bag = DisposeBag()let subject = PublishSubject&lt;GHObject&gt;() _ = subject .flatMapLatest&#123; $0.gh_value.asObservable() &#125; .subscribe(onNext: &#123; dump($0) &#125;).addDisposableTo(bag) let gh1 = GHObject(gh_value: Variable(10)) subject.onNext(gh1)gh1.gh_value.value = 11 let gh2 = GHObject(gh_value: Variable(100))subject.onNext(gh2) gh1.gh_value.value = 12gh2.gh_value.value = 101gh2.gh_value.value = 102 gh1.gh_value.value = 13gh1.gh_value.value = 14gh1.gh_value.value = 15//终端输出- 10- 11- 100- 101- 102 这个flatMapLatest听上去比较绕，但是一旦拿起笔画画，就会很清晰了。 在获取某些信号量的时候，我们需要在此之前获取其他的信号，这里我们可以用到.startWith(_ elements: E ...)，看一下github中的源码，就会发现了： 12345678910111213141516public func startWith(_ elements: E ...) -&gt; Observable&lt;E&gt; &#123; return StartWith(source: self.asObservable(), elements: elements)&#125;...override func run&lt;O : ObserverType&gt;(_ observer: O, cancel: Cancelable) -&gt; (sink: Disposable, subscription: Disposable) where O.E == Element &#123; for e in elements &#123; observer.on(.next(e)) &#125; return (sink: Disposables.create(), subscription: source.subscribe(observer))&#125;... 看到这里，你应该也就知道了，这个startWith接受的是一个可变参数，在正在订阅到自己想要的数据之前，会先遍历打印之前的信号。看一下Demo: 1234567891011121314151617181920let bag = DisposeBag()let subject = PublishSubject&lt;String&gt;() subject .startWith("Step1", "Step2", "Step3") .subscribe(onNext: &#123; print($0) &#125;).addDisposableTo(bag) subject.onNext("Do somethingA")print("----")subject.onNext("Do somethingB")//终端输出Step1Step2Step3Do somethingA----Do somethingB 可以看出，他不是每次订阅的时候，都会将startWith中的值打印一遍，只会打印一次。 串联链接多个事件的操作符，我们可以使用concat,调用方式有很多种，看一下源码： 1234567891011121314extension ObservableType &#123; /** Concatenates the second observable sequence to `self` upon successful termination of `self`. - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html) - parameter second: Second observable sequence. - returns: An observable sequence that contains the elements of `self`, followed by those of the second sequence. */ public func concat&lt;O: ObservableConvertibleType&gt;(_ second: O) -&gt; Observable&lt;E&gt; where O.E == E &#123; return Observable.concat([self.asObservable(), second.asObservable()]) &#125;&#125; 看这种定义的方式，我们可以这样实现concat: 1234567891011121314151617181920let bag = DisposeBag() let subjectA = PublishSubject&lt;String&gt;()let subjectB = PublishSubject&lt;String&gt;()let subjectC = PublishSubject&lt;String&gt;() _ = subjectA.concat(subjectB.concat(subjectC)).subscribe(onNext: &#123; print($0)&#125;).addDisposableTo(bag) subjectA.onNext("A1")subjectA.onCompleted()subjectB.onNext("B1")subjectB.onCompleted()subjectC.onNext("C1")//终端的输出A1B1C1 这里你可以将subjectA.onCompleted()注释掉，你会发现终端的输出只有A1,这也就解释了串行队列，只有在subjectA完成的时候，他才会订阅下一个时间。 系统还给Observable写了个extension，这样在正在调用的时候，更加方便、直观。看源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354extension Observable &#123; /** Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully. This operator has tail recursive optimizations that will prevent stack overflow. Optimizations will be performed in cases equivalent to following: [1, [2, [3, .....].concat()].concat].concat() - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html) - returns: An observable sequence that contains the elements of each given sequence, in sequential order. */ public static func concat&lt;S: Sequence &gt;(_ sequence: S) -&gt; Observable&lt;Element&gt; where S.Iterator.Element == Observable&lt;Element&gt; &#123; return Concat(sources: sequence, count: nil) &#125; /** Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully. This operator has tail recursive optimizations that will prevent stack overflow. Optimizations will be performed in cases equivalent to following: [1, [2, [3, .....].concat()].concat].concat() - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html) - returns: An observable sequence that contains the elements of each given sequence, in sequential order. */ public static func concat&lt;S: Collection &gt;(_ collection: S) -&gt; Observable&lt;Element&gt; where S.Iterator.Element == Observable&lt;Element&gt; &#123; return Concat(sources: collection, count: collection.count.toIntMax()) &#125; /** Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully. This operator has tail recursive optimizations that will prevent stack overflow. Optimizations will be performed in cases equivalent to following: [1, [2, [3, .....].concat()].concat].concat() - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html) - returns: An observable sequence that contains the elements of each given sequence, in sequential order. */ public static func concat(_ sources: Observable&lt;Element&gt; ...) -&gt; Observable&lt;Element&gt; &#123; return Concat(sources: sources, count: sources.count.toIntMax()) &#125;&#125; 这里可以接受自定义的、系统的集合类型，以及一个可变的类型，都是可以这样使用的。上面的代码就可以按照Demo所写的那样完成: 12345678Observable.concat([subjectA, subjectB, subjectC]) .subscribe(onNext: &#123; print($0) &#125;).addDisposableTo(bag) Observable.concat(subjectA, subjectB, subjectC) .subscribe(onNext: &#123;print($0)&#125;) .addDisposableTo(bag) 如果是并行操作时间的话，我们可以选用.merge()的操作符: 12345678910111213141516Observable.merge(subjectA, subjectB, subjectC) .subscribe(onNext: &#123;print($0)&#125;) .addDisposableTo(bag) subjectA.onNext("A1")//subjectA.onCompleted()subjectB.onNext("B1")//subjectB.onCompleted()subjectC.onNext("C1")// 终端输出A1B1C1 这样可以看出来，及时在之前的时间不完成的情况下，事件的打印依旧。 为了方便控制并行的个数，我们也可以这样使用 1234Observable.of(subjectA, subjectB, subjectC) .merge(maxConcurrent: 2) .subscribe(onNext: &#123;print($0)&#125;) .addDisposableTo(bag) 合并多个事件的操作符我们可以使用combineLatest,Demo： 123456789101112131415161718192021let subjectA = PublishSubject&lt;String&gt;()let subjectB = PublishSubject&lt;String&gt;() Observable.combineLatest(subjectA, subjectB) &#123; a, b in a + "," + b &#125;.subscribe(onNext: &#123; dump($0)&#125;).addDisposableTo(bag) subjectA.onNext("A1")subjectB.onNext("B1")subjectA.onNext("A2")subjectB.onNext("B2")//终端输出- "A1,B1"- "A2,B1"- "A2,B2" 如果是个时间的合并。类似下面： 1234567891011121314151617181920let subjectA = PublishSubject&lt;String&gt;()let subjectB = PublishSubject&lt;String&gt;()let subjectC = PublishSubject&lt;String&gt;() Observable.combineLatest([subjectA, subjectB, subjectC]) &#123; events in events.joined(separator: "--") &#125;.subscribe(onNext: &#123; dump($0)&#125;).addDisposableTo(bag) subjectA.onNext("A1")subjectB.onNext("B1")subjectA.onNext("A2")subjectB.onNext("B2")subjectC.onNext("C1")//终端输出- "A2--B2--C1" combineLatest合并的时间中，必须至少都发生了一次事件发送。 任一一个时间发生更新的时候，都会发生回调。 每次获取的值，都是当前事件的最新的值。 combineLatest接受的合并事件也可以是不同的值类型 例如下面： 12345678910111213141516171819202122let bag = DisposeBag() let subjectA = PublishSubject&lt;String&gt;()let subjectB = PublishSubject&lt;Int&gt;() Observable.combineLatest(subjectA, subjectB) &#123; a, b in a + "," + "\(b)" &#125;.subscribe(onNext: &#123; dump($0)&#125;).addDisposableTo(bag) subjectA.onNext("A1")subjectB.onNext(11)subjectA.onNext("A2")subjectB.onNext(22)/、终端输出- "A1,11"- "A2,11"- "A2,22" 每次只会合并多个最新的时间话，这里我可以使用.zip()的操作符: 1234567891011121314151617181920212223let bag = DisposeBag() let subjectA = PublishSubject&lt;String&gt;()let subjectB = PublishSubject&lt;Int&gt;()//let subjectC = PublishSubject&lt;String&gt;() Observable.zip(subjectA, subjectB) &#123; a, b in a + "," + "\(b)" &#125;.subscribe(onNext: &#123; dump($0)&#125;).addDisposableTo(bag) subjectA.onNext("A1")subjectB.onNext(11)subjectA.onNext("A2")subjectB.onNext(22)//终端的输出- "A1,11"- "A2,22" 如果存在多个observable,并且存在一定的依赖关系，在某件事情发送的时候，会去获取另一时间的最新值: 123456789101112131415161718let bag = DisposeBag() let triggerSubject = PublishSubject&lt;Void&gt;()let contentSubject = BehaviorSubject&lt;String&gt;(value: "Default value") _ = triggerSubject.withLatestFrom(contentSubject).subscribe(onNext: &#123; print($0)&#125;).addDisposableTo(bag) triggerSubject.onNext(())contentSubject.onNext("Input Extra Content")triggerSubject.onNext(())//终端输出Default valueInput Extra Content 在不同的observable中，我们可以随意切换任意的时间，使用操作符.switchLatest(),这样只能在指定的模式下，做指定的事件： 1234567891011121314151617181920212223let bag = DisposeBag() let reading = PublishSubject&lt;String&gt;()let writing = PublishSubject&lt;String&gt;() let work = PublishSubject&lt;Observable&lt;String&gt;&gt;()work.switchLatest() .subscribe(onNext: &#123; print($0) &#125;).addDisposableTo(bag) work.onNext(reading)reading.onNext("Read 1") work.onNext(writing)writing.onNext("Write 1") reading.onNext("Read Extra") work.onNext(reading)reading.onNext("Read 2")]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于RxSwift信息量的一些问题]]></title>
    <url>%2F2017%2F10%2F08%2F20171007%2F</url>
    <content type="text"><![CDATA[之前的文章中，介绍了RxSwift中，将之前传统的模式修改为更Rx的模式，在转换的过程中，我们会发现，其实RxSwift只是将之前分散处理的恭喜，收拢起来，之前我们或许关心的是block的回调、代理方法、function()调用，而现在我们或许只需要关心一件事情信号量，可想而知，伴随着项目的庞大、功能的复杂，整个项目中充斥着的都是这些信号，此时我们就要学会分析、过滤、转化信号。 先不去深究下面列举的每个操作符的源代码，在碰到一些特别难以理解的操作符，我们再去查看一下源代码 忽略信号的操作： 1.先来看一下最最普通的订阅模式： 1234567891011121314151617181920let subject = PublishSubject&lt;Int&gt;()let bag = DisposeBag() _ = subject.subscribe( onNext: &#123; print($0) &#125;, onCompleted: &#123; print("Completed") &#125;).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)subject.onNext(4)subject.onCompleted()// 终端输入1234Completed 如果我们需要忽略所有的.onNext()的时间话，我们可以用.ignoreElements()操作符 123456789101112131415161718let subject = PublishSubject&lt;Int&gt;()let bag = DisposeBag() _ = subject .ignoreElements() .subscribe( onNext: &#123; print($0) &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)subject.onNext(4)subject.onCompleted()//终端输出Completed 如果忽略前几个.onNext()事件信号量，我们可以使用.skip()操作符,例如.skip(2)如果不足2个的话，那就都跳过,直接.onCompleted()或者.onError(): 1234567891011121314151617_ = subject .skip(2) .subscribe( onNext: &#123; print($0) &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)subject.onNext(4)subject.onCompleted()//终端输出34Completed 指定条件过滤数据，我们可以选用.skipWhile()，这里.skipWhile()接受的是一个block，理解起来可能会比较绕，但是看一下github上的解释： 123456789/** Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements. - seealso: [skipWhile operator on reactivex.io](http://reactivex.io/documentation/operators/skipwhile.html) - parameter predicate: A function to test each element for a condition. - returns: An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate. */public func skipWhile(_ predicate: @escaping (E) throws -&gt; Bool) -&gt; Observable&lt;E&gt; &#123; return SkipWhile(source: asObservable(), predicate: predicate)&#125; 只要条件为true，我们就会绕过发出的信号，看一下Demo： 12345678910111213141516171819202122let subject = PublishSubject&lt;Int&gt;()let bag = DisposeBag() _ = subject .skipWhile(&#123; (item) -&gt; Bool in return item != 3 &#125;) .subscribe( onNext: &#123; print($0) &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)subject.onNext(4)subject.onCompleted()//终端输出34Completed 依赖某个信号量的时候，我们可以选用.skipUntil(),这里的入参是例外一个信号量： 123456789101112131415161718192021let subject = PublishSubject&lt;Int&gt;()let dependOnSubject = PublishSubject&lt;Void&gt;()let bag = DisposeBag() _ = subject .skipUntil(dependOnSubject) .subscribe( onNext: &#123; print($0) &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)dependOnSubject.onNext(())subject.onNext(4)subject.onCompleted()//终端输出4Completed 忽略重复出现的相邻的信号量，我们可以使用.distinctUntilChanged(), demo: 1234567891011121314151617181920212223242526272829let subject = PublishSubject&lt;Int&gt;()let bag = DisposeBag() _ = subject .distinctUntilChanged() .subscribe( onNext: &#123; print($0) &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(2)subject.onNext(3)subject.onNext(3)subject.onNext(3)subject.onNext(4)subject.onNext(2)subject.onNext(3)subject.onCompleted()//终端输出123423Completed 选择信号的操作 选择指定第几个信号量的操作符，我们可以选用.elementAt(),当选择的个数超过了存在的信号量，此时就会报.onError()的错误，Demo： 12345678910111213141516171819let subject = PublishSubject&lt;Int&gt;()let bag = DisposeBag() _ = subject .elementAt(2) .subscribe( onNext: &#123; print($0) &#125;, onError: &#123;_ in print("Error") &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)subject.onNext(4)subject.onCompleted()//终端的输出3Completed 根据某些条件，筛选过滤出自己想要的数据，我们可以选用.filter()的操作符： 123456789101112131415161718192021let subject = PublishSubject&lt;Int&gt;()let bag = DisposeBag() _ = subject .filter(&#123; (item) -&gt; Bool in item == 2 &#125;) .subscribe( onNext: &#123; print($0) &#125;, onError: &#123;_ in print("Error") &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)subject.onNext(4)subject.onCompleted()//终端输出2Completed 获取指定数量的操作符，我们也可以选用.take(),当入参的数字大于已有的数据，就会把所有的.onNext()事件都打印出来: 1234567891011121314151617181920let subject = PublishSubject&lt;Int&gt;()let bag = DisposeBag() _ = subject .take(2) .subscribe( onNext: &#123; print($0) &#125;, onError: &#123;_ in print("Error") &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)subject.onNext(4)subject.onCompleted()//终端输出12Completed 还有一个比较绕的操作符，叫做takeWhile(),和skipWhile()类似，只要block中返回的是true的话，就会选取这儿元素，一旦false就结束 123456789101112131415161718192021let subject = PublishSubject&lt;Int&gt;()let bag = DisposeBag() _ = subject .takeWhile(&#123; (item) -&gt; Bool in item != 2 &#125;) .subscribe( onNext: &#123; print($0) &#125;, onError: &#123;_ in print("Error") &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)subject.onNext(4)subject.onCompleted()//终端输入1Completed 准备定位到第几个的话，可以选用下面的操作符takeWhileWithIndex, 它接受两个参数，一个index,一个value,同样为true，就会选取，为false，就立刻结束 123456789101112131415161718192021let subject = PublishSubject&lt;Int&gt;()let bag = DisposeBag() _ = subject .takeWhileWithIndex(&#123; (item, index) -&gt; Bool in item != 2 &amp;&amp; index != 3 &#125;) .subscribe( onNext: &#123; print($0) &#125;, onError: &#123;_ in print("Error") &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)subject.onNext(3)subject.onNext(4)subject.onCompleted()//终端输出1Completed 依赖于某个信号，来获取信号量，可以选用.takeUntil(),Demo 12345678910111213141516171819202122let subject = PublishSubject&lt;Int&gt;()let dependOnSubject = PublishSubject&lt;Void&gt;()let bag = DisposeBag() _ = subject .takeUntil(dependOnSubject) .subscribe( onNext: &#123; print($0) &#125;, onError: &#123;_ in print("Error") &#125;, onCompleted: &#123; print("Completed") &#125; ).addDisposableTo(bag) subject.onNext(1)subject.onNext(2)dependOnSubject.onNext(())subject.onNext(3)subject.onNext(4)subject.onCompleted()//终端输出12Completed 为了同时订阅同个数据的不同信号量，节约开销，我们可以使用这个.share() 1234let object = Observable.of(1,2,3,4,5).share()_ = object.subscribe(&#123; print($0 )&#125;)_ = object.subscribe(&#123; print($0 )&#125;)]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实际项目中从传统模式切换为RxSwift模式]]></title>
    <url>%2F2017%2F10%2F05%2F20171005%2F</url>
    <content type="text"><![CDATA[举一个简单的例子，来实现RxSwift的功能： 列表Controller里面的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import UIKitclass TestRxSwiftViewController: UIViewController, UITableViewDataSource &#123; var datas = [TestRxSwiftItemObject]() @IBOutlet weak var ItemTableview: UITableView! // MARK: -- Life Cycle override func viewDidLoad() &#123; super.viewDidLoad() loadDatas() ItemTableview.reloadData() &#125; override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == "testRx" &#123; let detail: TestRxSwiftDetailViewController = segue.destination as! TestRxSwiftDetailViewController if let index = ItemTableview.indexPath(for: sender as! UITableViewCell) &#123; detail.Item = datas[index.row] &#125; &#125; &#125; // MARK: -- Private Methods func loadDatas() &#123; for i in 1..&lt;10 &#123; let itemObject = TestRxSwiftItemObject(name: "Index-\(i)", isClicked: i % 2 == 0 ? true : false) datas.append(itemObject) &#125; &#125; // MARK: -- UITableView DataSource func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return datas.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath) let itemObject = datas[indexPath.row] cell.textLabel?.text = itemObject.name cell.accessoryType = itemObject.isClicked ? .checkmark : .none return cell &#125;&#125; 详情Controller里面的代码： 123456789101112131415161718class TestRxSwiftDetailViewController: UIViewController &#123; @IBOutlet weak var content: UITextField! @IBOutlet weak var isOn: UISwitch! var Item: TestRxSwiftItemObject? override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. if let Item = Item &#123; content.text = Item.name isOn.isOn = Item.isClicked &#125; &#125;&#125; 切换为RxSwift的模式 首先我们将我们在列表控制器里面的Array, 更换为可以订阅的变量，这里我们用Variable来代替: 1234//之前var datas = [TestRxSwiftItemObject]()//之后var datas = Variable&lt;[TestRxSwiftItemObject]&gt;([]) 并且将所有的去数据中的对象的方法切换一下： 1234//之前let itemObject = datas[indexPath.row]//之后let itemObject = datas.value[indexPath.row] 然后我们只需要更加、删除数据，关于UI的切换，我们可以统一做处理，如下： 以为之前我们已经将data，切换为Variable了，这样我们可以通过调用asObservable()就可以改为可定于的订阅的对象，并且可以接受到回调。 12345678910111213_ = datas.asObservable().subscribe( onNext: &#123; [weak self] todos in self?.updateUI(todos: todos) &#125;).addDisposableTo(bag)func updateUI(todos: [TestRxSwiftItemObject]) &#123; title = todos.isEmpty ? "Todos" : "\(todos.count) Todos" addBtn.isEnabled = todos.filter &#123; !$0.isClicked &#125;.count &lt; 6 ItemTableview.reloadData()&#125; 关于的数据的传递，涉及到两点，第一个：我们如何从首页数据传递给第二个控制器呢？通过公开的属性传递： 123let detail: TestRxSwiftDetailViewController = segue.destination as! TestRxSwiftDetailViewControllerif let index = ItemTableview.indexPath(for: sender as! UITableViewCell) &#123;detail.Item = datas.value[index.row] 第二点我们如何将第二个控制器里面的属性回传给首页控制器呢？，我们在第二页控制器里公开出一个可以订阅的对象，这样我们只要在第二个控制前里面修改数据值，并且传递，就能再第一个控制器里面接收到回调了。这里有个两点： 1234fileprivate var itemSubject = PublishSubject&lt;TestRxSwiftItemObject&gt;()var item: Observable&lt;TestRxSwiftItemObject&gt; &#123; return itemSubject.asObservable()&#125; 首先定义的fileprivate,阻止了外部给这个变量发送数据。而仅仅只是给外部暴露了一个item的对像。 而在对象内部，我们依旧可以通过itemSubject来发送数据，并且外部也能够接受到回调。 点击保存，第二个页面dismiss之前，我执行如下的保存操作： 1234567if let item = Item &#123; item.name = content.text! item.isClicked = isOn.isOn itemSubject.onNext(item) itemSubject.onCompleted()&#125; 这样在首页我们就可以这样接受到回调了： 123456789101112let detail: TestRxSwiftDetailViewController = segue.destination as! TestRxSwiftDetailViewControllerif let index = ItemTableview.indexPath(for: sender as! UITableViewCell) &#123; detail.Item = datas.value[index.row] _ = detail.item.subscribe( onNext: &#123; [weak self] newTodo in self?.datas.value[index.row] = newTodo &#125;, onDisposed: &#123; print("Finishing changing item content") &#125; )&#125; 关于最后一点异步的回调操作，简单的来说，我们将之前返回值Void-&gt;Observable&lt;Void&gt;或者URL-&gt;Observable&lt;URL&gt;,Demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152enum CustomError: Error &#123; case someOptionErrors case urlIsNullError&#125;func syncToSaveDatas() -&gt; Observable&lt;URL&gt; &#123; return Observable.create &#123; observer in var testURL: URL? var someOptions: Bool testURL = URL(string: "") someOptions = true // Error 1 guard someOptions else &#123; observer.onError(CustomError.someOptionErrors) return Disposables.create() &#125; if let testURL = testURL &#123; // success observer.onNext(testURL) observer.onCompleted() &#125; else &#123; // Error 2 observer.onError(CustomError.urlIsNullError) return Disposables.create() &#125; return Disposables.create() &#125;&#125;@IBAction func saveDatas(_ sender: Any) &#123; _ = syncToSaveDatas().subscribe( onNext: &#123; url in print(url) &#125;, onError: &#123; print("error is \($0)") &#125;, onCompleted: &#123; print("Success") &#125; )&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习RxSwift]]></title>
    <url>%2F2017%2F10%2F03%2F20171003%2F</url>
    <content type="text"><![CDATA[创建可以订阅的对象，在RxSwift中称之为Observable,我们可以通过系统介绍给我的方法来创建(我们称之为Operators)。 这里我们通过Create的Operators的方法来创建，先看一下官网[http://reactivex.io/documentation/operators/create.html] 的介绍: You can create an Observable from scratch by using the Create operator. You pass this operator a function that accepts the observer as its parameter. Write this function so that it behaves as an Observable — by calling the observer’s onNext, onError, and onCompleted methods appropriately.A well-formed finite Observable must attempt to call either the observer’s onCompleted method exactly once or its onError method exactly once, and must not thereafter attempt to call any of the observer’s other methods. 再看一下github上源码： 123456789101112extension Observable &#123; // MARK: create /** Creates an observable sequence from a specified subscribe method implementation. - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html) - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method. - returns: The observable sequence with the specified implementation for the `subscribe` method. */ public static func create(_ subscribe: @escaping (AnyObserver&lt;E&gt;) -&gt; Disposable) -&gt; Observable&lt;E&gt; &#123; return AnonymousObservable(subscribe) &#125;&#125; 按照官网的介绍，我们就可以通过Create来创建一个可被订阅的对象，这个对象的入参是一个block，任意对象的Observer,他可以发送.onNext()/.onComplete()/.onError() 第二段的注释的意思，就是这个Observer可以发送.onNext(),但是这个对象一旦发送了一次.onComplete()或者.onError(),然后就不能尝试调用任何观察者的其他方法了。看一下Demo： 12345678910111213141516171819202122232425enum CustomeError: Error &#123; case somethingError&#125; let customOB = Observable&lt;Int&gt;.create &#123; observer in observer.onNext(1) observer.onNext(2) //observer.onError(CustomeError.somethingError) observer.onCompleted() return Disposables.create()&#125;let disposeBag1 = DisposeBag()customOB.subscribe( onNext: &#123; print($0) &#125;, onError: &#123; print($0) &#125;, onCompleted: &#123; print("onCompleted") &#125;, onDisposed: &#123; print("onDisposed") &#125;).addDisposableTo(disposeBag1) 这创建的依旧是一个Observer的对象，也可以调用其他的Operator,这里为了方便的调试，我们可以使用.debug()。使用如下： 1234567891011121314151617181920let disposeBag1 = DisposeBag()customOB .debug() .subscribe( onNext: &#123; print($0) &#125;, onError: &#123; print($0) &#125;, onCompleted: &#123; print("onCompleted") &#125;, onDisposed: &#123; print("onDisposed") &#125; ).addDisposableTo(disposeBag1) // 控制台的打印信息如下：2017-10-03 13:58:23.488: ViewController.swift:35 (viewDidLoad()) -&gt; subscribed2017-10-03 13:58:23.493: ViewController.swift:35 (viewDidLoad()) -&gt; Event next(1)12017-10-03 13:58:23.493: ViewController.swift:35 (viewDidLoad()) -&gt; Event next(2)22017-10-03 13:58:23.493: ViewController.swift:35 (viewDidLoad()) -&gt; Event completedonCompletedonDisposed2017-10-03 13:58:23.493: ViewController.swift:35 (viewDidLoad()) -&gt; isDisposed 在我们真是的项目中，我们可能需要不仅仅是一个订阅者或者发布者，我们需要的是一个不仅可以订阅、也可以发布的对象，在RxSwift中，我们称之为Subjects: 首选我们要说的Subjects对象叫做PublishSubject,看一下github上的源码： 1234/// Represents an object that is both an observable sequence as well as an observer.////// Each notification is broadcasted to all subscribed observers.public final class PublishSubject&lt;Element&gt; 再看官网上对PublishSubject对象的介绍： PublishSubject emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription. Note that a PublishSubject may begin emitting items immediately upon creation (unless you have taken steps to prevent this), and so there is a risk that one or more items may be lost between the time the Subject is created and the observer subscribes to it. If you need to guarantee delivery of all items from the source Observable, you’ll need either to form that Observable with Create so that you can manually reintroduce “cold” Observable behavior (checking to see that all observers have subscribed before beginning to emit items), or switch to using a ReplaySubject instead. If the source Observable terminates with an error, the PublishSubject will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable. 只有先订阅消息，再发送消息，才能接受到消息 首先可以看出来，这个对象是Cold Sign,这里所谓的Cold，就代表，当创建完这个对象的时候，并不会立刻发送数据，而只有在有订阅者订阅它的时候，它才会发送数据。 而这里还有一点很重要的是，PublishSubject只能够订阅在它之后发送的数据，这一点也就是说，在这个订阅消息之前，不管我们发送了多少数据，在真正订阅之后，这些之前订阅的数据是不会发送的。 并且在约到失败的时候，这个对象就将被终止，除了在回调的.onError()方法之外，以后所有的数据都将无法接受。看一下Demo： 12345678910111213141516171819202122232425262728293031let subject = PublishSubject&lt;String&gt;()subject.onNext("Test1")subject.onNext("Test2")let sub1 = subject.subscribe( onNext: &#123; print("1:) \($0)")&#125;)subject.onNext("Test3")subject.onNext("Test4")sub1.dispose()subject.onNext("Test5")let sub2 = subject.subscribe( onNext: &#123; print("2:) \($0)")&#125;)subject.onNext("Test6")subject.onNext("Test7")sub2.dispose()// 终端输出为1:) Test31:) Test42:) Test62:) Test7 第二种同时即可以订阅，也可以发送消息的对象，我们这里叫做BehaviorSubject。这里我们先看一下github中代码: 1234/// Represents a value that changes over time.////// Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.public final class BehaviorSubject&lt;Element&gt; 再看一下官网上的介绍： When an observer subscribes to a BehaviorSubject, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s). However, if the source Observable terminates with an error, the BehaviorSubject will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable. 看到注释以及代码的意思，这种Subject的对象的特点就是，订阅这种对象，它就可以接收到最近的一次值或者是初始化的默认值 同样，这个Subject的对象，，一旦接受到.onError()或者.onComplete(), 这个对象将不会再发送任何值了。看一下Demo： 1234567891011121314151617181920212223242526let subject = BehaviorSubject&lt;String&gt;(value: "Default Value")let sub1 = subject.subscribe( onNext: &#123; print("From1:\($0)") &#125;)subject.onNext("Test1")sub1.dispose()let sub2 = subject.subscribe( onNext: &#123;print("From2:\($0)")&#125;)subject.onNext("Test2")subject.onNext("Test3")sub2.dispose()// 终端输出From1:Default ValueFrom1:Test1---From2:Test1From2:Test2From2:Test3 这里可以通过BehaviorSubject可以查看最近一次发送数据，如果是第一次，就会接受到默认的数据，但是如果我们想要接受指定数目的历史数据，我们可以使用另外一种subject，我们叫做：ReplaySubject. 看一下github上代码的： 12/// Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.public class ReplaySubject&lt;Element&gt; ReplaySubject emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes. There are also versions of ReplaySubject that will throw away old items once the replay buffer threatens to grow beyond a certain size, or when a specified timespan has passed since the items were originally emitted. If you use a ReplaySubject as an observer, take care not to call its onNext method (or its other on methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates the Observable contract and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first. ReplaySubject对象不能初始化默认值、并且每次打印历史数据的值是可以控制的，看一下Demo： 123456789101112131415161718192021222324252627let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 2)let sub1 = subject.subscribe( onNext: &#123; print("From 1:| \($0)")&#125;)subject.onNext("Test1")subject.onNext("Test2")subject.onNext("Test3")sub1.dispose()let sub2 = subject.subscribe( onNext: &#123; print("From 2:| \($0)")&#125;)subject.onNext("Test4")sub2.dispose()// 终端输出From 1:| Test1From 1:| Test2From 1:| Test3From 2:| Test2From 2:| Test3From 2:| Test4 第三种Subjects, 我们叫做Variable, 看一下github上的注释: 12345/// Variable is a wrapper for `BehaviorSubject`.////// Unlike `BehaviorSubject` it can't terminate with error, and when variable is deallocated/// it will complete its observable sequence (`asObservable`).public final class Variable&lt;Element&gt; &#123; 特点：1.这个对象是对BehaviorSubject的上层封装。2.对象不能通过发送Error而终止对象发送数据。3.通过调用asObservable，可以转化为Observer对象。 Demo: 1234567891011121314let subject = Variable("Test1")let _ = subject.asObservable().subscribe( onNext: &#123;print("1:\($0)")&#125;)subject.value = "Changed"print(subject.value)// 终端输出1:Test11:ChangedChanged]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Swift Tips(三)]]></title>
    <url>%2F2017%2F09%2F14%2F20170914%2F</url>
    <content type="text"><![CDATA[final修饰的class/func/var,表示内容不允许进行继承或者重写 lazy简单赋值：lazy var str1: String = &quot;Hello&quot; lazy计算赋值： 1234567lazy var str: String = &#123; let str = "Hello" print("只有首次访问输出") return str &#125;() lazy用在一些map/filter： 1234567let result = data.lazy.map &#123; (i: Int) -&gt; Int in print("正在处理 \(i)") return i * 2&#125; Swift 中的镜像以及反射的问题：我们可以通过Mirror来实现： 123456789101112131415161718192021222324252627282930let xiaoming = Person(name: "XiaoMing", age: 16)let r = Mirror(reflecting: xiaoming)if let name = valueFrom(xiaoming, key: "name") as? String &#123; print("通过key 得到值:\(name)")&#125;dump(xiaoming)print("xiaoming 是\(r.displayStyle!)")print("属性个数:\(r.children.count)")for child in r.children &#123; print("属性名:\(String(describing: child.label)),值:\(child.value)")&#125;func valueFrom(_ object: Any, key: String) -&gt; Any? &#123; let mirror = Mirror(reflecting: object) for child in mirror.children &#123; let (targetKey, targetMirror) = (child.label, child.value) if key == targetKey &#123; return targetMirror &#125; &#125; return nil&#125; 隐式解包并不能确保属性一定有值，或者一定安全，而是在获取属性值的时候，自动强制解包，如果该值是nil的话，在调用的时候，也是会crash的。 optional定义其实就是个枚举： 123456789101112let aNil: String? = nillet anotherNil: String?? = aNillet literalNil: String?? = nilif let _ = anotherNil &#123; print("anotherNil")&#125;if let _ = literalNil &#123; print("literalNil")&#125; 打印optional可以通过fr v -R xxx map的使用，我见的最多的就是在数组等集合中的map使用，先来看一下map的定义: 123456789101112131415161718/// Returns an array containing the results of mapping the given closure/// over the sequence's elements.////// In this example, `map` is used first to convert the names in the array/// to lowercase strings and then to count their characters.////// let cast = ["Vivien", "Marlon", "Kim", "Karl"]/// let lowercaseNames = cast.map &#123; $0.lowercaseString &#125;/// // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]/// let letterCounts = cast.map &#123; $0.characters.count &#125;/// // 'letterCounts' == [6, 6, 3, 4]////// - Parameter transform: A mapping closure. `transform` accepts an/// element of this sequence as its parameter and returns a transformed/// value of the same or of a different type./// - Returns: An array containing the transformed elements of this/// sequence.public func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T] 清晰明了，这里定义的泛型为T, 函数内部的block，将另外一种泛型Element转化为T，最后还是生成一个[T]类型的数组。 除了数组的map外，这里作者还说了一下Optional的map行数，效果一样： 123456789101112131415161718192021222324252627282930/// Evaluates the given closure when this `Optional` instance is not `nil`,/// passing the unwrapped value as a parameter.////// Use the `map` method with a closure that returns a nonoptional value./// This example performs an arithmetic operation on an/// optional integer.////// let possibleNumber: Int? = Int("42")/// let possibleSquare = possibleNumber.map &#123; $0 * $0 &#125;/// print(possibleSquare)/// // Prints "Optional(1746)"////// let noNumber: Int? = nil/// let noSquare = noNumber.map &#123; $0 * $0 &#125;/// print(noSquare)/// // Prints "nil"////// - Parameter transform: A closure that takes the unwrapped value/// of the instance./// - Returns: The result of the given closure. If this instance is `nil`,/// returns `nil`.public func map&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U) rethrows -&gt; U?// 例子如下：let num: Int? = 3let result = num.map &#123; $0 * 2&#125;print(result) // Optional(6) protocol的extension的功能，为协议完成了方法的默认实现。这也，即使遵循了协议，你也可以不用写任何实现的代码。 如果类型推断是实际的类型： 如果类型中没有实现，就会调用拓展中的方法实现。 如果类型推断的是协议：1. 如果在协议中定义过，如果类型中没有实现，那就调用拓展中的实现。 2.如果在协议中没用定义过的话，拓展中的方法默认会被调用。 where字段的使用，目前已经不能再if/guard中使用where,但是在swich/foreach/for循环中，我们还是可以使用的。 对于如果需要在enum中循环需要嵌套定义的话，这里我需要用的indirect,例如这样我们就可以这样定义一个单向连边的结构了： 1234567891011121314151617indirect enum LinkedList&lt;Element: Comparable&gt; &#123; case empty case node(Element, LinkedList&lt;Element&gt;) // 删除链表中某个元素func removing(_ element: Element) -&gt; LinkedList&lt;Element&gt; &#123; guard case let .node(value, next) = self else &#123; return .empty &#125; return value == element ? next : LinkedList.node(value, next.removing(element))&#125; &#125; let linkedList = LinkedList.node(1, .node(2, .node(3, .node(4, .empty)))) let result = linkedList.removing(2) print(result) 在Object-c中，返回SEL，我们会直接调用@selector，但是在Swift中我们已经不能这样调用了，我们需要用到一个字段#selector,使用方法类似： 1234567891011121314151617181920212223 func callMe() &#123;&#125; func callMeWithParam(obj: AnyObject!) &#123;&#125; func turn(by angle: Int, speed: Int) &#123;&#125;let someMethod = #selector(callMe)let anotherMethod = #selector(callMeWithParam)let method = #selector(turn)// 如果名字相同，我们这里需要定义类型：let method11 = #selector(comonFunc as () -&gt;())let method22 = #selector(commonFunc(input:) as (Int) -&gt; Int) func comonFunc() &#123;&#125; func commonFunc(input: Int) -&gt; Int &#123; return input &#125; 实例化方法的动态调用：1.通过类获取方法，2.再传入实例得到方法，3.在根据情况传入参数 123456789101112131415class MyClass &#123; func method(number: Int) -&gt; Int &#123; return number + 1 &#125; class func method(number: Int) -&gt; Int &#123; return number &#125;&#125;let f = MyClass.methodlet object = MyClass()let result = f(object)(1)print(result) 如果存在相同名字的函数，可以显示定义类型来区分: 12345let f1 = MyClass.methodlet f2: (Int) -&gt; Int = MyClass.methodlet f3: (MyClass) -&gt; (Int) -&gt; Int = MyClass.method 单例： 1234class Manager &#123; static let shared = Manager() private init() &#123;&#125;&#125; 自定义编译符号，在Build Settings中，找到Swift Compiler - Custom Flag,并且在Other Swift Flags中加上-D FREE_VERSION 编译符号： // MARK:、// TODO:、// FIXME: app入口文件，这里默认创建app的时候，项目会自动为我们创建main的文件，在swift中，系统自动创建@UIApplicationMain,代表系统会自动将这个类标记为启动文件，但是这里我们可以通过如下的方法，可以将启动的文件指定为我们自定义的类，也可以将事件的接受者指定为我们想要的文件类： 1234567891011121314151617181920// 创建一个main.swift 的文件import UIKitclass MyApplication: UIApplication &#123; override func sendEvent(_ event: UIEvent) &#123; super.sendEvent(event) print("Event sent: \(event)") &#125;&#125;UIApplicationMain( CommandLine.argc, UnsafeMutableRawPointer(CommandLine.unsafeArgv) .bindMemory( to: UnsafeMutablePointer&lt;Int8&gt;.self, capacity: Int(CommandLine.argc)), nil, NSStringFromClass(AppDelegate.self)) 在Swift中的协议默认都是必须要实现的，但是如果用在Object-c中，协议的方法是可选的，我们可以这样实现： 123@objc protocol OptionalProtocol &#123; @objc optional func optionalMethod()&#125; 但是有了Protocol Extension，我也可以以Swift的方式来实现,对于OC中可选的协议方法，我们可以通过写protocol extension 来实现可选的功能。 Swift中的unowned和以前的unsafe_unretained: 即使它原来引用的内容已经被释放了，它仍然会保持对被释放对象的一个无效引用，它不是optional值，也不能被指向nil,如果调用属性或者方法的时候就会crash。作者建议: 如果确定在访问的时候，不会被释放的话，就使用unowned，如果存在释放的可能，那就用weak 在swift中，Int/Bool/String/Array/Dictionary都是值类型。 这些类型只是在简单的赋值的时候，在物理内存上都是同一个东西。 而当发生一个数据改变的时候，他们的内存地址才会发生变化。 值类型在赋值的时候，会将储存其中的值类型一并进行复制，而对其中的引用类型，则只是复制了一份引用。 12345678910let myObject = MyObject()let a = [myObject]var b = ab.append(myObject)myObject.number = 100print(b[0].number) //100print(b[1].number) //100 处理大量数据并且频繁操作其中的元素的时候，我们需要使用NSMutableArray、NSMutableDictionary会更好。 对于容器内条目少、容器本身数目多的情况下，我们需要使用Array、Dictionary swift版本配合range的使用： 12345678910let levels = "ABCDE"let nsRange = NSMakeRange(1, 4)print((levels as NSString).replacingCharacters(in: nsRange, with: "AAAA"))let indexPositionOne = levels.characters.index(levels.startIndex, offsetBy: 1)let swiftRange = indexPositionOne ..&lt; levels.characters.index(levels.startIndex, offsetBy: 5)print(levels.replacingCharacters(in: swiftRange, with: "AAAA"))]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Swift Tips(二)]]></title>
    <url>%2F2017%2F09%2F08%2F20170908%2F</url>
    <content type="text"><![CDATA[在介绍（Tuple）的时候，说了交换输入的方法书写，在Object-C中，有很多方法，我们传入的是指针，这个问题主要的来源就是因为受制约C语言，单一返回，有了Tuple的时候，我们就可以方便的调用了。 12let rect = CGRect(x: 0, y: 0, width: 100, height: 100)let (small, large) = rect.divided(atDistance: 20, from: .minXEdge) 在写swift的时候，我们常常需要和Optional打交道，这时候我们就需要常常用到解包，这里就提到了一个快速解包的方式??,首先看一下如何使用： 1234var level: Int?var startLevel = 1var currentLevel = level ?? startLevel 这里很简单，但是还是要说一下，这里的??判断左边的值，如果是非nil的optional的值，那就直接返回左边的value值，否则就返回右边的值,但是细细往下看一下源码的定义会发现： 12public func ??&lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T) rethrows -&gt; Tpublic func ??&lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T?) rethrows -&gt; T? 看到这里，我就有点疑惑了，这个??其实就是一个函数，那么问题来了，函数的调用方式为什么那么另类呢？,按照我们的理解，这个函数的调用方式不应该是这样的吗？??(optional, xxx),但是发现这样写，会报错，所以这里我就决定把函数的定义直接copy下来，然后自己去实现，带入如下： 123456789101112func th&lt;T&gt;(_ optional: T?, _ defaultValue: @autoclosure () throws -&gt; T) rethrows -&gt; T &#123; if let optional = optional &#123; return optional &#125; return try defaultValue()&#125;var level: Int?var startLevel = 1var test = th(level, startLevel) 看到这里我就开始猜测了，这或许是swift为了方便的我们的调用，所以它又定义了一个语法糖吧！ @autoclosure 符号的意思，就是直接将：入参T 转化为 ()-&gt;T @escaping 符号的意思就是说明，这个参数是异步的，不是属于这个局部的函数，可以在这个函数执行完成之后再执行这里的回调，不加任何参数的block默认就是同步的，函数执行完成之前，这个block就会被收回。 optional Chaining 如果某个属性是nil的话，会提前返回回来。 重载符号的做法，用的比较少： 12345678910precedencegroup DotProductPrecedence &#123; associativity: none higherThan: MultiplicationPrecedence&#125;infix operator +*: DotProductPrecedencefunc +*(left: Vector2D, right: Vector2D) -&gt; Double &#123; return left.x * right.x + left.y * right.y&#125; 外部传入的参数，如果需要在函数内部修改的话，需要在参数前面加上inout，这样传入参数的时候，就需要将之前传入的值改为地址，类似: 1234func incrementor(variable: inout Int) -&gt; Int &#123; variable += 1 return variable &#125; 字面量的作用，我就觉得很鸡肋，但是还是看一下，说白了，字面量的意思就是说：可同直接实例化的时候，传入一个String、Int、Bool, 而返回的确实我们自定义的类型，例如： 12345678910111213141516171819202122232425class Person: ExpressibleByStringLiteral &#123; let name: String init(name value: String) &#123; self.name = value &#125; required convenience init(stringLiteral value: String) &#123; self.init(name: value) &#125; required convenience init(extendedGraphemeClusterLiteral value: String) &#123; self.init(name: value) &#125; required convenience init(unicodeScalarLiteral value: String) &#123; self.init(name: value) &#125;&#125; let p: Person = "xiaoming" print(p.name) 数组下标说实话，还是蛮不错的内容，用的好的话，可以节省很多的时间，通过对下面两个方法写一下拓展，就可以实现自定义的下标功能： 123public subscript(index: Int) -&gt; Elementpublic subscript(bounds: Range&lt;Int&gt;) -&gt; ArraySlice&lt;Element&gt; onvcate 的例子中举出了下面的例子，方便我们通过下标来获取数组的数据： 12345678910111213141516171819202122232425var arr = [1,2,3,4,5,6]print(arr[[0,2,3]])arr[[0,2,3]] = [-1, -3, -4]print(arr)extension Array &#123; subscript(input: [Int]) -&gt; ArraySlice&lt;Element&gt; &#123; get&#123; var result = ArraySlice&lt;Element&gt;() for i in input &#123; assert(i &lt; self.count, "Index out of range") result.append(self[i]) &#125; return result &#125; set&#123; for(index,i) in input.enumerated() &#123; assert(i &lt; self.count, "Index out of range") self[i] = newValue[index] &#125; &#125; &#125;&#125; 下面作者也说了，这个方式调用起来不是很优雅，然后就有了下面的拓展，是我自己写的： 123456789101112131415161718192021222324252627282930313233343536373839404142extension Array &#123; subscript(first: Int, second: Int, other: Int...) -&gt; ArraySlice&lt;Element&gt; &#123; get&#123; var result = ArraySlice&lt;Element&gt;() if first &lt; self.count &#123; result.append(self[first]) &#125; if second &lt; self.count &#123; result.append(self[second]) &#125; for i in other &#123; assert(i &lt; self.count, "Index out of range") result.append(self[i]) &#125; return result &#125; set&#123; var tempDatas = other.count &gt; 0 ? other : [Int]() if (first &lt; self.count) &#123; tempDatas.append(first) &#125; if (second &lt; self.count) &#123; tempDatas.append(second) &#125; for(index,i) in tempDatas.enumerated() &#123; assert(i &lt; self.count, "Index out of range") self[i] = newValue[index] &#125; &#125; &#125;&#125;var t = [1,2,3,4,5]print( t[0,2,3,4])t[0,2,3,4] = [99,99,99,99]print(t) 函数作为一等公民，就是你可以把函数作为参数，返回值，或者可以在函数中定义任意多个函数，这样也可以控制代码的访问权限的问题。 在不同的target(一个叫GG,一个叫HH)中，调用同一个类的，同一个方法，例如我们定义了一个My的类，里面定义了一个hello的类方法: 123GG.My.hello()HH.My.hello() typealias 除了用在给变量、实例、属性定义别名外，还可以用在协议上，我认为这样的用户很大: 12345protocol Cat &#123;&#125;protocol Dog &#123;&#125;typealias Pat = Cat &amp; Dogclass ViewController: UIViewController, Pat &#123;&#125; 如果想对协议添加限定的话，我们就可以定义一个associatedtype xx,这样在遵循了协议的时候，就需要制定我们type的类型，这就和之前看官方Array定义的效果医院，需要我们制定类型，这样就能够更好的限制遵循协议的对象。 1234567891011121314protocol Animal &#123; associatedtype F func eat(_ food: F)&#125;struct Meat: Food &#123;&#125;struct Crass: Food &#123;&#125;struct Tiger: Animal &#123; typealias F = Meat func eat(_ food: Meat) &#123; print("eat \(food)") &#125;&#125; 但是一旦我们这样限制了协议之后，在进行独立判断的时候，我们就不能像之前那样直接进行判断了，例如： 1234567func isDangerous(animal: Animal) -&gt; Bool &#123; if animal is Tiger &#123; return true &#125; else &#123; return false &#125;&#125; 这里错误的原因，是因为我们没有在编译的时候，限制协议中的type类型，在这种情况下，我们只能按照泛型的类型来书写了： 12345678func isDangerous&lt;T: Animal&gt;(animal: T) -&gt; Bool &#123; if animal is Tiger &#123; return true &#125; else &#123; return false &#125;&#125; 可变参数的调用，不限制在指定哪个位置，接受可变参数的函数内部，把可变参数看作是对应数据的数组，但是每个函数只能接受一个可变参数，并且可变参数的类型必须是一致的。 方法的调用顺序问题: 123456789101112131415class Cat &#123; var name: String init() &#123; name = "cat" &#125;&#125;class Tiger: Cat &#123; let power: Int override init() &#123; power = 10 super.init() name = "gh" &#125;&#125; 类在初始化的时候，必须要保证该类的所有成员都完成了初始化。 存在继承关系的类，必须要确保当前子类实例的所有成员完成初始化后才会调用父类的初始化。 可以显示的调用super.init()，如果不显示的调用的super.init()的时候，当我们完成子类的实例化方法的时候，就会自己调用super.init(),当然如果存在复写的情况的话，还是需要显示的调用的。 Designated、Convenience、Required 使用注意点： Swift的init只能被调用一次，而且是线程安全的，可以对let属性变量进行赋值。 在init前面加了convenience的初始化方法必须调用同一个类的init的方法。 convenience的实例化方法不能被重写，并且也不能够被子类通过super的方式调用。 只要子类重写了convenience方法所需的init的方法后，子类就可以使用convenience的初始化方法。 当子类含有异于父类的初始化方法时（初始化方法参数类型和数量异于父类），子类必须要实现父类的required初始化方法，并且也要使用required修饰符而不是override。 当子类没有初始化方法时，可以不用实现父类的required初始化方法。 对于可以返回nil的初始化方法，我们需要在init?(xxx)，加入? 如果想在protocol 里定义一个类型域上的方法或者计算属性，我们需要在定义的时候用static进行定义。 在Swift中的集合类型，在定义中可以看出，我们可以将同一种类型的数据存放在集合中，但是如果类型不同呢？我们应该怎么办呢？ 123456789// Any 类型可以隐式转化let mixed: [CustomStringConvertible] = [1, "two", false]// 转化为[NSObject]let objectArray = [1 as NSObject, "two" as NSObject, false as NSObject]let any = mixed[2]let nsObject = objectArray[2] 这样存储是没啥问题的，但是也会存在一个问题，那就是可能数据会部分丢失，这其实也是不建议的，因为既然你能存放在同一个集合中，那这些元素，就应该存在一定的共同点。 1234567enum IntOrString &#123; case IntValue(Int) case StringValue(String) case BoolValue(Bool)&#125;let mixed = [IntOrString.IntValue(1), IntOrString.StringValue("two"), IntOrString.BoolValue(false)] 默认参数可以在任意的位置: 12345678910func sayHello1(str1: String = "Hello", str2: String, str3: String) &#123; print(str1 + str2 + str3)&#125;func sayHello2(str1: String, str2: String, str3: String = "World") &#123; print(str1 + str2 + str3)&#125;sayHello1(str2: " ", str3: "World")sayHello2(str1: "Hello", str2: " ") swift 中没有专门的用来正则匹配的东西，但是围绕NSRegularExpression也是可以在swift上做一下拓展: 12345678910111213141516171819202122232425262728293031struct RegexHelper &#123; let regex: NSRegularExpression init(_ pattern: String) throws &#123; try regex = NSRegularExpression(pattern: pattern, options: .caseInsensitive) &#125; func match(_ input: String) -&gt; Bool &#123; let matches = regex.matches(in: input, options: [], range: NSMakeRange(0, input.utf16.count)) return matches.count &gt; 0 &#125;&#125;let mailPattern = "^([a-z0-9\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$"let matcher: RegexHelperdo &#123; matcher = try RegexHelper(mailPattern) let maybeMailAddress = "onev@onevcat.com" if matcher.match(maybeMailAddress) &#123; print("有效的邮箱地址") &#125;&#125; catch &#123; print(error)&#125; ...(闭区间)和..&lt;(开区间)，除了可以生成一个数字类型的范围外，还是可以生成字符串和ASCII编码： 12let interval = "a"..."z"let xx = \0...~ 任意的类型有：Any/AnyObject/AnyClass, 而 typealias AnyClass = AnyObject.Type, .self用在类型后面取得类型本身，用在某实例后面表示取得实例本事 通过AnyObject.Type获取得到的是一个元类型， 也就是AnyClass,这时候我们需要调用.self来获取元类。 在协议中返回值，我们可以返回Self,这个类型的意思是，遵循这个协议的类调用这个方法可以返回一个同样遵循该协议并且相同的类： 1234567891011121314151617protocol Copyable &#123; func copy() -&gt; Self&#125;class MyClass: Copyable &#123; var num = 1 func copy() -&gt; Self &#123; let result = type(of: self).init() result.num = num return result &#125; required init() &#123; &#125;&#125; 这样书写之后，不管是MyClass还是MyClass的子类都可以同样适用该协议方法。 并且需要使用required来定义初始化方法，确保该类及其子类都能响应这个初始化方法。 swift 是不支持动态派发的，所以他不会根据继承的关系，在运行时改变方法的执行： 123456789101112131415161718192021222324class Pet &#123;&#125;class Cat: Pet &#123;&#125;class Dog: Pet &#123;&#125;func printPet(_ pet: Pet) &#123; print("Pet")&#125;func printPet(_ cat: Cat) &#123; print("Meow")&#125;func printPet(_ dog: Dog) &#123; print("Bark")&#125;func printThem(_ pet: Pet, _ cat: Cat) &#123; printPet(pet) // Pet printPet(cat) // Meow&#125;printThem(Dog(), Cat()) 虽然我这里传入的是Dog()的实例，但是在函数内部，我们定义的确实它的父类，所以在实际调用的时候，不管你传入的是什么，在编译的时候，就已经决定了，函数调用的入参是pet，如果想要区分的话，只能通过类型的判断去执行： 12345678910func printThem(_ pet: Pet, _ cat: Cat) &#123; if let aCat = pet as? Cat &#123; printPet(aCat) &#125; else if let aDog = pet as? Dog &#123; printPet(aDog) &#125; printPet(cat)&#125; 属性的监听在willSet是将date-&gt;newValue, 而didSet是从oldValue-&gt;date。 基本上在同一个类中对同一个属性值，不可能存在set/willSet/didSet, 但是如果复写父类的属性值的时候，我们就可以同时实现三个属性值： 12345678910111213141516171819202122232425262728class A &#123; var number: Int &#123; get &#123; print("get") return 1 &#125; set &#123; print("set") &#125; &#125;&#125;class B: A &#123; override var number: Int &#123; willSet &#123; print("willset") &#125; didSet &#123; print("didSet") &#125; &#125;&#125;let b = B()b.number = 0// 输出// get// willSet// set// didSet 这里首先打印get,是因为这里实现了didSet,在didSet中用到了oldValue, 而这个值需要在整个set动作之前进行获取并存储代用。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Masonry Autolayout布局实例]]></title>
    <url>%2F2017%2F09%2F07%2F20170907%2F</url>
    <content type="text"><![CDATA[最近看到很多人都在转一篇博客，博客的链接为：[http://tutuge.me/2015/05/23/autolayout-example-with-masonry/], 其实文章的知识点不是很多，重点就是讲如何运用Masonry来实现一些东西，但是不得不承认这篇文章很使用，我在平时开发的时候，很多细节的地方，我也没有注意到，然后看了一下他的四篇博客，记录一下： 第一部分重点讲的是两个属性: Content Compression Resistance、Content Hugging,这里我觉得作者的解释还是形象的： 1234567891011121314Content Compression Resistance = 不许挤我值越高，内容越不容易被压缩当内容放不下的时候，优先挤压那些优先级低的元素Content Hugging = 抱紧子元素设置的属性值越高，子元素越不会随着父视图的变化而变化//设置label1的content hugging 为1000[_label1 setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];//设置label1的content compression 为1000[_label1 setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]; 居中显示四个元素: 12345678910111213141516171819202122232425262728293031UIView __block *lastView = nil; MASConstraint __block *widthConstraint = nil; NSUInteger arrayCount = _imageViews.count; [_imageViews enumerateObjectsUsingBlock:^(UIView *view, NSUInteger idx, BOOL *stop) &#123; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; //宽高固定 widthConstraint = make.width.equalTo(@(imageViewSize.width)); make.height.equalTo(@(imageViewSize.height)); //左边约束 make.left.equalTo(lastView ? lastView.mas_right : view.superview.mas_left); //垂直中心对齐 make.centerY.equalTo(view.superview.mas_centerY); //设置最右边的imageView的右边与父view的最有对齐 if (idx == arrayCount - 1) &#123; make.right.equalTo(view.superview.mas_right); &#125; [_widthConstraints addObject:widthConstraint]; lastView = view; &#125;]; &#125;]; ... // 隐藏元素的时候，就可以直接来修改约束 if (sender.on) &#123; width.equalTo(@(IMAGE_SIZE)); &#125; else &#123; width.equalTo(@0); &#125; a视图是b视图的倍数关系的： 1make.width.equalTo(_containerView.mas_width).multipliedBy(0.5); UITableViewCell高度的问题： 首先如果是在iOS8以及以后的版本的话，那就不需要考虑这个问题了，直接使用新特性 12345678910_tableView.estimatedRowHeight = 80.0f;...- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;#ifdef IOS_8_NEW_FEATURE_SELF_SIZING // iOS 8 的Self-sizing特性 return UITableViewAutomaticDimension;&#125; 如果是在旧版本iOS7上的话: 123456789 // 根据当前数据，计算Cell的高度，注意+1dataEntity.cellHeight = [_templateCell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height + 0.5f; // 计算UILabel的preferredMaxLayoutWidth值，多行时必须设置这个值，否则系统无法决定Label的宽度 CGFloat preferredMaxWidth = [UIScreen mainScreen].bounds.size.width - 44 - 4 * 3; // 44 = avatar宽度，4 * 3为padding // Content - 多行 _contentLabel.preferredMaxLayoutWidth = preferredMaxWidth; // 多行时必须设置 为了避免在转屏的时候，Header、Bottom差一截的问题，这里我们头，尾视图不需要根据父视图来设定约束，而是根据topLayoutGuide、bottomLayoutGuide来设定: 12345678910 [_topView mas_updateConstraints:^(MASConstraintMaker *make) &#123; // 直接利用其length属性，避免iOS、SDK版本升级后topLayoutGuide不再是UIView make.top.equalTo(self.view.mas_top).with.offset(self.topLayoutGuide.length);&#125;];// 根据新的length值更新约束[_bottomView mas_updateConstraints:^(MASConstraintMaker *make) &#123; // 直接利用其length属性，避免iOS、SDK版本升级后topLayoutGuide不再是UIView make.bottom.equalTo(self.view.mas_bottom).with.offset(-(self.bottomLayoutGuide.length));&#125;]; 自定义baseline的属性值： 1234 // 返回自定义的baseline的view- (UIView *)viewForBaselineLayout &#123; return _baseView;&#125; 可拉伸的UITableView 12345678910111213141516171819 _tableView.contentInset = UIEdgeInsetsMake(ParallaxHeaderHeight, 0, 0, 0); ... - (void)initView &#123; _parallaxHeaderView = [UIImageView new]; [self.view insertSubview:_parallaxHeaderView belowSubview:_tableView]; _parallaxHeaderView.contentMode = UIViewContentModeScaleAspectFill; _parallaxHeaderView.image = [UIImage imageNamed:@"parallax_header_back"]; [_parallaxHeaderView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.and.right.equalTo(self.view); make.top.equalTo(self.mas_topLayoutGuideBottom); _parallaxHeaderHeightConstraint = make.height.equalTo(@(ParallaxHeaderHeight)); &#125;]; // Add KVO [_tableView addObserver:self forKeyPath:@"contentOffset" options:NSKeyValueObservingOptionNew context:nil];&#125; KVO的回调 1234567891011// 方法2：利用KVO- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; if ([keyPath isEqualToString:@"contentOffset"]) &#123; CGPoint contentOffset = ((NSValue *)change[NSKeyValueChangeNewKey]).CGPointValue; if (contentOffset.y &lt; -ParallaxHeaderHeight) &#123; _parallaxHeaderHeightConstraint.equalTo(@(-contentOffset.y)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Swift Tips]]></title>
    <url>%2F2017%2F09%2F01%2F20170901%2F</url>
    <content type="text"><![CDATA[onvcate的《Swift开发者必备的Tips》之前刚出的时候，我就翻阅过，后来Swift的版本一直在改，我也就懒得去看了,现在Swift的ABI基本都稳定了，我在回顾复习一下这本书，记录一下要点：协议中的read-only的属性值： 在protocol中给在方法前面添加mutating，可以修改Struct、Enum中的属性值, 在Class中本来就可以修改，所以可以直接忽视mutating。 首先我们来想一下，怎么在protocol中定义一个只读的属性值: 1234567891011121314protocol Vehicle &#123; var number: Int &#123; get &#125;&#125;struct MyCar: Vehicle &#123; var number: Int&#125;var car = MyCar(number: 3)car.numbercar.number = 10car.number 当我写完这段代码的时候，我发现，我定义的只读属性number,但是这里为什么？我还可以设置呢？我google了一下：[https://stackoverflow.com/questions/31358518/read-only-properties-of-protocols-in-swift] There’s no way to specify in a protocol that you must have a read-only property. Your protocol asks for a car.number property, and allows but does not require a setter. 这里我的理解就是，当你实例化一个car的对象，并且调用car.xxx某个属性值的时候，你并没有限制他的xxx属性值是只读的。所以我们只需要修改car的那行代码： 1234567var car: Vehicle = MyCar(number: 3)car.numbercar.number = 10 // error: 'number' is a get-only propertycar.number 那么我现在在协议中定义一个新的方法，这个方法做什么呢？就是修改协议里面的变量值，代码如下： 12345678910111213141516171819202122protocol Vehicle &#123; var number: Int &#123; get &#125; mutating func changeNumber()&#125;struct MyCar: Vehicle &#123; var number: Int mutating func changeNumber() &#123; number = 99 &#125;&#125;var car: Vehicle = MyCar(number: 12)car.numbercar.changeNumber()car.number 惊奇的发现，居然可以修改这个只读的属性值了？？我又懵逼了。查看了官方的Demo[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html] 这里的属性值我只是简单的定义了下，没有通过computed value来定义值，按照官方的demo，我们直接修改代码如下： 12345678910111213141516171819202122232425262728protocol Vehicle &#123; var number: Int &#123; get &#125; mutating func changeNumber()&#125;struct MyCar: Vehicle &#123; var customInt: Int var number: Int &#123; get &#123; return customInt &#125; &#125; mutating func changeNumber() &#123;// number = 99 &#125;&#125;var car: Vehicle = MyCar(customInt: 12)car.numbercar.changeNumber()car.number 这样一旦我调用ChangeNumber的方法的时候，你就会发现报错了。 下面说了for in的使用，大家应该都知道，for in的循环，我们都可以使用在集合类型的上面，但是在swift中我其实是可以将for in用在我们自定义的类型上面。在Apple的官方文档上也给了一个说明：[https://developer.apple.com/documentation/swift/iteratorprotocol] 首先能使用for in来枚举的对象，必须遵循Sequence,看里面的源码会发现里面除了很多的方法就只剩两个属性值的设置： 123456789/// A type that provides the sequence's iteration interface and /// encapsulates its iteration state. associatedtype Iterator : IteratorProtocol /// A type that represents a subsequence of some of the sequence's elements. associatedtype SubSequence /// Returns an iterator over the elements of this sequence. public func makeIterator() -&gt; Self.Iterator 按照官方的意思，我们这里其他不需要去实现，这里就实现了一个public func makeIterator() -&gt; Self.Iterator这个方法，可以看出这个方法返回的是一个迭代器，而这个迭代器必须要实现IteratorProtocol的协议： 12345678910111213141516171819202122232425262728293031323334public protocol IteratorProtocol &#123; /// The type of element traversed by the iterator. associatedtype Element /// Advances to the next element and returns it, or `nil` if no next element /// exists. /// /// Repeatedly calling this method returns, in order, all the elements of the /// underlying sequence. As soon as the sequence has run out of elements, all /// subsequent calls return `nil`. /// /// You must not call this method if any other copy of this iterator has been /// advanced with a call to its `next()` method. /// /// The following example shows how an iterator can be used explicitly to /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and /// then call the iterator's `next()` method until it returns `nil`. /// /// let numbers = [2, 3, 5, 7] /// var numbersIterator = numbers.makeIterator() /// /// while let num = numbersIterator.next() &#123; /// print(num) /// &#125; /// // Prints "2" /// // Prints "3" /// // Prints "5" /// // Prints "7" /// /// - Returns: The next element in the underlying sequence, if a next element /// exists; otherwise, `nil`. public mutating func next() -&gt; Self.Element?&#125; 上面的注释也说明了一些，这里其实就是一个迭代器模式，不断的调用next()的方法，知道返回nil，官方的例子上面没有用到Element,就只是将返回的类型定义为Int?,只是用了next的方法： 并且之前我们也看到了CountdownIterator的实例化方法，将自己这个结构体传入了进去,所以这里就定义了一个内部变量countdown: 1234567891011121314151617181920212223242526272829303132333435struct Coundown: Sequence &#123; let start: Int func makeIterator() -&gt; CoundownIterator &#123; return CoundownIterator(self) &#125;&#125;struct CoundownIterator: IteratorProtocol &#123; let countdown: Coundown var times = 0 init(_ countdown: Coundown) &#123; self.countdown = countdown &#125; mutating func next() -&gt; Int? &#123; let nextNumber = countdown.start - times guard nextNumber &gt; 0 else &#123; return nil &#125; times += 1 return nextNumber &#125;&#125;let threeTwoOne = Coundown(start: 3)for count in threeTwoOne &#123; print("\(count)...")&#125; 上面的例子还是通俗易懂的，但是唯一的缺点就是有些属性没用，可能他觉得没必要吧，看一下onevcate的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import UIKitstruct ReverseSequence&lt;T&gt;: Sequence &#123; var array: [T] init(array: [T]) &#123; self.array = array &#125; typealias Iterator = ReverseItrator&lt;T&gt; func makeIterator() -&gt; ReverseItrator&lt;T&gt; &#123; return ReverseItrator(array: self.array) &#125;&#125;struct ReverseItrator&lt;T&gt;: IteratorProtocol &#123; typealias Element = T var array: [Element] var currentIndex = 0 init(array: [T]) &#123; self.array = array currentIndex = array.count - 1 &#125; mutating func next() -&gt; T? &#123; if currentIndex &lt; 0 &#123; return nil &#125; else &#123; let element = self.array[currentIndex] currentIndex -= 1 return element &#125; &#125;&#125;let arr = [0,1,2,3,4]for i in ReverseSequence(array: arr) &#123; print("Index: \(i) is \(arr[i])")&#125; 其实这里会发现typealias Iterator = ReverseItrator&lt;T&gt;, typealias Element = T写了这些之后，相应协议中的返回值就是自动生成，但是如果你想代码简洁，其实可以忽略这些属性值，直接设置也是可以的。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习YYText(一)]]></title>
    <url>%2F2017%2F08%2F30%2F20170830%2F</url>
    <content type="text"><![CDATA[YY系列的很多代码都写的很棒，最近很多地方都用到富文本，所以决定用YYText,用之前看了一下里面的代码，觉得还是有很多地方要学习的。代码量非常大，所以可能要分几篇博客分别去写，简单的逻辑就不写了。 看demo里面，第一行的代码，关于的测试部分就写的很简单，但是深究下去，还是有很多值得学习的地方的： 12// 这里的self只是一个传入的ViewController的实例[YYTextExampleHelper addDebugOptionToViewController:self]; 这里传入的vc只是用来设置navigationItem的，这里是设置的一个UISwicher的UI控件，这里存在一个方法： 123[switcher addBlockForControlEvents:UIControlEventValueChanged block:^(UISwitch *sender) &#123; [self setDebug:sender.isOn]; &#125;]; 仔细一看就会发现问题，UISwich的实例变量可以直接调用addBlockForControlEvents的方法，传入了Event和block: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@implementation UIControl (YYAdd)...- (void)addBlockForControlEvents:(UIControlEvents)controlEvents block:(void (^)(id sender))block &#123; _YYUIControlBlockTarget *target = [[_YYUIControlBlockTarget alloc] initWithBlock:block events:controlEvents]; [self addTarget:target action:@selector(invoke:) forControlEvents:controlEvents]; NSMutableArray *targets = [self _yy_allUIControlBlockTargets]; [targets addObject:target];&#125;...- (NSMutableArray *)_yy_allUIControlBlockTargets &#123; NSMutableArray *targets = objc_getAssociatedObject(self, &amp;block_key); if (!targets) &#123; targets = [NSMutableArray array]; objc_setAssociatedObject(self, &amp;block_key, targets, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return targets;&#125;...@interface _YYUIControlBlockTarget : NSObject@property (nonatomic, copy) void (^block)(id sender);@property (nonatomic, assign) UIControlEvents events;- (id)initWithBlock:(void (^)(id sender))block events:(UIControlEvents)events;- (void)invoke:(id)sender;@end@implementation _YYUIControlBlockTarget- (id)initWithBlock:(void (^)(id sender))block events:(UIControlEvents)events &#123; self = [super init]; if (self) &#123; _block = [block copy]; _events = events; &#125; return self;&#125;- (void)invoke:(id)sender &#123; if (_block) _block(sender);&#125;@end...@end 这里点到源码里面可以看到，YY作者写了一个UIControl的category，来作了拓展，提供了addBlockForControlEvents这个方法，这也就解释了上面可以调用这个方法。 发现作者拿到UIControlEvents和block，直接生成了一个_YYUIControlBlockTarget实例。发现生成的这个实例，也做什么特别的事情，就是把block copy保存下来，events也保存下来。 然后它还是调用了系统的addTarget:action:forControlEvents，直接调用invoke:的方法，其实就是调用了我传入进来的block。 下面可以看到作者通过runtime给这个category生成了一个NSMutableArry的属性值，并且把我的target对象保存起来。 其实通过看源码就可以发现作者这么写这个category，就做了两件事情，第一可以用block, 第二可以方便直接remove掉相关对象上事件。 在事件成功触发的时候，就会调用下面的方法： 123456789101112131415161718192021222324252627282930+ (void)setDebug:(BOOL)debug &#123; YYTextDebugOption *debugOptions = [YYTextDebugOption new]; if (debug) &#123; debugOptions.baselineColor = [UIColor redColor]; debugOptions.CTFrameBorderColor = [UIColor redColor]; debugOptions.CTLineFillColor = [UIColor colorWithRed:0.000 green:0.463 blue:1.000 alpha:0.180]; debugOptions.CGGlyphBorderColor = [UIColor colorWithRed:1.000 green:0.524 blue:0.000 alpha:0.200]; &#125; else &#123; [debugOptions clear]; &#125; [YYTextDebugOption setSharedDebugOption:debugOptions]; DebugEnabled = debug;&#125;...@interface YYTextDebugOption : NSObject &lt;NSCopying&gt;/** Set a debug option as shared debug option. This method must be called on main thread. @discussion When call this method, the new option will set to all debug target which is added by `addDebugTarget:`. @param option A new debug option (nil is valid). */+ (void)setSharedDebugOption:(nullable YYTextDebugOption *)option;... 在这个类方法中主要涉及到的一个对象为YYTextDebugOption,这个对象只是一个继承自NSObject的对象，这里没毛病。 生成实例对象之后，我们需要设置不同的值，然后还是通过自己的类方法，将上面的生成的这个对象通过参数出入进去。 在YYTextDebugOption里面： 123456789101112131415161718192021222324252627...+ (void)setSharedDebugOption:(YYTextDebugOption *)option &#123; NSAssert([NSThread isMainThread], @"This method must be called on the main thread"); _setSharedDebugOption(option);&#125;...static void _setSharedDebugOption(YYTextDebugOption *option) &#123; _initSharedDebug(); pthread_mutex_lock(&amp;_sharedDebugLock); _sharedDebugOption = option.copy; CFSetApplyFunction(_sharedDebugTargets, _sharedDebugSetFunction, NULL); pthread_mutex_unlock(&amp;_sharedDebugLock);&#125;....static void _initSharedDebug() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; pthread_mutex_init(&amp;_sharedDebugLock, NULL); CFSetCallBacks callbacks = kCFTypeSetCallBacks; callbacks.retain = _sharedDebugSetRetain; callbacks.release = _sharedDebugSetRelease; _sharedDebugTargets = CFSetCreateMutable(CFAllocatorGetDefault(), 0, &amp;callbacks); &#125;);&#125; 这里首页确保了设置的的时候，必须是要主线程去调用，其实这里这样写，和后面通过锁来存储对象效果是一致的。 这里发现作者都是些的c函数，这里我不太确定，为什么不用oc呢？ 这里作者写了一个单例，并且初始化了pthread_mutex_init(&amp;_sharedDebugLock, NULL);锁的值 12345678910111213//1：pthread_mutex_init(pthread_mutex_t * mutex,const pthread_mutexattr_t *attr);初始化锁变量mutex。attr为锁属性，NULL值为默认属性。//2：pthread_mutex_lock(pthread_mutex_t *mutex);加锁//3：pthread_mutex_tylock(pthread_mutex_t *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。//4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁//5：pthread_mutex_destroy(pthread_mutex_t *mutex);使用完后释放...__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)int pthread_mutex_init(pthread_mutex_t * __restrict, const pthread_mutexattr_t * _Nullable __restrict);... 看代码可以发现，这里需要传入两个值，第一个值是用来表示这个锁的标记，同样第二只默认为Null 1234CFSetCallBacks callbacks = kCFTypeSetCallBacks; callbacks.retain = _sharedDebugSetRetain; callbacks.release = _sharedDebugSetRelease; _sharedDebugTargets = CFSetCreateMutable(CFAllocatorGetDefault(), 0, &amp;callbacks); 这里的几行代码，其实是通过c的方法是，来生成一个容器属性，类似NSArray,NSDictionary,NSSet,通过源码就可以发现其实就是一个结构体，结构体里面定义的属性值，就是我们需要定义这个容器变量的值，可以猜出来，release/retain是设置对象的内存管理的，equal/hash是对象存储的方式，当然啦，通过c生成的函数，我们可以转化为Foundation的属性值,可以通过类似这样的方式来生成return (NSMutableSet *)CFBridgingRelease(CFSetCreateMutable(0, 0, &amp;callbacks)); 12345678typedef struct &#123; CFIndex version; CFSetRetainCallBack retain; CFSetReleaseCallBack release; CFSetCopyDescriptionCallBack copyDescription; CFSetEqualCallBack equal; CFSetHashCallBack hash;&#125; CFSetCallBacks; 通过代码可以看出来，其实作者就是想保证，始终只有一个YYTextDebugOption *option的存在。通过获取这个option的值，就知道你的设置了。 关键设置Text的相关代码： 1234567891011121314NSMutableAttributedString *text = [NSMutableAttributedString new]; &#123; NSMutableAttributedString *one = [[NSMutableAttributedString alloc] initWithString:@"Shadow"]; one.yy_font = [UIFont boldSystemFontOfSize:30]; one.yy_color = [UIColor whiteColor]; YYTextShadow *shadow = [YYTextShadow new]; shadow.color = [UIColor colorWithWhite:0.000 alpha:0.490]; shadow.offset = CGSizeMake(0, 1); shadow.radius = 5; one.yy_textShadow = shadow; [text appendAttributedString:one]; [text appendAttributedString:[self padding]]; &#125; 这里设置yy_font、yy_color的时候，用法和我们之前设置label的属性设置一模一样，这里点进去可以发现，这里是因为作者写了一个NSMutableAttributedString的一个category，和之前的做法一样,在setter值的时候，作者覆写了setter的值方法，统一都调用了一个同一个的方法： 12345678910111213141516171819202122232425262728293031...- (void)yy_setFont:(UIFont *)font range:(NSRange)range &#123; /* In iOS7 and later, UIFont is toll-free bridged to CTFontRef, although Apple does not mention it in documentation. In iOS6, UIFont is a wrapper for CTFontRef, so CoreText can alse use UIfont, but UILabel/UITextView cannot use CTFontRef. We use UIFont for both CoreText and UIKit. */ [self yy_setAttribute:NSFontAttributeName value:font range:range];&#125;...- (void)yy_setColor:(UIColor *)color range:(NSRange)range &#123; [self yy_setAttribute:(id)kCTForegroundColorAttributeName value:(id)color.CGColor range:range]; [self yy_setAttribute:NSForegroundColorAttributeName value:color range:range];&#125;...- (void)yy_setAttribute:(NSString *)name value:(id)value range:(NSRange)range &#123; if (!name || [NSNull isEqual:name]) return; if (value &amp;&amp; ![NSNull isEqual:value]) [self addAttribute:name value:value range:range]; else [self removeAttribute:name range:range];&#125;... 这里其实已经很明显了，所有的设置属性的时候，都是调用的这个方法，如果存在这个值，就设置上去，没有，就去除掉。 这里在设置颜色的时候，连着设置了两个属性，我查了一下，但是网上都没有说的很清楚，应该是就是为了某些版本的兼容问题的吧，看一下matt大神的解释吧： [https://github.com/TTTAttributedLabel/TTTAttributedLabel/pull/416] Unfortunately, this patch appears to actually degrade support for iOS 8, as NS text attributes do not seem to apply in Core Text rendering for whatever reason. As inconvenient as they are, everything works in iOS 4 – 8 if kCT. Am I missing something? This feels like more of a “if it ain’t broke, don’t fix it” type of situation… 关键这里的shadow让人看的很懵逼，因为看代码就可以知道，作者这里自定义了一个继承了NSObject的Shadow对象YYTextShadow *shadow = [YYTextShadow new];,同样它和设置font，color一样，都是最终调用到了- (void)yy_setAttribute:(NSString *)name value:(id)value range:(NSRange)range {},前面我好理解，他都是设置的系统的设置，所以你不管设置font，color其实最终都是走到系统的设置上去了，但是这里设置的对象，key都是自定义的，这里系统是怎么认识的呢？开始看到这里的时候，我就有点不是很理解了，但是当我看到下面的时候我就明白了。 12345678910YYLabel *label = [YYLabel new]; label.attributedText = text; label.width = self.view.width; label.height = self.view.height - (kiOS7Later ? 64 : 44); label.top = (kiOS7Later ? 64 : 0); label.textAlignment = NSTextAlignmentCenter; label.textVerticalAlignment = YYTextVerticalAlignmentCenter; label.numberOfLines = 0; label.backgroundColor = [UIColor colorWithWhite:0.933 alpha:1.000]; [self.view addSubview:label]; 首先这里定义一个新的属性值，叫做YYLabel,点进去可以发现，这个YYLabel的对象继承的是UIView的,这里作者要做的应该就是写一个变化的UILabel: 12345678910111213141516/** The YYLabel class implements a read-only text view. @discussion The API and behavior is similar to UILabel, but provides more features: * It supports asynchronous layout and rendering (to avoid blocking UI thread). * It extends the CoreText attributes to support more text effects. * It allows to add UIImage, UIView and CALayer as text attachments. * It allows to add 'highlight' link to some range of text to allow user interact with. * It allows to add container path and exclusion paths to control text container's shape. * It supports vertical form layout to display CJK text. See NSAttributedString+YYText.h for more convenience methods to set the attributes. See YYTextAttribute.h and YYTextLayout.h for more information. */@interface YYLabel : UIView &lt;NSCoding&gt; 可以看到YYLabel除了UILabel提供的那些东西外，我们还提供很多牛逼的功能，这些动能的实现，我还没有看，先来看看之前我们设置的NSMutableAttributedString是如何生效的？ 在第二行代码，我们直接将我们前面设置的text属性值进行设定label.attributedText = text;: 123456789101112131415161718192021222324252627282930- (void)setAttributedText:(NSAttributedString *)attributedText &#123; if (attributedText.length &gt; 0) &#123; _innerText = attributedText.mutableCopy; switch (_lineBreakMode) &#123; case NSLineBreakByWordWrapping: case NSLineBreakByCharWrapping: case NSLineBreakByClipping: &#123; _innerText.yy_lineBreakMode = _lineBreakMode; &#125; break; case NSLineBreakByTruncatingHead: case NSLineBreakByTruncatingTail: case NSLineBreakByTruncatingMiddle: &#123; _innerText.yy_lineBreakMode = NSLineBreakByWordWrapping; &#125; break; default: break; &#125; &#125; else &#123; _innerText = [NSMutableAttributedString new]; &#125; [_textParser parseText:_innerText selectedRange:NULL]; if (!_ignoreCommonProperties) &#123; if (_displaysAsynchronously &amp;&amp; _clearContentsBeforeAsynchronouslyDisplay) &#123; [self _clearContents]; &#125; [self _updateOuterTextProperties]; [self _setLayoutNeedUpdate]; [self _endTouch]; [self invalidateIntrinsicContentSize]; &#125;&#125; 这里的代码应该就是解析我们之前设置的NSAttributedString属性。 按照代码，先判断_lineBreakMode，然后给NSAttributedString设置yy_lineBreakMode的值。 [_textParser parseText:_innerText selectedRange:NULL];这个是一个代理方法，但是我现在我这里的_textParser是nil,那也就不会调用这个代理方法，从函数名字上可以知道，这里的函数主要做的上就是去解析某个Text。 调用[self _updateOuterTextProperties]; 1234567891011121314151617181920- (void)_updateOuterTextProperties &#123; _text = [_innerText yy_plainTextForRange:NSMakeRange(0, _innerText.length)]; _font = _innerText.yy_font; if (!_font) _font = [self _defaultFont]; _textColor = _innerText.yy_color; if (!_textColor) _textColor = [UIColor blackColor]; _textAlignment = _innerText.yy_alignment; _lineBreakMode = _innerText.yy_lineBreakMode; NSShadow *shadow = _innerText.yy_shadow; _shadowColor = shadow.shadowColor;#if !TARGET_INTERFACE_BUILDER _shadowOffset = shadow.shadowOffset;#else _shadowOffset = CGPointMake(shadow.shadowOffset.width, shadow.shadowOffset.height);#endif _shadowBlurRadius = shadow.shadowBlurRadius; _attributedText = _innerText; [self _updateOuterLineBreakMode];&#125; 从上面的代码的逻辑中我们可以看出，这个函数主要做的事情就是讲我们前面传入进来的NSAttributedString一个个取出来 - (NSString *)yy_plainTextForRange:(NSRange)range {}这个函数的主要是从NSAttributedString中取出Text的值，复制给一个全局的text的值，看一下这里的实现： 123456789101112131415- (NSString *)yy_plainTextForRange:(NSRange)range &#123; if (range.location == NSNotFound ||range.length == NSNotFound) return nil; NSMutableString *result = [NSMutableString string]; if (range.length == 0) return result; NSString *string = self.string; [self enumerateAttribute:YYTextBackedStringAttributeName inRange:range options:kNilOptions usingBlock:^(id value, NSRange range, BOOL *stop) &#123; YYTextBackedString *backed = value; if (backed &amp;&amp; backed.string) &#123; [result appendString:backed.string]; &#125; else &#123; [result appendString:[string substringWithRange:range]]; &#125; &#125;]; return result;&#125; 这里他枚举了NSAttributedString的属性值，如果前面设置过YYTextBackedStringAttributeName,这里它会进行拼接，但是我们前面没有设置这个属性，所以，这个枚举出的value = nil。可以通过这里的枚举方法，我们就可以枚举出我们想要attribute值，并进行修改： 123456789101112131415161718NSMutableAttributedString *res = [self.richTextEditor.attributedText mutableCopy];[res beginEditing];__block BOOL found = NO;[res enumerateAttribute:NSFontAttributeName inRange:NSMakeRange(0, res.length) options:0 usingBlock:^(id value, NSRange range, BOOL *stop) &#123; if (value) &#123; UIFont *oldFont = (UIFont *)value; UIFont *newFont = [oldFont fontWithSize:oldFont.pointSize * 2]; [res removeAttribute:NSFontAttributeName range:range]; [res addAttribute:NSFontAttributeName value:newFont range:range]; found = YES; &#125;&#125;];if (!found) &#123; // No font was found - do something else?&#125;[res endEditing];self.richTextEditor.attributedText = res; 下面就是简单的对全局的值进行赋值,看到这里，就可以稍微明白了之前的自定义设置Shadow的问题了：NSShadow *shadow = _innerText.yy_shadow;,然后将shadow的值进行赋值： 12345678 _shadowColor = shadow.shadowColor;#if !TARGET_INTERFACE_BUILDER _shadowOffset = shadow.shadowOffset;#else _shadowOffset = CGPointMake(shadow.shadowOffset.width, shadow.shadowOffset.height);#endif _shadowBlurRadius = shadow.shadowBlurRadius; 最后又设置了一下- (void)_updateOuterLineBreakMode {}代码如下： 123456789101112131415161718- (void)_updateOuterLineBreakMode &#123; if (_innerContainer.truncationType) &#123; switch (_innerContainer.truncationType) &#123; case YYTextTruncationTypeStart: &#123; _lineBreakMode = NSLineBreakByTruncatingHead; &#125; break; case YYTextTruncationTypeEnd: &#123; _lineBreakMode = NSLineBreakByTruncatingTail; &#125; break; case YYTextTruncationTypeMiddle: &#123; _lineBreakMode = NSLineBreakByTruncatingMiddle; &#125; break; default:break; &#125; &#125; else &#123; _lineBreakMode = _innerText.yy_lineBreakMode; &#125;&#125; 这里又设计到了一下新的对象YYTextContainer *_innerContainer;,这里我目前没用到这个值，所以暂且先忽略它。 下面调用了新的方法- (void)_setLayoutNeedUpdate {},这个方法设置了一个属性值，然后调用- (void)_clearInnerLayout {}由于这里我们没有设置值，所以直接return掉了，最后调用了一下[self.layer setNeedsDisplay]; 在最后的最后调用了[self invalidateIntrinsicContentSize];,这个函数的调用我之前也没有用过，但是看解释应该可以猜出一部分： call this when something changes that affects the intrinsicContentSize. Otherwise UIKit won’t notice that it changed.我的猜测是当父视图的发生变化的时候，我们需要调用这个方法来通知子视图也发生了变化。 到目前为止外面只了解完了最最基础的那个函数调用，设置shadow，textcolor，font，足以看出这个yyText的强大了。 网上找了些资料，大部分都没有说清楚，能说清楚下面两篇文章：可以看看 : [http://www.jianshu.com/p/f0c33d6c39bb, http://blog.csdn.net/wypblog/article/details/7264315]]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Data的迁移和合并(五)]]></title>
    <url>%2F2017%2F08%2F22%2F20170822%2F</url>
    <content type="text"><![CDATA[记得在两年前我去面试的时候，面试官关于Core data的问题，他们大都只会问你一个问题，基本上你只要能够答出来，就说明还是使用过Core Data，这个问题就是：“如何迁移Core Data的数据库”？因为谁都无法预料业务的发展，以及数据库的修改，所以这个问题也是必然会发生的。这里重点列举几个Core Data数据库迁移的问题： 首先要说一下，如果你的App，只是缓存一些离线数据的话，就没必要考虑什么数据库迁移了，因为你只需要在新版本中，删除之前的core data数据，新建一个就可以了 只是在原有的Entity中添加几个字段,步骤如下： 点击Editor-&gt;Add Model Version. 命名新版本的文字就啥：xxx v2. 如果你有多个Core Data的项目，需要勾选你想要修改的Core Data项目的名字. 点击创建完成. 点击File Inspector,在Model Version中勾选你刚才创建的新的Model. 此时我们就可以勾选进我们新建的Core Data Entity的字段创建表中去，创建你想要修改的字段. 此时你就可以去想要的xxx.swift的Model Template 的文件中去添加字段了，例如：@NSManaged var image: UIImage? 此时你就可以像使用其他字段一样使用你新建的字段了，例如上面的imagexxx.image = xxx 在原有的Entity中删除字段，并且创建新的RelationShip关联到新的Entity对象： 前面的1-5的操作都是一样的. 点击Core Data来创建新建的一个Entity,并且设置相应的字段(这里设置Module 为项目的名字). 然后从我们新建的Entity中建立新的联系去关联到我们之前的Entity(通过设置destination来设置关联). 并且回到之前的Entity中，删除或者修改我们想要的修改的字段. 并且在之前的Entity中，建立联系，关联到之前新建的Entity(这里需要设置destination为新建的Entity，并且设置inverse). 此时已经可以开始准备合并了，在此之前，需要做些修改： 创建一个新的类，类名和我们新建的Entity的名字一样，并且在里面创建我们新建的字段. 修改之前Entity对应的Swift类中，增删修改字段. 下面是最最重要的一步：建立model 映射： 在New/File中选择Mapping Model,选择你修改的基准的Entity为Source, 选择最新的Entity为Targer Model，名字类似为：UnCloudNotesMappingModel_v2_to_v3 在这个新建的映射的文件中可以看出来，如果是之前就存在Entity的话，那么的它的值Value Expression= $source.xxx，可以看出来这样的数据是没有发生改变的.(这里的source就是我们开始创建这个文件的时候选择的source是同一个文件，我们可以理解为：v3里面xx字段的值，直接就是取自v2字段的同样的值). 刚下已经说了需要新建的一个Entity建立关联，那么必然在这个RelationShip中我们可以看到我们才新建好的Relationship的字段，但是在Value Expression中发现xcode并没有给我们填入什么值，这也是很好理解的，为这个值，关联的是我们新建Entity值，当然之前的Source不知道啦！！所以你现在要做的就是删除这段关联，因为既然是关联，我可以从a对象关联b对象，那我同样可以从b对象关联到a对象 勾选新建的Entity对象，发现此时的xode没有给我们勾选Source，这里的理解为：默认这个新建的Entity的值，所有的值，都是我们自己新建，不需要从之前的Entity中获取值,但是我们这里一旦勾选了source，为某个对象的话，xocde会自动去更加字符创去匹配，获取相应的值，选择了source之后，对应的名字也从xxx改为yyyToxxx. 通过之前的理解我们其实可以理解为，每一个note都会关联attachment,但是这里我也可以做一下过滤，如果attachment里的image != nil,才将数据进行关联. 之前xcode为我们创建的Relationship，由于里面的value expression是我们新建的Entity,所以我们将之前的RelationShip删除掉，然后为新建的Entity新建一个relationship关联到之前的旧Entity,并且设置Mapping Name,这里系统就会自动将value expression值填上runtime的函数 最后设置两个属性： 12description.shouldMigrateStoreAutomatically = truedescription.shouldInferMappingModelAutomatically = false 删除对象的字段，并且建立一个新的Entity,里面包含了其他新建的字段,是并且这个Entity是之前某个Entity的子类. 前面的1-5的操作都是一样的. 点击Core Data来创建新建的一个Entity,并且设置相应的字段(这里设置Module 为项目的名字). 设置新建Entity的Parent Entity,并且也可以设置相应的自定义字段. 之后新建我们新建(EntityName).swift，根据新建的字段类型，定义字段，此时可以同样表明继承关系class ImageAttachment:Attachment {} 虽然这里创建了我们想要的Entity以及字段，但是之前的旧model如何作转化呢？这里就同样需要映射，因此这里创建了一个新的Mapping Model:UnCloudNotesMappingModel_v3_to_v4. 这里我们可以更加需要，如果新建的Entity的字段直接来自于之前的某个Model的话，我就可以将这个Model设置为Source，但是如果有些字段没有，或者不是直接可以获取到的话，或者需要从不同的字段中进行一定的逻辑才能够赋值的话，那么这里就需要自定义NSEntityMigrationPolicy,这里我们新建的子类对象，并且将Model的Custom Policy设置为我们新建的子类的话，系统在载入的时候，会进行比较，假如你现在的Core Data的版本确实需要更新的话，就会执行这个类. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class AttachmentToImageAttachmentMigrationPolicyV3toV4: NSEntityMigrationPolicy &#123; override func createDestinationInstances(forSource sInstance: NSManagedObject, in mapping: NSEntityMapping, manager: NSMigrationManager) throws &#123; //1.这里会存在两个context，一个读入的source context，一个写入destinationContext.这里当然需要读入的最终的这个context let description = NSEntityDescription.entity(forEntityName: "ImageAttachment", in: manager.destinationContext) let newAttachment = ImageAttachment(entity: description!, insertInto: manager.destinationContext) //2. 将属性进行迭代 func traversePropertyMappings(block: (NSPropertyMapping, String) -&gt; ()) throws &#123; if let attributeMappings = mapping.attributeMappings &#123; for propertyMapping in attributeMappings &#123; if let destinationName = propertyMapping.name &#123; block(propertyMapping, destinationName) &#125; else &#123; //3.如果这个对象，连相应的属性值都不能反悔的话，那就代表肯定有问题的，需要抛出问题. let message = "Attribute destination not configured properly" let userInfo = [NSLocalizedFailureReasonErrorKey: message] throw NSError(domain: errorDomain, code: 0, userInfo: userInfo) &#125; &#125; &#125; else &#123; let message = "No Attribute Mappings found" let userInfo = [NSLocalizedFailureReasonErrorKey: message] throw NSError(domain: errorDomain, code: 0, userInfo: userInfo) &#125; &#125; // 4. 这一步按照映射关系，应该是一一对象进行赋值的 try traversePropertyMappings &#123; propertyMapping, destinationName in guard let valueExpression = propertyMapping.valueExpression else &#123; return &#125; let context: NSMutableDictionary = ["source": sInstance] guard let desinationValue = valueExpression.expressionValue(with: sInstance, context: context) else &#123; return &#125; newAttachment.setValue(desinationValue, forKey: destinationName) &#125; // 5. 接下来的数据，你可以进行计算，或者从其他Entity中获取值 if let image = sInstance.value(forKey: "image") as? UIImage &#123; newAttachment.setValue(image.size.width, forKey: "width") newAttachment.setValue(image.size.height, forKey: "height") &#125; // 6. let body = sInstance.value(forKeyPath: "note.body") as? NSString ?? "" newAttachment.setValue(body.substring(to: 80), forKey: "caption") // 7. 下面需要将新建的Entity与source object、mapping 之间建立联系，如果在迁移数据接受的时候，此函数调用失败的话，数据会丢失. manager.associate(sourceInstance: sInstance, withDestinationInstance: newAttachment, for: mapping) &#125;&#125; 之前所讲的都是从v1-&gt;v2,从v2-&gt;v3,从v3-&gt;v4，但是这其实是最最简单的情况，但事实情况会比较复杂，因为你永远不知道用户此时是什么版本号？他们可以从v1-&gt;v4,也可以从v2-&gt;v4，那么这样一来就会比较复杂了.此时我们这里就需要进行自定义数据合并了. 我们要做的事情，是进行比较，要先从bundle中读取文件名，然后我们从文件名中进行判断，这个bundle是数据v2、v3还是v1. 123456789101112131415161718192021extension NSManagedObjectModel &#123; private class func modelURLs( in modelFolder: String) -&gt; [URL] &#123; return Bundle.main .urls(forResourcesWithExtension: "mom", subdirectory: "\(modelFolder).momd") ?? [] &#125; class func modelVersionsFor( modelNamed modelName: String) -&gt; [NSManagedObjectModel] &#123; return modelURLs(in: modelName) .flatMap(NSManagedObjectModel.init) &#125; class func uncloudNotesModel( named modelName: String) -&gt; NSManagedObjectModel &#123; let model = modelURLs(in: "UnCloudNotesDataModel") .filter &#123; $0.lastPathComponent == "\(modelName).mom" &#125; .first .flatMap(NSManagedObjectModel.init) return model ?? NSManagedObjectModel() &#125;&#125; 版本号之前的判断： 1234567891011121314151617181920212223242526272829class var version1: NSManagedObjectModel &#123; return uncloudNotesModel(named: "UnCloudNotesDataModel") &#125; var isVersion1: Bool &#123; return self == type(of: self).version1 &#125; class var version2: NSManagedObjectModel &#123; return uncloudNotesModel(named: "UnCloudNotesDataModel v2") &#125; var isVersion2: Bool &#123; return self == type(of: self).version2 &#125; class var version3: NSManagedObjectModel &#123; return uncloudNotesModel(named: "UnCloudNotesDataModel v3") &#125; var isVersion3: Bool &#123; return self == type(of: self).version3 &#125; class var version4: NSManagedObjectModel &#123; return uncloudNotesModel(named: "UnCloudNotesDataModel v4") &#125; var isVersion4: Bool &#123; return self == type(of: self).version4 &#125; 啥时候进行数据迁移呢？ 123456789101112131415161718192021222324252627282930var stack: CoreDataStack &#123; guard enableMigrations, !store(at: storeURL, isCompatibleWithModel: currentModel) else &#123; return CoreDataStack(modelName: modelName) &#125; performMigration() return CoreDataStack(modelName: modelName)&#125;// 通过获取元数据，并且进行比较，如果需要更新的话，就会将数据返回 private func store(at storeURL: URL, isCompatibleWithModel model: NSManagedObjectModel) -&gt; Bool &#123; let storeMetadata = metadataForStoreAtURL(storeURL: storeURL) return model.isConfiguration(withName: nil, compatibleWithStoreMetadata:storeMetadata) &#125; private func metadataForStoreAtURL(storeURL: URL) -&gt; [String: Any] &#123; let metadata: [String: Any] do &#123; metadata = try NSPersistentStoreCoordinator .metadataForPersistentStore(ofType: NSSQLiteStoreType, at: storeURL, options: nil) &#125; catch &#123; metadata = [:] print("Error retrieving metadata for store at URL:\(storeURL): \(error)") &#125; return metadata &#125; 数据如何进行合并呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private func migrateStoreAt(URL storeURL: URL, fromModel from:NSManagedObjectModel, toModel to:NSManagedObjectModel, mappingModel:NSMappingModel? = nil) &#123; // 1.创建migration manager的实例对象 let migrationManager = NSMigrationManager(sourceModel: from, destinationModel: to) // 2.如果在方法中传递mapping model的对象的话，我们可以使用它，否则我们就创建它. var migrationMappingModel: NSMappingModel if let mappingModel = mappingModel &#123; migrationMappingModel = mappingModel &#125; else &#123; migrationMappingModel = try! NSMappingModel .inferredMappingModel( forSourceModel: from, destinationModel: to) &#125; // 3 let targetURL = storeURL.deletingLastPathComponent() let destinationName = storeURL.lastPathComponent + "~1" let destinationURL = targetURL .appendingPathComponent(destinationName) print("From Model: \(from.entityVersionHashesByName)") print("To Model: \(to.entityVersionHashesByName)") print("Migrating store \(storeURL) to \(destinationURL)") print("Mapping model: \(String(describing: mappingModel))") // 4 let success: Bool do &#123; try migrationManager.migrateStore(from: storeURL, sourceType:NSSQLiteStoreType, options:nil, with:migrationMappingModel, toDestinationURL:destinationURL, destinationType:NSSQLiteStoreType, destinationOptions:nil) success = true &#125; catch &#123; success = false print("Migration failed: \(error)") &#125; // 5 if success &#123; print("Migration Completed Successfully") let fileManager = FileManager.default do &#123; try fileManager.removeItem(at: storeURL) try fileManager.moveItem(at: destinationURL, to: storeURL) &#125; catch &#123; print("Error migrating \(error)") &#125; &#125; &#125; 如何一步步的合并数据，这里调用了一个递归函数，从而时间一步步的合并数据： 1234567891011121314151617181920212223242526272829303132333435363738func performMigration() &#123; if !currentModel.isVersion4 &#123; fatalError("Can only handle migrations to version 4!") &#125; if let storeModel = self.storeModel &#123; if storeModel.isVersion1 &#123; let destinationModel = NSManagedObjectModel.version2 migrateStoreAt(URL: storeURL, fromModel: storeModel, toModel: destinationModel) performMigration() &#125; else if storeModel.isVersion2 &#123; let destinationModel = NSManagedObjectModel.version3 let mappingModel = NSMappingModel(from: nil, forSourceModel: storeModel, destinationModel: destinationModel) migrateStoreAt(URL: storeURL, fromModel: storeModel, toModel: destinationModel, mappingModel: mappingModel) performMigration() &#125; else if storeModel.isVersion3 &#123; let destinationModel = NSManagedObjectModel.version4 let mappingModel = NSMappingModel(from: nil, forSourceModel: storeModel, destinationModel: destinationModel) migrateStoreAt(URL: storeURL, fromModel: storeModel, toModel: destinationModel, mappingModel: mappingModel) &#125; &#125; &#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Core Data, Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习NSFetchedResultsController, 获取数据部分(五)]]></title>
    <url>%2F2017%2F08%2F21%2F20170821%2F</url>
    <content type="text"><![CDATA[上一周一直在忙着写项目，书虽然看完了，但是还是想写写笔记，加深一下记忆，在第四章的时候，其实通过NSFetchReques一些值的修改，其实我们已经可以开始正常的使用core data, 并且可以按照我们的意愿来过滤数据，并且进行排序。这一章重点讲的是NSFetchedResultsController。 什么是NSFetchedResultsController? 干什么用的？ 其实操作Core Data,我们做的最多的操作其实就是，从Core Data中获取数据，然后放入到Array中，然后设置DataSource，然后刷新TableView, Apple就是为了解决这种麻烦，所以才产生了NSFetchedResultsController，但是NSFetchedResultsController不同于其他的ViewController,因为它是没有界面的，他主要的目的是为了异步获取的数据用的。说白了，NSFetchedResultsController其实就是NSFetchRequest Result数据的封装。从继承关系上也可以看出来： 123open class NSFetchedResultsController&lt;ResultType&gt; : NSObject where ResultType : NSFetchRequestResult &#123;&#125;class ViewController: UIViewController &#123;&#125; 和NSFetchRequest很用法很类似的： 123456789101112131415161718// 1let fetchRequest: NSFetchRequest&lt;Team&gt; = Team.fetchRequest()let sort = NSSortDescriptor(key: #keyPath(Team.teamName), ascending: true)fetchRequest.sortDescriptors = [sort]// 2fetchedResultsController = NSFetchedResultsController( fetchRequest: fetchRequest, managedObjectContext: coreDataStack.managedContext, sectionNameKeyPath: nil, cacheName: nil)// 3do &#123; try fetchedResultsController.performFetch()&#125; catch let error as NSError &#123; print("Fetching error: \(error), \(error.userInfo)")&#125; NSFetchedResultsController主要是为了协调Core Data和TableView,但是仍然需要传递NSFetchRequest, 记住NSFetchRequest是可以高度自定义的，可以传递descriptiors/ predicate 实例化NSFetchedResultsController需要四个参数，第二个参数就是NSManagedObjectContext，需要这个managedContext来进行搜索 ,剩下的sectionNameKeyPath,cacheName NSFetchedResultsController里面必须至少要有一个sort descriptor否则会直接crash 如何获取数据12345678910111213func numberOfSections(in tableView: UITableView) -&gt; Int &#123; guard let sections = fetchedResultsController.sections else &#123;return 0 &#125; return sections.count&#125;func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int)-&gt; Int &#123; guard let sectionInfo = fetchedResultsController.sections?[section] else &#123;return 0 &#125; return sectionInfo.numberOfObjects&#125; 通过调用sections的属性，返回的数组中，包含的Object中，都遵循了NSFetchedResultsSectionInfo的协议，这个轻量级的协议，能够调用title/number 如果获取相应的对象呢？ 1let team = fetchedResultsController.object(at: indexPath) 如何更改数据123let team = fetchedResultsController.object(at: indexPath) team.wins = team.wins + 1 coreDataStack.saveContext() 如何将数据分组 可以根据我们之前创建的Entity对象中的字段，任意进行分组，例如我们的Entity中存在一个名为qualifyingZone的String的字段,来进行分组，只需要如下的修改： 12345fetchedResultsController = NSFetchedResultsController( fetchRequest: fetchRequest, managedObjectContext: coreDataStack.managedContext, sectionNameKeyPath: #keyPath(Team.qualifyingZone), cacheName: nil) 这里我们只是传入了一个#keyPath(),根据之前的知识，这个字段的意思会在编译的时候，去寻找Team下面的qualifyingZone。 这个字段又是如何分组的呢？首先它是先讲这些最为Key的字段放在一个Section中（数组中），然后在回更加每个不同的字段去生成不同的数据。 通过#keyPath,可以深入到Core Data中的relationship来查询属性值 虽然当时sectionNameKeyPath但是发现，数据的排序还是更加首字母的？这是因为我没有设置NSSortDescriptor，修改代码如下： 1234567let zoneSort = NSSortDescriptor( key: #keyPath(Team.qualifyingZone), ascending: true)let scoreSort = NSSortDescriptor( key: #keyPath(Team.wins), ascending: false)let nameSort = NSSortDescriptor( key: #keyPath(Team.teamName), ascending: true)fetchRequest.sortDescriptors = [zoneSort, scoreSort, nameSort] 根据数组的排序，先根据Team.qualifyingZone排序，然后根据Team.wins排序，最后根据Team.teamName来排序。 缓存数据12345fetchedResultsController = NSFetchedResultsController( fetchRequest: fetchRequest, managedObjectContext: coreDataStack.managedContext, sectionNameKeyPath: #keyPath(Team.qualifyingZone), cacheName: "worldCup") 数据分类是很耗性能，避免每次都去分类数据，可以通过缓存，如何通过缓存呢？ 直接添加一个字符串的key，这样就可以将数据缓存到磁盘中去了。 监听数据变化 NSFetchedResultsController可以监听数据集的变化，并且通知他的代理，通过实现代理方法，可以做响应的操作。 这里代理的触发还是需要通过设置NSManagedObjectContext,如果在项目中存在多个Managed Object Context的话，那么代理的方法是不会触发的，除非我们保存数据，并且合并context 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// MARK: - NSFetchedResultsControllerDelegateextension ViewController: NSFetchedResultsControllerDelegate &#123; func controllerWillChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) &#123; tableView.beginUpdates() &#125; func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) &#123; switch type &#123; case .insert: tableView.insertRows(at: [newIndexPath!], with: .automatic) case .delete: tableView.deleteRows(at: [indexPath!], with: .automatic) case .update: let cell = tableView.cellForRow(at: indexPath!) as! TeamCell configure(cell: cell, for: indexPath!) case .move: tableView.deleteRows(at: [indexPath!], with: .automatic) tableView.insertRows(at: [newIndexPath!], with: .automatic) &#125; &#125; func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange sectionInfo: NSFetchedResultsSectionInfo, atSectionIndex sectionIndex: Int, for type: NSFetchedResultsChangeType) &#123; let indexSet = IndexSet(integer: sectionIndex) switch type &#123; case .insert: tableView.insertSections(indexSet, with: .automatic) case .delete: tableView.deleteSections(indexSet, with: .automatic) default: break &#125; &#125; func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) &#123; tableView.endUpdates() &#125;&#125; 添加Entity123456let team = Team( context: self.coreDataStack.managedContext) team.teamName = nameTextField.text team.qualifyingZone = zoneTextField.text team.imageName = "wenderland-flag" self.coreDataStack.saveContext()]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Core Data, Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习CoreData, 获取数据部分(四)]]></title>
    <url>%2F2017%2F08%2F10%2F20170810%2F</url>
    <content type="text"><![CDATA[前面三章都是一些很基础的操作以及概念，之前我们取数据，用的最多的也就是使用NSFetchRequest中的NSPredicate,我们通过修改相应的NSPredicate值来获取到我们想要的数据。所有这一章主要讲解的是获取数据的相关操作以及技巧。 之前用到的操作是：创建一个NSFetchRequest的实例，然后通过NSManagedObjectContext这个对象来直接修改NSFetchRequest就可以实现了。 仅仅获取NSFetchRequest的方法就有5种: 12345678910111213141516171819202122232425262728293031// 1:通过最普通的NSFetchRequest&lt;Venue&gt;()的方法来实例化NSFetchRequest的对象，紧接着必须使用NSEntityDescription来获取相应的Entity对象，然后直接通过set entity的值。let fetchRequest1 = NSFetchRequest&lt;Venue&gt;()let entity = NSEntityDescription.entity(forEntityName: "Venue", in: managedContext)!fetchRequest1.entity = entity// 2:这里直接通过NSFetchRequest的实例化方法传入entityName值，直接将上面的步骤省略了，避免使用NSEntityDescription的对象。let fetchRequest2 = NSFetchRequest&lt;Venue&gt;(entityName: "Venue")// 3: 这个又在第二部的上面做出了相应的省略，当你生成NSManagedObject subclass 的对象，同时你这个对象也会生成一个类方法，直接返回NSFetchRequest，通过这样能够直接与相应的Entity产生联系。let fetchRequest3: NSFetchRequest&lt;Venue&gt; = Venue.fetchRequest()// 4: 在三章里分析managedObjectModel就说过，这里可以直接通过managedObjectModel来获取NSFetchRequest。这里在xCode回有个可视化的操作，就是可以添加Request的操作。let fetchRequest4 = managedObjectModel.fetchRequestTemplate(forName: "venueFR")// 5: 这里第五个方法其实与第四个很相近的，都是通过managedObjectModel来获取NSFetchRequest，不同的是这里多穿了一个substitutionVariables，这个值是用在predicate中的，从而进一步来获取你想要的值。let fetchRequest5 = managedObjectModel.fetchRequestFromTemplate( withName: "venueFR", substitutionVariables: ["NAME" : "Vivi Bubble Tea"]) 其实NSFetchRequest是一个很普通的类，但是如果你仔细研究一下NSFetchRequest的实例化，你就会发现&lt;ResultType : NSFetchRequestResult&gt;这个参数，这个参数的作用就是准备具体说明了你想要获取数据的格式:例如之前你获取的是[Venue]而不是[AnyObject]。 点击xxx.xcdatamodeld,并且长按Add Entity,选择Add Fetch Request，这样就创建了一个NSFetchRequest的对象。但是通过这样创建的NSFetchRequest的对象是无法修改的。这里需要注意一下，并且通过修改这里Fetch all选择相应的model，当然这里也可以通过添加另外的predicate的值，来对我们需要的数据进行操作。 那么如何来获取我们之前在模板中创建的NSFetchRequest对象呢？这里我们用到是通过managedObjectModel来获取相应的Request: 12345678guard let model = coreDataStack.managedContext .persistentStoreCoordinator?.managedObjectModel, let fetchRequest = model .fetchRequestTemplate(forName: "FetchRequest") as? NSFetchRequest&lt;Venue&gt; else &#123;return&#125; NSFetchRequest有一个resultType的属性值，之前我们使用的都是它的默认值NSManagedObjectResultType,其实它是一个枚举值，一共可以获取四中不同的类型： 1234.managedObjectResultType: 返回的响应的数据(默认的值).countResultType: 返回的匹配数据的个数.dictionaryResultType: 以字典的形式来返回相应的数据，包括count，匹配的数据。.managedObjectIDResultType: 返回匹配数据的唯一标示符 这里创建Predicate的方式之前我们也已经看到了,这里的#keyPath, 这个在编译的时候，编译器就会一级级的找相应的属性值，是否存在写错的情况： 1234lazy var cheapVenuePredicate: NSPredicate = &#123; return NSPredicate(format: "%K == %@", #keyPath(Venue.priceInfo.priceCategory), "$")&#125;() 获取count： 12345678910111213141516171819202122232425262728 func populateCheapVenueCountLabel() &#123; let fetchRequest = NSFetchRequest&lt;NSNumber&gt;(entityName: "Venue") fetchRequest.resultType = .countResultType fetchRequest.predicate = cheapVenuePredicate do &#123; let countResult = try coreDataStack.managedContext.fetch(fetchRequest) let count = countResult.first!.intValue firstPriceCategoryLabel.text = "\(count) bubble tea places" &#125; catch let error as NSError &#123; print("Count not fetch \(error), \(error.userInfo)") &#125; ----------------- let fetchRequest: NSFetchRequest&lt;Venue&gt; = Venue.fetchRequest() fetchRequest.predicate = expensiveVenuePredicate do &#123; let count = try coreDataStack.managedContext.count(for: fetchRequest) thirdPriceCategoryLabel.text = "\(count) bubble tea places" &#125; catch let error as NSError &#123; print("Count not fetch \(error), \(error.userInfo)") &#125;&#125; 上面所有的操作都是需要把所有的相关数据载入到内存中去，然后再去计算个数，core data 能够快速找到数据的“总和、平均值、最大、最小”： 1234567891011121314151617181920212223242526272829303132333435363738func populateDealsCountLabel() &#123;// 1 let fetchRequest = NSFetchRequest&lt;NSDictionary&gt;(entityName: "Venue") fetchRequest.resultType = .dictionaryResultType // 2: 这边你为了获取总和生成了一个NSExpressionDescription的对象，并且set了一个name的值，便于自己能够从字典中找到自己想要的那个值： let sumExpressionDesc = NSExpressionDescription() sumExpressionDesc.name = "sumDeals"// 3: 首先你生成了一个NSExpression的变量来确定你需要哪个字段来计算总和，其次生成了一个NSExpression来变量来确定你要运行的函数，最后定义了返回数据的类型是int32位： let specialCountExp = NSExpression(forKeyPath: #keyPath(Venue.specialCount)) sumExpressionDesc.expression = NSExpression(forFunction: "sum:", arguments: [specialCountExp]) sumExpressionDesc.expressionResultType = .integer32AttributeType// 4：将自己设置的东西都告诉给FetchRequest fetchRequest.propertiesToFetch = [sumExpressionDesc]// 5:根据上面的定义，我们需要调用的是sum函数，将我们Venue.specialCount所有的字段都加起来，丢在一个字典中，字典的key为sumDeals: do &#123; let results = try coreDataStack.managedContext.fetch(fetchRequest) let resultDict = results.first! let numDeals = resultDict["sumDeals"]! numDealsLabel.text = "\(numDeals) total deals" &#125; catch let error as NSError &#123; print("Count not fetch \(error), \(error.userInfo)") &#125;&#125; 这里除了支持sum，还有其他函数支持吗？count,min,max,median,mode,absolute 这里我们运用的都是些一个单独的NSPredicate，来进行过滤数据，但是我们其实还可以运用多个Predicate来实现类似AND,OR,NOT，可以通过NSCompoundPredicate将两个单独NSPredicate组合成一个。 排序 另一个很牛逼的地方，就是可以对获取的数据进行排序，这里运用的函数是NSSortDescriptor,其实这个函数在我们版本号比较的时候就可以运用，但是Core Data中的排序，它是发生在SQLite层面的，而不是内存层面的。 1234567891011121314151617lazy var nameSortDescriptor: NSSortDescriptor = &#123; let compareSelector = #selector(NSString.localizedStandardCompare(_:)) return NSSortDescriptor(key: #keyPath(Venue.name),&#125;()ascending: true,selector: compareSelector)lazy var distanceSortDescriptor: NSSortDescriptor = &#123; return NSSortDescriptor( key: #keyPath(Venue.location.distance), ascending: true)&#125;()lazy var priceSortDescriptor: NSSortDescriptor = &#123; return NSSortDescriptor( key: #keyPath(Venue.priceInfo.priceCategory), ascending: true)&#125;() 上面需要解释一下的是Venue.name 的排序，需要三个字段：1:属性的字段名。2：升序还是降序，3: 执行比较的函数。这里需要重点说一下，我之前比较的都是用的compare的函数，但是apple这里建议使用的是NSString.localizedStandardCompare，因为这个函数对一些特殊的字符也做了相应的操作。 异步操作： 现在我们所有获取数据的操作其实都是在主线程操作的，所以在我们操作大量数据的时候，就会生卡顿，在iOS8的时候，CoreData可以在后台长期高效的运行。 1var asyncFetchRequest: NSAsynchronousFetchRequest&lt;Venue&gt;! 1234567891011121314151617181920212223override func viewDidLoad() &#123; super.viewDidLoad()// 1 fetchRequest = Venue.fetchRequest()// 2 asyncFetchRequest = NSAsynchronousFetchRequest&lt;Venue&gt;( fetchRequest: fetchRequest) &#123; [unowned self] (result: NSAsynchronousFetchResult) in guard let venues = result.finalResult else &#123;return&#125; self.venues = venues self.tableView.reloadData() &#125;// 3 do &#123; try coreDataStack.managedContext.execute(asyncFetchRequest) // Returns immediately, cancel here if you want &#125; catch let error as NSError &#123; print("Could not fetch \(error), \(error.userInfo)") &#125;&#125; 这里可以看到NSAsyncchronousFetchRequest并没有取代NSFetchRequest,这里可以把异步操作是普通操作的一个封装。 并且这里NSManagedObjectContext执行的是execute(_:)而不是fetch(_:) 当然这里你可以可以通过调用cancel()来取消查询。 批量操作，无需获取数据。 在iOS8的时候，提供了一个新的接口可以批量操作，并且也不需要将数据载入到内存中去NSBatchUpdateRequest， 123456789101112131415161718192021222324// 1. 通过传入EntityName 实例化了一个NSBatchUpdateRequest对象let batchUpdate = NSBatchUpdateRequest(entityName: "Venue")// 2. 设置了需要修改的字段，以及值batchUpdate.propertiesToUpdate = [#keyPath(Venue.favorite) : true]// 3. 这个批量操作需要影响哪些数据batchUpdate.affectedStores = coreDataStack.managedContext .persistentStoreCoordinator?.persistentStores// 4. 设置了返回结果的类型，我们这里定义为返回批量更新的count值batchUpdate.resultType = .updatedObjectsCountResultTypedo &#123; let batchResult = try coreDataStack.managedContext.execute(batchUpdate) as! NSBatchUpdateResult print("Records updated \(batchResult.result!)")&#125; catch let error as NSError &#123; print("Could not update \(error), \(error.userInfo)")&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Core Data, Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习CoreData(三)]]></title>
    <url>%2F2017%2F08%2F09%2F20170809%2F</url>
    <content type="text"><![CDATA[这一章主要介绍的了四个组成的类 1`NSManagedObjectModel`,`NSPersistentStore`,`NSPersistentStoreCoordinator`,`NSManagedObjectContext` NSManagedObjectModel: 它就相当于数据库的一个表，我的理解就是代表我们创建的一个Entity,里面包含很多我们创建的字段值，当然也包含与其他Entity之前的关系（relationship）。具体NSManagedObjectModel是如何与我们创建的data model产生联系的呢？答案就是：runtime,通过runtime的机制，能够在编译期高效的将我们所创建model data，也就是将xcdatamodel文件的内容编译进momd文件夹中，再将momd文件夹中的内容实例化NSManagedObjectModel NSPersistentStore: 他就是负责读写数据，这里还提到了私有NSPersistentStore类型，三种是原子性的，一种是非原子性的（所谓的原子性和定义属性值用的原子性不是同一个概念，这里指的原子性：在你做读写的时候，需要将所有的相关数据都载入到内存中去，而非原子性可以根据数据的需求而载入）,四种Type依次为:NSQLiteStoreType,NSXMLStoreType,NSBinaryStoreType,NSInMemoryStoreType。 NSPersistentStoreCoordinator: 是NSManagedObjectModel和NSPersistentStore的桥接，我的理解是，它就是NSManagedObjectModel和NSPersistentStore上层的实现，core data 主要也是通过它来实现功能，NSPersistentStoreCoordinator隐藏了它内部的实现，因为NSManagedObjectContext并不知道你要存储的是sqlite xml还是其他的格式，如果你有多个持久化存储，而对NSManagedObjectContext也是统一的接口。 NSManagedObjectContext，是managed object的暂存器，它也是最最上层的封装，所有的操作都可以通过它来完成，如果不调用save()的方法的话，所有的NSManagedObjectContext变化均不会生效的。NSManagedObjectContext管理着所有期间创建、获取对象的生命周期，也报错错误信息，以及model的关系，每个managedobjec都必须持有对NSManagedObjectContext的引用，一旦持有了NSManagedObjectContext,在managedobjec的整个生命周期中都会持有，也一个application中，也可以存在多个NSManagedObjectContext，并且NSManagedObjectContext也不是线程安全的。 iOS10 出现了一个新的类NSPersistentContainer，你只需要实例化NSPersistentContainer就可以获得上面所提到的四个重要的类了。 通过懒加载的方式，直接生成NSPersistentContainer: 12345678910111213141516private lazy var storeContainer: NSPersistentContainer = &#123; let container = NSPersistentContainer(name: self.modelName) container.loadPersistentStores &#123; (storeDescription, error) in if let error = error as NSError? &#123; print("Unresolved error \(error), \(error.userInfo)") &#125; &#125; return container&#125;() 那么自然获取NSManagedObjectContext就可以直接通过NSPersistentContainer来获取了： 虽然这里的NSManagedObjectContext可以直接获取，但是managed model,store coordinator 以及persistent store就需要通过NSPersistentStoreDescription 123lazy var managedContext: NSManagedObjectContext = &#123; return self.storeContainer.viewContext&#125;() 这里在保存数据之前可以先进行判断数据是够发生变化，这边变化的东西，NSManagedObjectContext是肯定知道的： 12345678func saveContext () &#123; guard managedContext.hasChanges else &#123; return &#125; do &#123; try managedContext.save() &#125; catch let error as NSError &#123; print("Unresolved error \(error), \(error.userInfo)") &#125;&#125; 创建完Entity之后，可以为这个Entity来创建关系，点击关系，可以关联其他的Entity,并且也可以编辑RelationShip的Data ModelInspector: To Many（一对多），并且也可以设置Ordered顺序,这里一旦生成对多有序的对象，那对象就是NSOrderedSet类型。 可以看到实例化model，对象很简单，只需要传入context就可以了： 1let walk = Walk(context: managedContext) 也可以直接通过NSManagedObjectContext直接删除某个对象： 12//2 managedContext.delete(walkToRemove)]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Core Data, Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习CoreData, 子类化NSManagerObject(二)]]></title>
    <url>%2F2017%2F08%2F08%2F20170808%2F</url>
    <content type="text"><![CDATA[打开xxx.xcdatamodeld文件,添加Entity,例如这里名叫“Person”的类,并且通过类似第一部分的操作就可以编辑了Attributes了。 这里在给Attribute添加字段的时候需要注意的: 字段类型有Boolean 布尔类型, Date 时间戳, Double 浮点类型,String 字符串类型, Integer Integer 32 Integer 64 整型。 如果Entity中有关联的image或者PDF(任何可以被序列化为0或者任何的东西)类型的话，都可以将它定义为Binary Data 二进制类型, 但是这也会带来一个问题：“如果二进制文件太大,当你每次需要获取这个Entity的时候，就会消耗巨大的内存，从而影响性能”，这里你可以通过勾选Allows External Storage,这样“Core Data会根据你存入数据的大小，来决定是直接存储这个值还是仅仅只是存储一个URI的值，这个值指向的是一个单独的文件数据”,并且如果打开了这个属性值，你将无法通过查询的方式来获取这个值。 这里的UIColor,NSArray,NSDictionary任何只要遵循了NSCoding协议的都可以定义为: Transformable。 之前不管是取值还是赋值都是通过KVC的方式来实现的，例如： 1234// Set the nameperson.setValue(aName, forKey: "name")// Get the namelet name = person.value(forKey: "name") 我们勾选Codegen值为：Manual/None,然后点击Editor\Create NSManagedObject Subclass....，这样Xcode就可以为我们创建了两个文件。如果修改了响应的Entity的文件的属性，可以重新点击Editor\Create NSManagedObject Subclass.... 生成的文件中，属性值前面都写着@NSManaged,这个字段的意思是告诉Swift编译器，这个属性的存储和实现都是在运行时产生的，而不是在编译的时候产生。因为这些属性的存储是需要managed object context,而这个东西在编译的时候，还没有生成。 测试插入的一个新的数据： 123456789101112131415161718 // Save test bow tie let bowtie = NSEntityDescription.insertNewObject( forEntityName: "Bowtie", into: self.persistentContainer.viewContext) as! Bowtie bowtie.name = "My bow tie" bowtie.lastWorn = NSDate() // Retrieve test bow tie do &#123; let request = NSFetchRequest&lt;Bowtie&gt;(entityName: "Bowtie") let ties = try self.persistentContainer.viewContext.fetch(request) let sample = ties.first print("Name :\(sample?.name), Worn: \(sample?.lastWorn)") &#125; catch let error as NSError &#123; print("Fetching error: \(error), \(error.userInfo)") &#125;return true&#125; image和UIColor的存取 12345678... let colorDict = btDict["tintColor"] as! [String: AnyObject] bowtie.tintColor = UIColor.color(dict: colorDict) let image = UIImage(named: imageName!) let photoData = UIImagePNGRepresentation(image!)! bowtie.photoData = NSData(data: photoData)... 如何根据条件查询？运用NSPredicate: 123456789101112//2 let request = NSFetchRequest&lt;Bowtie&gt;(entityName: "Bowtie") let firstTitle = segmentedControl.titleForSegment(at: 0)! request.predicate = NSPredicate( format: "searchKey == %@", firstTitle)do &#123; //3 let results = try managedContext.fetch(request)//4 populate(bowtie: results.first!) &#125; catch let error as NSError &#123; print("Could not fetch \(error), \(error.userInfo)") &#125; CoreData 如何对字段值进行验证？ 勾选需要验证字段，打开data model inspector,然后勾选Validation，可以勾选默认值,最大值,最小值，这样就可以在catch中捕获住Error： 12345 if error.domain == NSCocoaErrorDomain &amp;&amp; (error.code == NSValidationNumberTooLargeError || error.code == NSValidationNumberTooSmallError) &#123; rate(currentBowtie)&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Core Data, Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习CoreData(一)]]></title>
    <url>%2F2017%2F08%2F07%2F20170807%2F</url>
    <content type="text"><![CDATA[最近在看Core Data这本书，很多人都说这个东西多难用，但是很多细节如果不进去细细看的话，也会存在很多懵逼的地方。不得不承认，这个东西还是挺牛逼的。 如何存入相应的Entity对象? 在回答这个问题之前要先知道，我们是通过什么对象来存入数据的呢？ 答案是：NSManagedObjectContext 那什么是NSManagedObjectContext? 书上的给的解释我认为很贴切：You can consider a managed object context as an in-memory “scratchpad” for working with managed objects，我的理解是：它其实就相当于内存中的暂存器,那么完成插入数据就分为两步：1. 将数据插入到NSManagedObjectContext，2. 然后将managed object context的变化保存到磁盘中 那现在怎么获取这个所谓的暂存器NSManagedObjectContext? 如果你的项目创建是通过xcode，勾选创建Use Core Data的话，就可以直接通过下面的代码来获取： 12let managedContext = appDelegate.persistentContainer.viewContext 如何通过NSManagedObjectContext来获取Entity？ 我们通过模板来创建的Entity对象，在CoreData中就好比Class,这些Entity都是继承NSManagedObject类或者为其子类，那这个问题就转化为如何取得我们之前早起定义的Entity，也就是NSManagedObject对象呢？ 123let entity = NSEntityDescription.entity(forEntityName: "Person", in: managedContext)! 这里是通过NSEntityDescription对象一个类方法entity,传入相应的Entity字符串，但是这里返回并不是我们之前预料的NSManagedObject,而是NSEntityDescription自己。 这里是因为NSEntityDescription= 数据模型实体定义 与 NSManagedObject 的链接部分 拿到了Entity,如何来设置值呢？ 因为NSManagedObject是用OC来写的，可以通过KVC的方式来设置，这里一定要注定字符串的书写正确，否则就会发生crash 之前说了最后还需要commit,那如何commit的？ 直接调用managedContext.save(),这里可能会提交不成功，那就需要catch住相应的错误。 赋值的代码：123456789101112131415161718192021222324func save(name: String) &#123; guard let appDelegate = UIApplication.shared.delegate as? AppDelegate else &#123; return &#125; //1. let managedContext = appDelegate.persistentContainer.viewContext //2. let entity = NSEntityDescription.entity(forEntityName: "Person", in: managedContext)! let person = NSManagedObject(entity: entity, insertInto: managedContext) //3. person.setValue(name, forKeyPath: "name") //4. do &#123; try managedContext.save() people.append(person) &#125; catch let error as NSError &#123; print("Could not save. \(error), \(error.userInfo)") &#125; &#125; 取值的代码：12345678910111213141516//1 guard let appDelegate = UIApplication.shared.delegate as? AppDelegate else &#123;return&#125; let managedContext = appDelegate.persistentContainer.viewContext//2 let fetchRequest = NSFetchRequest&lt;NSManagedObject&gt;(entityName: "Person")//3 do &#123; people = try managedContext.fetch(fetchRequest) &#125; catch let error as NSError &#123; print("Could not fetch. \(error), \(error.userInfo)") &#125; 其他都和赋值的操作是一样的，那第二部是什么意思呢？ 就如这个NSFetchRequest类名字一样，NSFetchRequest他就是赋值从Core Data中获取数据的东西，这里我们通过传入EntityName来准确告诉context我们需要获取的是什么对象。这里是获取所有符合条件的对象。 最后调用fetch会直接返回所有数据，同样这里也可能会失败，记住catch住错误。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Core Data, Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 0.46 最新环境配置]]></title>
    <url>%2F2017%2F07%2F31%2F20170731%2F</url>
    <content type="text"><![CDATA[隔了好久，闲来无事，看到自己github上React-Native的项目好久没有更新了，所以想继续搞搞它，但是发现好多坑。 打开官网 https://facebook.github.io/react-native/，我所用的都是最新的版本0.46, 点击链接到https://facebook.github.io/react-native/docs/getting-started.html,点击Build Projects with Native Code，会有一个Demo，按照这个Demo一步步操作，会遇到很多的坑，这里我记录一下： 1.先运行Android的机器，发现会报未找到SDK的问题，具体如下： 12345FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring project ':app'.&gt; SDK location not found. Define location with sdk.dir in the local.properties file or with an ANDROID_HOME environment variable. 解决：以mac为例子，找到~/.bashrc的文件，也有可能是~/.zshrc的文件 123451. vim ~/.bashrc2. export ANDROID_HOME=~/Library/Android/sdk export PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools 2.再次运行react-native run-android 想执行真机的话, 报这如下错误： 1Could not run adb reverse: Command failed: /Users/gonghuan/Library/Android/sdk/platform-tools/adb -s K21GAMN590201150 reverse tcp:8081 tcp:8081 这里假如你的系统是Android 5.0以上的话，应该就不会有这个问题了，但是如果你的安卓机器和我的一样，都是低于Android 5.0的话：, 以我的手机为例[安卓4.4.4]，解决： 1234567891. (Android 5.0以下)通过Wi-Fi连接你的本地开发服务器首先确保你的电脑和手机设备在同一个Wi-Fi环境下。2. 在设备上运行你的React Native应用。和打开其它App一样操作。你应该会看到一个“红屏”错误提示。这是正常的，下面的步骤会解决这个报错。3. 摇晃设备，或者运行adb shell input keyevent 82，可以打开开发者菜单。4. 点击进入Dev Settings。5. 点击Debug server host for device。6. 输入你电脑的IP地址和端口号（譬如10.0.1.1:8081）。在Mac上，你可以在系统设置/网络里找查询你的IP地址。在Windows上，打开命令提示符并输入ipconfig来查询你的IP地址。在Linux上你可以在终端中输入ifconfig来查询你的IP地址。7. 回到开发者菜单然后选择Reload JS。` 3.运行react-native run-android的时候，启动模拟器，我这边报这个错误： 1Error: No available formula with the name "android-sdk" 解决途径：1. 如果你已经按照官网 [https://facebook.github.io/react-native/docs/getting-started.html] 的教程，走完，但是还是报错的话就执行下面的命令： 1234567brew tap caskroom/caskbrew cask install android-sdkbrew cask install android-platform-tools]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习设计模式-迭代器模式]]></title>
    <url>%2F2017%2F07%2F13%2F20170713%2F</url>
    <content type="text"><![CDATA[代码写多了，就想把代码写好，将代码写好，就必然要学习设计模式，今天重点学习一下迭代器模式和组合模式。这里我参照的学习是以JAVA为参照的《Header First》设计模式，我这里会以Object-c的格式来重写，最后以一个我项目中的实例来说明一下。1.1 迭代器设计模式： 问题：这里有两个类：一个是煎饼餐厅菜类PancakeHouseMenu(这里假设代码中是以数组的形式来存储),一个是普通餐厅类DinerMenu(这里假设是以字典的形式来存储),他们都有自己原有的代码，以及逻辑，现在如何将这两个菜单类合并成一个类更好给用户调用。 这个是PancakeHouseMenu的代码 123456789101112131415161718192021222324252627282930313233343536373839#import "PancakeHouseMenu.h"#import "Pancak.h"@interface PancakeHouseMenu ()@property (nonatomic, strong) NSMutableArray *items;@end@implementation PancakeHouseMenu- (instancetype)init &#123; if (self = [super init]) &#123; [self addItem:@"cake_A" isVege:YES price:0.23]; [self addItem:@"cake_B" isVege:NO price:0.53]; [self addItem:@"cake_C" isVege:YES price:1.2]; &#125; return self;&#125;- (void)addItem:(NSString *)itemName isVege:(BOOL)isVege price:(CGFloat)price &#123; Pancak *cake = [Pancak pancakName:itemName isVege:isVege price:price]; if (cake != nil) [self.items addObject:cake];&#125;- (NSArray &lt;Pancak *&gt;*) menuItems; &#123; return [self.items copy];&#125;#pragma mark - Getter Methods- (NSMutableArray *)items &#123; if (_items == nil) _items = [NSMutableArray new]; return _items;&#125;@end 这个是DinerMenu的代码 123456789101112131415161718192021222324252627282930313233343536373839404142#import "DinerMenu.h"#import "Diner.h"@interface DinerMenu ()@property (nonatomic, strong) NSMutableDictionary *items;@property (nonatomic, assign) NSInteger numberOfItems;@end@implementation DinerMenu- (instancetype)init &#123; if (self = [super init]) &#123; self.numberOfItems = 0; [self addItem:@"Diner_A" isVege:YES price:2.32]; [self addItem:@"Diner_B" isVege:NO price:5.33]; [self addItem:@"Diner_C" isVege:YES price:1.27]; &#125; return self;&#125;- (NSDictionary *) menuItems &#123; return [self.items copy];&#125;- (void)addItem:(NSString *)itemName isVege:(BOOL)isVege price:(CGFloat)price &#123; Diner *diner = [Diner DinerName:itemName isVege:isVege price:price]; if (diner != nil &amp;&amp; itemName != nil) &#123; [self.items setObject:diner forKey:@(self.numberOfItems)]; self.numberOfItems ++; &#125;&#125;- (NSMutableDictionary *)items &#123; if (_items == nil) _items = [NSMutableDictionary new]; return _items;&#125;@end 通过比较就可以看出这两个的区别。存储数据分别用的是NSMutableArray和NSMutableDictionary 如果此时我需要分别打印响应的数据的时候的，就需要这样： 123456789101112131415161718192021- (void)printMenu &#123; self.pancakeMenu = [PancakeHouseMenu new]; NSArray *pancakeItems = self.pancakeMenu.menuItems; self.dinerMenu = [DinerMenu new]; NSDictionary *dinerItems = self.dinerMenu.menuItems; for (int i = 0 ; i &lt; pancakeItems.count ; i++) &#123; Pancak *pancake = pancakeItems[i]; NSLog(@"%@", pancake); &#125; NSLog(@"--------------------"); for (int i = 0 ; i &lt; dinerItems.count; i ++ ) &#123; Diner *diner = dinerItems[@(i)]; NSLog(@"%@", diner); &#125; &#125; 结果如下： 12345672017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] pancake:[name:cake_A--isvege:1--price:0.23]2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] pancake:[name:cake_B--isvege:0--price:0.53]2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] pancake:[name:cake_C--isvege:1--price:1.20]2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] --------------------2017-07-12 16:54:00.993 Learn_Iterator_Composite_Pattern[6245:186657] diner:[name:Diner_A--isvege:1--price:2.32]2017-07-12 16:54:00.993 Learn_Iterator_Composite_Pattern[6245:186657] diner:[name:Diner_B--isvege:0--price:5.33]2017-07-12 16:54:00.993 Learn_Iterator_Composite_Pattern[6245:186657] diner:[name:Diner_C--isvege:1--price:1.27] 这样第一个问题就出现了，这里两家餐厅的菜单存储的数据结构没法控制，这里需要打印菜单的时候，就需要分别遍历两个数据 解决版本：封装变化的部分（这里变化的部分就是循环遍历的地方） 这里创建一个protocol,代码如下： 1234567891011121314151617@protocol Iterator &lt;NSObject&gt;/** 是否这个聚合中存在更多的元素 @return 返回bool值 */- (BOOL)hasNext;/** 返回下一个对象 @return 下一个对象 */- (id)next;@end 创建一个新的类DinerMenuIterator,这个类是Iterator具体实现的类，具体实现： 12345678910111213141516171819202122232425262728293031323334#import "DinerMenuIterator.h"@interface DinerMenuIterator ()@property (nonatomic, strong) NSDictionary *items;@property (nonatomic, assign) NSInteger position;@end@implementation DinerMenuIterator- (instancetype)initWithItems:(NSDictionary *)items &#123; if (self = [super init]) &#123; self.position = 0; self.items = items; &#125; return self;&#125;- (BOOL)hasNext &#123; if (self.position &gt;= self.items.count) return NO; return YES;&#125;- (id)next &#123; if ([self hasNext]) &#123; id item = self.items[@(self.position)]; self.position ++; return item; &#125; return nil;&#125;@end 修改DinerMenu的类： 12345678910111213/** 返回菜单项 @return 菜单总数据 *///- (NSDictionary *) menuItems;/** 迭代器的接口 @return 迭代器对象 */- (id&lt;Iterator&gt;)iterator; .m 文件的具体实现： 1234567- (id&lt;Iterator&gt;)iterator &#123; return [[DinerMenuIterator alloc] initWithItems:[self.items copy]];&#125;//- (NSDictionary *) menuItems &#123;// return [self.items copy];//&#125; 这样打印代码如下： 12345678910111213141516171819202122- (void)printMenu &#123; self.pancakeMenu = [PancakeHouseMenu new]; id &lt;Iterator&gt;pancakIterator = [self.pancakeMenu iterator]; self.dinerMenu = [DinerMenu new]; id &lt;Iterator&gt;dinerIterator = [self.dinerMenu iterator]; [self iterate_print_menu:pancakIterator]; NSLog(@"--------------------"); [self iterate_print_menu:dinerIterator]; &#125;- (void)iterate_print_menu:(id&lt;Iterator&gt;)it &#123; while (it.hasNext) &#123; NSLog(@"%@", it.next); &#125;&#125; 这样就解决了游走于每一个元素内部之间，而不需要暴露内部的实现。 迭代器模式：提供一种方法顺序访问聚合对象中各个元素，而又不暴露其内部的实现。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习《iOS Animations》]]></title>
    <url>%2F2017%2F07%2F04%2F20170704%2F</url>
    <content type="text"><![CDATA[最近一直在学习《iOS Animations》这本书，记录一下学习到知识点： 这本都快看完了，一直觉得没啥可做笔记的，以为UI动画的一些用法，你知道就是知道，不知道就是不知道，知道了 就觉得很容易，所以觉得这是一个熟能生巧的技能，但是想想，这本书都快看完了，还是要留下一些什么，所以觉得记些东西。 Animating Constraints 如何在动画中修改约束 最简单的就是获取NSLayoutConstraint!的属性值，直接修改对象的constant可以直接实现约束值的改变。官方的api解释如下： Unlike the other properties, the constant may be modified after constraint creation. Setting the constant on an existing constraint performs much better than removing the constraint and adding a new one that’s just like the old but for having a new constant. 12@IBOutlet weak var menuHeightConstraint: NSLayoutConstraint!menuHeightConstraint.constant = isMenuOpen ? 200.0 : 60.0 1.1 添加动画 运用类似这些apianimate(withDuration:animations:)就可以实现动画。 可以在animations的closure里面添加动画的代码，也可以在外面修改完响应的约束代码，然后直接在closure中调用self.view.layoutIfNeeded() 123UIView.animate(withDuration: 1.0, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 10.0, options: .curveEaseIn, animations: &#123; self.view.layoutIfNeeded() &#125;, completion: nil) 1.2 遍历修改约束1234567titleLabel.superview?.constraints.forEach &#123; constraint in if constraint.firstItem === titleLabel &amp;&amp; constraint.firstAttribute == .centerX &#123; constraint.constant = isMenuOpen ? -100.0 : 0.0 return &#125;&#125; 这里的作用就是遍历titleLabel的父视图的约束. 表达式firstItem.firstAttribute = secondItem.secondAttribute + constant 删除某个约束，是通过 isActive的属性来设置的，isActive的属性为false的时候，就代表去除约束, 当设置isActive的属性值为false,视图的层级会删除约束，并且如果没有对象引用它，它就会从内存中去除掉。 1.3 添加新的约束 1.在刚才枚举中，可以通过循环，并且创建一个新的约束，并且替换掉： 12345678910let newConstraint = NSLayoutConstraint( item: titleLabel, attribute: .centerY, relatedBy: .equal, toItem: titleLabel.superview!, attribute: .centerY, multiplier: isMenuOpen ? 0.67 : 1.0, constant: 5.0)newConstraint.identifier = "TitleCenterY"newConstraint.isActive = true 通过设置identifier的属性值，来找到视图层级的元素，通过设置isActive来告诉Autolayout将其应用到当前的布局中去。 如果是手动编写autolayout的代码，创建完新的约束后，需要通过addConstraint,将新的约束添加到视图上去。 但是系统更偏向于使用NSLayoutConstraint.activate(_:)的类方法,接受一个 constraint的数组，性能更优，官方api的解释如下: Convenience method that activates each constraint in the contained array, in the same manner as setting active=YES. This is often more efficient than activating each constraint individually. 2. 12345let conX = imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor)let conBottom = imageView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: imageView.frame.height)let conWidth = imageView.widthAnchor.constraint(equalTo: view.widthAnchor, multiplier: 0.33, constant: -50)let conHeight = imageView.heightAnchor.constraint(equalTo: imageView.widthAnchor)NSLayoutConstraint.activate([conX, conBottom, conWidth, conHeight])]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习算法]]></title>
    <url>%2F2017%2F06%2F20%2F20170620%2F</url>
    <content type="text"><![CDATA[前两天闲来无事有重新温习了一下算法，用Swift3重写了一下算法：今天先写一下O(n^2)的两种算法：选择排序、插入排序，以及算法复杂度为O(nlogn)的：递归排序 项目我已经丢到github上了，可以自己去下载： [https://github.com/Ghstart/play_with_algorithm] 1.1 准备工作 首先写算法，我需要有准备为我产生测试用例的方法，因此我定义了了一个类Helper,并且写静态方法： 12345678static func generateSources(count: Int) -&gt; [Int] &#123; var sources: [Int] = [Int]() for _ in 1...count &#123; let randomNum: UInt32 = arc4random_uniform(1_000_000) sources.append(Int(randomNum)) &#125; return sources &#125; 学习算法必不可少的，就是需要去验证我的算法，是否正确，这里我写了一个静态方法去验证我的算法是否排序正确： 12345678910111213141516static func isSorted(testSources: [Int]) -&gt; Bool &#123; if testSources.count &lt; 3 &#123; assert(true, "你逗我呢？？就几个自己数") return false &#125; for i in 0...testSources.count - 2 &#123; if testSources[i] &gt; testSources[i + 1] &#123; return false &#125; &#125; return true &#125; 写算法，我必须要去计算每个算法所执行的时间，通过Unit Test的measure可以来看出每个方法执行的时间，这里我也写了一个静态方法： 12345678static func executeTime(whichFunctionName: String, testSources: [Int], operation: ([Int]) -&gt; ([Int])) &#123; let methodStart = Date() let tt = operation(testSources) let methodFinished = Date() let executionTime = methodFinished.timeIntervalSince(methodStart) print(String(format:"执行%@花费%.9fs", whichFunctionName, executionTime)) assert(Helper.isSorted(testSources: tt), "排序后还是存在问题！！") &#125; 1.2 开始coding 选择排序，其实说白了，就找索引, 从当前位置一直往后找，并且判断，如果小，就找出他的索引，再继续往后找，直到到最后一位, 这里注意，它是不能提前结束的，所以这就是为什么说他会比插入排序慢了： 123456789101112131415161718192021222324252627/** * 选择排序 */ func selectionSort(sources: [Int]) -&gt; [Int] &#123; var sources = sources for i in 0..&lt;sources.count &#123; var minIndex = i for j in i+1..&lt;sources.count &#123; if sources[j] &lt; sources[minIndex] &#123; minIndex = j &#125; &#125; if minIndex != i &#123; swap(&amp;sources[minIndex], &amp;sources[i]) &#125; &#125; return sources &#125; 插入排序，是从第二个位置开始往前找，判断前面的是否比他大，比他大的话，就将前面的数字往后挪，因此类推： 12345678910111213141516171819202122232425/** * 插入排序 */ func insertionSort(sources: [Int]) -&gt; [Int] &#123; var sources = sources for i in 1..&lt;sources.count &#123; let e = sources[i] var j = i - 1 while ( j &gt;= 0 &amp;&amp; sources[j] &gt; e) &#123; sources[j + 1] = sources[j] j = j - 1 &#125; sources[j+1] = e &#125; return sources &#125; 递归排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 归并排序 */ func mergeSort(sources: [Int]) -&gt; [Int] &#123; var sources = sources __mergeSort(sources: &amp;sources, l: 0, r: sources.count - 1) return sources &#125; func __mergeSort( sources: inout [Int], l: Int, r: Int) &#123; if l &gt;= r &#123; return &#125; let mid: Int = (l + r) / 2 __mergeSort(sources: &amp;sources, l: l, r: mid) __mergeSort(sources: &amp;sources, l: mid+1, r: r) __merge(sources: &amp;sources, l: l, mid: mid, r: r) &#125; // [l...mid] [mid+1...r] func __merge(sources: inout [Int], l: Int, mid: Int, r: Int) &#123; var aux = [Int]() for i in l...r &#123; aux.insert(sources[i], at: i-l) &#125; var i: Int = l var j: Int = mid + 1 for k in l...r &#123; if i &gt; mid &#123; sources[k] = aux[j-l] j = j + 1 &#125; else if j &gt; r &#123; sources[k] = aux[i-l] i = i + 1 &#125; else if aux[i-l] &lt; aux[j-l] &#123; sources[k] = aux[i-l] i = i + 1 &#125; else &#123; sources[k] = aux[j-l] j = j + 1 &#125; &#125; &#125; 1.3 测试： 如何调用： 12345678910override func viewDidLoad() &#123; super.viewDidLoad() let arr = Helper.generateSources(count: 1_000) let arr1 = arr Helper.executeTime(whichFunctionName: "插入排序", testSources: arr, operation: insertionSort) Helper.executeTime(whichFunctionName: "选择排序", testSources: arr1, operation: selectionSort) &#125; 控制台的打印： 12执行插入排序花费0.016882956s执行选择排序花费0.023320019s]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Android开发基础笔记Tips]]></title>
    <url>%2F2017%2F05%2F31%2F20170531%2F</url>
    <content type="text"><![CDATA[学习Android, 最近正好有时间，可以系统的看看Android的系统开发，记录下学习的笔记，供今后参考。1.1 基础环境： 使用的IDE为：Android Studio. SDK 最低的版本为：Android 4.1. LinearLayout是布局组件，可以从继承关系上看出关系, 继承自View的子类ViewGroup，并且FrameLayout,TableLayout,RelativeLayout他们都是继承自ViewGroup 1234// 继承关系public class LinearLayout extends ViewGrouppublic abstract class ViewGroup extends View implements ViewParent, ViewManager 1.2 UI属性:123match_parent: 视图与其父视图大小相同wrap_content: 视图将根据展示的内容自动调整大小android:orientation: LinearLayout 具有的属性，决定子组件是“水平”还是“垂直”排列 字符串，对某个组件setString的时候，你会发现是这样写的：@string/xxxx, 这里需要注意一下：android:text属性值不是字符串值，而是对字符串资源的应用，其实这时候你setString的时候，实际上是去app/res/values的文件夹中查找strings.xml。 1&lt;string name="xxxx"&gt;YYYYYY&lt;/string&gt; 随意创建一个文件，系统会默认给我们创建一些代码： 这里的R.java文件是在代码编译的时候创建的: 1234567public class QuizActivity extends AppCompatActivity &#123; @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_quiz);&#125; AppCompatActivity是Activity的子类 activity创建完后，需要获取自己的界面： 123public void setContentView(@LayoutRes int layoutResID) &#123;&#125; 这里的layoutResID就是要在资源中来寻找相应的资源。资源文件需要从app/res目录下寻找，和TextView中获取字符串的方法是一样的，需要去app/res/values中的strings.xml中去寻找： 123public final void setText(@StringRes int resid) &#123;&#125; 1.3 按钮的点击：1234567mNextButton = (Button) findViewById(R.id.next_button); mNextButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); 1.4 Toast的提示信息：1Toast.makeText(CurrentActivity.this, R.string.xxx, Toast.LENGTH_SHORT).show(); 1.5 生命周期 不存在 -&gt;(onCreate)-&gt; 停止（不可见）-&gt;(onStart)-&gt;暂停（可见）-&gt; (onResume) 运行（可见 &amp; 在前台） 运行（可见 &amp; 在前台）-&gt;(onPause)-&gt; 暂停（可见 -&gt;(onStop)-&gt; 停止（不可见 -&gt;(onDestory)-&gt; 不存在 在创建了Activity之后，并且此实例出现在屏幕之前会调用onCreate的方法 转屏幕的时候，生命周期的改变： 当屏幕发生转动的时候，Activity的生命周期会从新再走一遍，也就是 上面的会先按照 2 -&gt; 1,每次转屏都会这样。 想要在转屏的时候，保存数据，可以调用下面onSaveInstanceState的方法来保存数据，下次在需要的时候，可以获取数据： 1234567891011121314@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putInt(KEY_INDEX, mCurrentIndex);&#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (savedInstanceState != null) &#123; mCurrentIndex = savedInstanceState.getInt(KEY_INDEX); &#125; &#125; 但是转屏并且保存数据的生命周期方法的调用顺序为： onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestory()]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习爬虫Scrapy[官网教程]]]></title>
    <url>%2F2017%2F05%2F25%2F20170525%2F</url>
    <content type="text"><![CDATA[1.学习爬虫框架 Scrapy 前几天一直在正Django的框架，现在基本上已经ok了，如果我们需要自己创建属于自己的网站、需要前台展示数据，后台可以编辑数据，可以插入到数据库，可以建立自己的数据类型，使用Django已经够了，那么现在有一个很重要的难题：数据从哪里来？怎么获取？如何存取？-&gt; Scrapy能够很好满足我们这些需求。 目前文档是线上最新的版本:Scrapy 1.3[https://docs.scrapy.org/en/latest/] 1.1 什么是Scrapy scrapy是一个web端抓取网站数据的框架，可以用来数据挖掘，信息处理等等 1.2 安装Scrapy 安装scrapy官网建议两种途径： 1.使用conda:12conda install -c conda-forge scrapy 2.使用pip: 12pip install Scrapy 官方建议，我们在安装Scrapy的时候，最好安装自己创建的虚拟环境中a dedicated virtualenv，这样至少不会与系统的包产生冲突。 virtualenv的安装网址为：[http://sourabhbajaj.com/mac-setup/Python/virtualenv.html] 12345678910//1.cd myproject///2.virtualenv venv // 如果你的系统已经安装了python2已经python3，但是你现在想建立一个python3的环境// virtualenv -p python3 envname//3.source venv/bin/activate//4.pip install Scrapy 执行完上面的4行命令，此时应该就可以安装好了Scrapy了。 执行一下pip list，看一下安装scrapy系统默认给我们安装了什么： 1234567891011121314151617181920212223242526272829303132333435(venv) ➜ venv pip listPackage Version---------------- -------appdirs 1.4.3asn1crypto 0.22.0attrs 17.1.0Automat 0.6.0cffi 1.10.0constantly 15.1.0cryptography 1.8.1cssselect 1.0.1enum34 1.1.6idna 2.5incremental 16.10.1ipaddress 1.0.18lxml 3.7.3packaging 16.8parsel 1.2.0pip 9.0.1pyasn1 0.2.3pyasn1-modules 0.0.8pycparser 2.17PyDispatcher 2.0.5pyOpenSSL 17.0.0pyparsing 2.2.0queuelib 1.4.2Scrapy 1.3.3service-identity 16.0.0setuptools 35.0.2six 1.10.0Twisted 17.1.0w3lib 1.17.0wheel 0.29.0zope.interface 4.4.1 lxml[http://lxml.de/], 高效的xml和html的解析框架，最低版本为3.4 parsel[https://pypi.python.org/pypi/parsel] ,在lxml的封装，解析html/xml的数据 w3lib[https://pypi.python.org/pypi/w3lib], 处理页面的url以及encodings twisted[https://twistedmatrix.com/trac/], 异步的网络请求框架。最低版本为：14.0 cryptography和pyOpenSSL(最低版本为0.14) 多重网络安全 1.3 开始抓取数据： 现在我们开始爬取页面，这里就爬取一下这个页面：http://quotes.toscrape.com/，这个网站列举了很多著名的导演，这个抓取的目的有下面几个： 创建一个新的Scrapy对象. 写一个spider对象抓取网站，并且解析数据 用命令行导出抓取的数据 改变规则，递归的抓取数据 运用spider的参数 1.3.1 新建scrapy项目12345678910//1.scrapy startproject tutorial//2.New Scrapy project 'tutorial', using template directory '/Users/gonghuan/Desktop/myproject/venv/lib/python2.7/site-packages/scrapy/templates/project', created in: /Users/gonghuan/Desktop/myproject/venv/tutorialYou can start your first spider with: cd tutorial scrapy genspider example example.com 1.3.2 创建我们第一个spider1234567891011121314151617181920import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): page = response.url.split("/")[-2] filename = 'quotes-%s.html' % page with open(filename, 'wb') as f: f.write(response.body) self.log('Saved file %s' % filename) spider是Scrapy用来抓取数据的类 必须要继承scrapy.Spider，并且要初始化请求，抓取规则，解析数据的规则等等 name被赋值为quotes,这是作为项目的唯一标示符，必须唯一的。 start_requests的方法，必须要返回一个可以递归的request请求。 parse的方法，用来处理下载下来的response，response的参数保存在TextResponse的实例中。 parse的作用：1: 解析response,并将爬去下来的dics解析成我们需要的数据，2: 并且找到新的url数据，并且创建新的request 最后执行scrapy crawl quotes,这个命令quotes就是我们刚才定义的name,然后他们将会向quotes.toscrape.com这个域名发起请求,终端也会出现下面的返回： 1234567891011... (omitted for brevity)2016-12-16 21:24:05 [scrapy.core.engine] INFO: Spider opened2016-12-16 21:24:05 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)2016-12-16 21:24:05 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:60232016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (404) &lt;GET http://quotes.toscrape.com/robots.txt&gt; (referer: None)2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://quotes.toscrape.com/page/1/&gt; (referer: None)2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://quotes.toscrape.com/page/2/&gt; (referer: None)2016-12-16 21:24:05 [quotes] DEBUG: Saved file quotes-1.html2016-12-16 21:24:05 [quotes] DEBUG: Saved file quotes-2.html2016-12-16 21:24:05 [scrapy.core.engine] INFO: Closing spider (finished)... 此时检查项目的文件夹，会出现quotes-1.html、quotes-2.html这样的两个文件，就代表已经成功抓取下来了。 刚才在start_requests的函数中，我们返回了scrapy.Request的对象，当这些请求一旦接受到服务器返回的response的时候，就会立刻调用callback的方法，也就是parse的方法，这个方法会包含刚才我们的请求的url以及相应的参数。 1.3.3 简写代码 其实我们发现start_requests其实就是通过对于的url生成相应的scrapy.Request的对象，但其实我们可以不用实现start_requests的方法，我们可以直接定义一个start_urls的列表，里面的元素就是相应的请求url,一旦你定义了这个对象，start_requests会默认从start_urls来获取url 即使在你的代码中没有指定的callback函数，parse的函数也会默认来处理每个url发起的请求，主要也是因为parse是系统默认的方法（当你没有准确的指定callback） 修改为如下的代码： 123456789101112131415import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] def parse(self, response): page = response.url.split("/")[-2] filename = 'quotes-%s.html' % page with open(filename, 'wb') as f: f.write(response.body) 1.3.4 解析数据 官方的建议，最好的解析是在shell [https://docs.scrapy.org/en/latest/topics/shell.html#topics-shell] 的操作下，在我们刚才创建的虚拟环境下执行如下的脚本scrapy shell &quot;http://quotes.toscrape.com/page/1/&quot; 看到如下的终端返回： 123456789101112131415[ ... Scrapy log here ... ]2016-09-19 12:09:27 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://quotes.toscrape.com/page/1/&gt; (referer: None)[s] Available Scrapy objects:[s] scrapy scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s] crawler &lt;scrapy.crawler.Crawler object at 0x7fa91d888c90&gt;[s] item &#123;&#125;[s] request &lt;GET http://quotes.toscrape.com/page/1/&gt;[s] response &lt;200 http://quotes.toscrape.com/page/1/&gt;[s] settings &lt;scrapy.settings.Settings object at 0x7fa91d888c10&gt;[s] spider &lt;DefaultSpider 'default' at 0x7fa91c8af990&gt;[s] Useful shortcuts:[s] shelp() Shell help (print this help)[s] fetch(req_or_url) Fetch request (or URL) and update local objects[s] view(response) View response in a browser&gt;&gt;&gt; 我们如何获取response里面的元素呢？可以通过css [https://www.w3.org/TR/selectors/] 执行response.css(&#39;title&#39;),就可以在终端看到如下的返回： 1[&lt;Selector xpath='descendant-or-self::title' data='&lt;title&gt;Quotes to Scrape&lt;/title&gt;'&gt;] 执行response.css(&#39;title&#39;)返回的是一个类似列表的一个东西，这个东西叫做SelectorList,这个列表里面就是搜索的对象，这些对象是Selector,这些Selector就是包装这些XML/HTML的外壳。你可以直接通过Selector直接获得里面的值： 12&gt;&gt;&gt; response.css('title').extract()['&lt;title&gt;Quotes to Scrape&lt;/title&gt;'] 你会发现还是一个列表，不是我们想要的值，这时我们就需要对css进行过滤，添加::text，就表示我们想要的只是&lt;title&gt;标签中对应的值 12&gt;&gt;&gt; response.css('title::text').extract()['Quotes to Scrape'] 返回的还是一个列表，但是你确定你需要的是第一个元素的话，可以这样直接使用extract_first取得列表中的元素,这样为了避免产生IndexError： 12&gt;&gt;&gt; response.css('title::text').extract_first()'Quotes to Scrape' 除了使用extract()以及extract_first(),还是可以使用re()，就是通过正则来筛选解析的数据 123456&gt;&gt;&gt; response.css('title::text').re(r'Quotes.*')['Quotes to Scrape']&gt;&gt;&gt; response.css('title::text').re(r'Q\w+')['Quotes']&gt;&gt;&gt; response.css('title::text').re(r'(\w+) to (\w+)')['Quotes', 'Scrape'] 1.3.4 除了使用CSS，你也可以使用XPath来查找元素 例如： 1234&gt;&gt;&gt; response.xpath('//title')[&lt;Selector xpath='//title' data='&lt;title&gt;Quotes to Scrape&lt;/title&gt;'&gt;]&gt;&gt;&gt; response.xpath('//title/text()').extract_first()'Quotes to Scrape' XPath是非常形象具体，并且功能强大的，CSS的选择器也是通过一些接口来转化为XPath的，虽然XPath没有CSS那么出名，但是它还是非常强大的，官方也是建议学习使用XPath，给出相关的链接： [https://docs.scrapy.org/en/latest/topics/selectors.html#topics-selectors] [http://zvon.org/comp/r/tut-XPath_1.html] [http://plasmasturm.org/log/xpath101/] 1.3.5 解析数据 现在你已经知道了一些关于选择器，获取数据的方法，现在就可以完善我们之前的爬虫了 刚才我们爬去的的页面中，你会发现每个http://quotes.toscrape.com都含有一下的html： 123456789101112131415&lt;div class="quote"&gt; &lt;span class="text"&gt;“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”&lt;/span&gt; &lt;span&gt; by &lt;small class="author"&gt;Albert Einstein&lt;/small&gt; &lt;a href="/author/Albert-Einstein"&gt;(about)&lt;/a&gt; &lt;/span&gt; &lt;div class="tags"&gt; Tags: &lt;a class="tag" href="/tag/change/page/1/"&gt;change&lt;/a&gt; &lt;a class="tag" href="/tag/deep-thoughts/page/1/"&gt;deep-thoughts&lt;/a&gt; &lt;a class="tag" href="/tag/thinking/page/1/"&gt;thinking&lt;/a&gt; &lt;a class="tag" href="/tag/world/page/1/"&gt;world&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 还是通过shell的方法来测试，执行下面的代码: 1234//1.scrapy shell 'http://quotes.toscrape.com//2.response.css("div.quote") 当然也可以把筛选后的数据，复制给每个变量： 1quote = response.css("div.quote")[0] 现在也可以通过解析quote来获得下面的值：title/author/tag 123456789&gt;&gt;&gt; title = quote.css("span.text::text").extract_first()&gt;&gt;&gt; title'“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”'&gt;&gt;&gt; author = quote.css("small.author::text").extract_first()&gt;&gt;&gt; author'Albert Einstein'&gt;&gt;&gt; tags = quote.css("div.tags a.tag::text").extract()&gt;&gt;&gt; tags['change', 'deep-thoughts', 'thinking', 'world'] 已经可以知道我们是如何来获取数据的了，现在我们就可以遍历循环，并且将爬去下来的数据插入到我们的Python的字典数据结构中： 123456789&gt;&gt;&gt; for quote in response.css("div.quote"):... text = quote.css("span.text::text").extract_first()... author = quote.css("small.author::text").extract_first()... tags = quote.css("div.tags a.tag::text").extract()... print(dict(text=text, author=author, tags=tags))&#123;'tags': ['change', 'deep-thoughts', 'thinking', 'world'], 'author': 'Albert Einstein', 'text': '“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”'&#125;&#123;'tags': ['abilities', 'choices'], 'author': 'J.K. Rowling', 'text': '“It is our choices, Harry, that show what we truly are, far more than our abilities.”'&#125; ... a few more of these, omitted for brevity&gt;&gt;&gt; 1.3.5 更新我们的spide代码： 现在回到我们之前新建的spider的项目中去，到目前为止，我们还真正去获取任何的数据，我们只是做了一件事情，就是讲页面的html的代码保存在本地，我们可以将每个页面的数据，爬去下来，并且将这些数据放下Python的字典的数据结构中，并且返回回去。代码如下： 1234567891011121314151617import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('small.author::text').extract_first(), 'tags': quote.css('div.tags a.tag::text').extract(), &#125; 运行之后看到如下的返回： 12342016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://quotes.toscrape.com/page/1/&gt;&#123;'tags': ['life', 'love'], 'author': 'André Gide', 'text': '“It is better to be hated for what you are than to be loved for what you are not.”'&#125;2016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://quotes.toscrape.com/page/1/&gt;&#123;'tags': ['edison', 'failure', 'inspirational', 'paraphrased'], 'author': 'Thomas A. Edison', 'text': "“I have not failed. I've just found 10,000 ways that won't work.”"&#125; 1.3.6 保存数据 最简单的保存形式就是通过Feed exports [https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-exports] 这里我们可以执行下面的代码保存为json的格式： 1scrapy crawl quotes -o quotes.json 此时在文件中就会出现一个名叫quotes.json的文件，其实就是我们刚才爬去下来的数据。 其实在一些简单的爬虫项目中，这样写，其实已经足够了，但是在一些复杂的大型项目中，可以写Item Pipeline[https://docs.scrapy.org/en/latest/topics/item-pipeline.html#topics-item-pipeline], 其实这个功能就是对应的项目的中tutorial/pipelines.py, scrapy项目默认会帮你创建的。 1.3.7 获取更多的url 其实刚才在项目中，我们只是爬去了两个url，并且也知道如何去解析他们，但是可能我们需要的是爬去整个网站的url，比如我们在爬去一个页面的时候，遇到这样的html,我们就需要计算并且获取对应的url: 12345&lt;ul class="pager"&gt; &lt;li class="next"&gt; &lt;a href="/page/2/"&gt;Next &lt;span aria-hidden="true"&gt;&amp;rarr;&lt;/span&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 此时你可能需要获取的是a里面对应的href的值： 12&gt;&gt;&gt; response.css('li.next a::attr(href)').extract_first()'/page/2/' 现在我们可以修改我们的spider的代码了，并且不需要指定几个url了，我们需要将这些逻辑都放到parse的函数中去： 123456789101112131415161718192021import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', ] def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('small.author::text').extract_first(), 'tags': quote.css('div.tags a.tag::text').extract(), &#125; next_page = response.css('li.next a::attr(href)').extract_first() if next_page is not None: next_page = response.urljoin(next_page) yield scrapy.Request(next_page, callback=self.parse) 上面的代码很容易看出，当解析完数据之后，我们就会寻找下一页的url,并且发现这里写的是一个相对的url，这里可以通过urljoin()这个函数来拼接url，并且yields回去一个新的request，当拿到的respsonse又会回到parse的函数中来解析 scrapy的下载机制：当你yields一个新的请求，scrapy会发送改请求，并注册一个回调方法，以便在完成的时候能够解析他。 1.3.8 简化发送的请求 为了简化发送的请求，我们可以用response.follow, 而不是新建一个新的Request 1234567891011121314151617181920import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', ] def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('span small::text').extract_first(), 'tags': quote.css('div.tags a.tag::text').extract(), &#125; next_page = response.css('li.next a::attr(href)').extract_first() if next_page is not None: yield response.follow(next_page, callback=self.parse) 与scrapy.Request不同，response.follow是支持相对路径，其实就是这个follow它会替我们做response.urljoin,并且response.follow返回是一个Request的实例。 之前的代码，取的是列表中的第一项元素，但是我们也可以枚举这个列表，来调用response.follow 123456for href in response.css('li.next a::attr(href)'): yield response.follow(href, callback=self.parse) // 也可以进行简写for a in response.css('li.next a'): yield response.follow(a, callback=self.parse) 对于抓取作者信息，我们可以自定义自己的回调函数 1234567891011121314151617181920212223242526import scrapyclass AuthorSpider(scrapy.Spider): name = 'author' start_urls = ['http://quotes.toscrape.com/'] def parse(self, response): # follow links to author pages for href in response.css('.author + a::attr(href)'): yield response.follow(href, self.parse_author) # follow pagination links for href in response.css('li.next a::attr(href)'): yield response.follow(href, self.parse) def parse_author(self, response): def extract_with_css(query): return response.css(query).extract_first().strip() yield &#123; 'name': extract_with_css('h3.author-title::text'), 'birthdate': extract_with_css('.author-born-date::text'), 'bio': extract_with_css('.author-description::text'), &#125; 这里当找到author相关的链接，我们会回调我们自定义的函数parse_author,在这个函数里，我们顶一个帮助函数，帮助我们具体还获取里面的值，在parse函数中，我们会找到下一页的请求，然后继续发送请求，回调函数还是我们的parse的函数. 这里有个关键的问题，我们不需要担心同一个url发送多次，易导致进入死循环，Scrapy默认是能够过滤已经请求过的url，并且你还可以通过在settings.py的文件中设置DUPEFILTER_CLASS [https://docs.scrapy.org/en/latest/topics/settings.html#std:setting-DUPEFILTER_CLASS]。 1.3.9 在spider中传递参数 我们可以通过下面的-a来传递参数，这些参数默认是传递到Spider中的__init__函数中去，并且能够成为spider的属性值 1scrapy crawl quotes -o quotes-humor.json -a tag=humor 例如上面的命令，我传递了tag的值，这样我就可以在我的spider项目中能够通过self.tag来获取传进来的值，也可以通过这样的值来请求准确url,其实就是请求的是这样的url: http://quotes.toscrape.com/tag/humor 12345678910111213141516171819202122import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): url = 'http://quotes.toscrape.com/' tag = getattr(self, 'tag', None) if tag is not None: url = url + 'tag/' + tag yield scrapy.Request(url, self.parse) def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('small.author::text').extract_first(), &#125; next_page = response.css('li.next a::attr(href)').extract_first() if next_page is not None:]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django第五/六部分，基本的测试用例[官网教程]]]></title>
    <url>%2F2017%2F05%2F17%2F20170517%2F</url>
    <content type="text"><![CDATA[经过前四部分的学习，此时我们已经创建了我们第一个app：polls, 并且根据我们自己的需求，修改了url，修改了对应的view函数，连接数据库，插入数据库相应的数据，并将数据库里的数据捞出来，显示在模板上，这似乎就是我们在前四部分做的事情，说起来简单，但是做好、做精细却不容易。下面我们会为我们的app提供测试的功能。1.1 什么是自动测试 测试是对代码对好检测，测试能够针对不同层面进行测试(1.对某个特定的方法是否按照预期返回都能够进行测试。2.有的人会对整个项目的整体操作做相应的测试用户输入具体的某些值，得到预期的一些值)，其实这里的测试与第二部分运用shell的操作是差不多的。 而自动化测试区别在于，一旦你的自动化测试生成了之后，当你修改了代码之后，你不需要再花时间人工去测试，自动可以测试你的代码。 1.2 写第一个测试用例 polls的应用存在一些小bug，在Question的Model中定义了这样一个方法，这个方法能够判断我们发布的时间是不是在一天之内的，如果在一天之内就会返回True，否则就是False： 12def was_published_recently(self): return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1) 运用shell,在终端输入python manager.py shell，然后再输入下面的代码： 12345678&gt;&gt;&gt; import datetime&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; from polls.models import Question&gt;&gt;&gt; # create a Question instance with pub_date 30 days in the future&gt;&gt;&gt; future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))&gt;&gt;&gt; # was it published recently?&gt;&gt;&gt; future_question.was_published_recently()True 这个显然是错误的，距离我发布的时间30天，应该返回false 开始写自动化测试来发现暴露这个bug，至少在今后，不会再出现类似的问题了。 打开polls/tests.py的文件，添加如下的代码： 123456789101112131415161718import datetimefrom django.utils import timezonefrom django.test import TestCasefrom .models import Questionclass QuestionMethodTests(TestCase): def test_was_published_recently_with_future_question(self): """ was_published_recently() should return False for questions whose pub_date is in the future. """ time = timezone.now() + datetime.timedelta(days=30) future_question = Question(pub_date=time) self.assertIs(future_question.was_published_recently(), False) 这里创建了一个django.test.TestCase的子类，实例化了一个Question的对象，通过传入一个time的参数，然后断言question的was_published_recently()返回的为false 执行python manage.py test polls 12345678910111213141516Creating test database for alias 'default'...System check identified no issues (0 silenced).F======================================================================FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionMethodTests)----------------------------------------------------------------------Traceback (most recent call last): File "/path/to/mysite/polls/tests.py", line 16, in test_was_published_recently_with_future_question self.assertIs(future_question.was_published_recently(), False)AssertionError: True is not False----------------------------------------------------------------------Ran 1 test in 0.001sFAILED (failures=1)Destroying test database for alias 'default'... 执行python manage.py test polls是让Django去在polls这个app 应用中查找你写的测试用例，当Django查找到django.test.TestCase的子类，Django将会为这个测试创建一些数据，Django接着去寻找以test开头的测试方法,在刚才我们创建的test_was_published_recently_with_future_question这个函数，第二行中，传入了一个pub_date创建了一个Question的实例对象，接着就断言question的was_published_recently()返回为False, 但是实际上返回的是True,这也就是导致我们断言失败的原因所在。 1.3 修改bug 此时我们已经知道了如果我们设置的pub_date是将来的时间的话，Question.was_published_recently()就应该返回的是False,所以打开polls/models.py修改为： 123def was_published_recently(self): now = timezone.now() return now - datetime.timedelta(days=1) &lt;= self.pub_date &lt;= now 再次执行python manage.py test polls就会得到下面的正确反馈： 123456789GhCoder_Site python manage.py test pollsCreating test database for alias 'default'...System check identified no issues (0 silenced)..----------------------------------------------------------------------Ran 1 test in 0.002sOKDestroying test database for alias 'default'... 1.4 更全面的测试 依旧测试was_published_recently()这个函数，让我们的测试更加全面，添加如下的两个方法： 1234567891011121314151617def test_was_published_recently_with_old_question(self): """ was_published_recently() should return False for questions whose pub_date is older than 1 day. """ time = timezone.now() - datetime.timedelta(days=30) old_question = Question(pub_date=time) self.assertIs(old_question.was_published_recently(), False)def test_was_published_recently_with_recent_question(self): """ was_published_recently() should return True for questions whose pub_date is within the last day. """ time = timezone.now() - datetime.timedelta(hours=1) recent_question = Question(pub_date=time) self.assertIs(recent_question.was_published_recently(), True) 这里我们添加了超过一天的数据，以及一天之内的数据，测试返回回来都和我们的断言是一样的，这样我就能更加保证我们的代码没有问题了。 1.5 测试View 之前我们的测试都是测试驱动的标准来写测试的，但是这也并不能涵盖我们所有的代码，测试驱动我们重点去关心具体的代码实现，但是测试view的话，我们重点是通过浏览器来模拟用户进行测试。 1.5.1 Django测试客户端 Django是提供测试客户端来模拟用户来具体与view进行交互，我们可以在tests.py文件中写代码，也可以通过shell来完成。 其实说白了就是看不到界面，完全是通过shell脚本来模拟请求，能够正常解析到response、response_code、response.content、response.context等等 我们先通过shell来完成测试环境的设置: 1234567891011121314151617181920212223242526272829//1.python manager.py shell//2.&gt;&gt;&gt; from django.test.utils import setup_test_environment&gt;&gt;&gt; setup_test_environment()&gt;&gt;&gt; from django.test import Client&gt;&gt;&gt; # create an instance of the client for our use&gt;&gt;&gt; client = Client()&gt;&gt;&gt; # get a response from '/'&gt;&gt;&gt; response = client.get('/')&gt;&gt;&gt; # we should expect a 404 from that address; if you instead see an&gt;&gt;&gt; # "Invalid HTTP_HOST header" error and a 400 response, you probably&gt;&gt;&gt; # omitted the setup_test_environment() call described earlier.&gt;&gt;&gt; response.status_code404&gt;&gt;&gt; # on the other hand we should expect to find something at '/polls/'&gt;&gt;&gt; # we'll use 'reverse()' rather than a hardcoded URL&gt;&gt;&gt; from django.urls import reverse&gt;&gt;&gt; response = client.get(reverse('polls:index'))&gt;&gt;&gt; response.status_code200&gt;&gt;&gt; response.contentb'\n &lt;ul&gt;\n \n &lt;li&gt;&lt;a href="/polls/1/"&gt;What&amp;#39;s up?&lt;/a&gt;&lt;/li&gt;\n \n &lt;/ul&gt;\n\n'&gt;&gt;&gt; response.context['latest_question_list']&lt;QuerySet [&lt;Question: What's up?&gt;]&gt; 1.5.2 改善我们的View 在第四部分的时候，我们依据类的形式来创建了view,在polls/views.py的文件中： 1234567class IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list' def get_queryset(self): """Return the last five published questions.""" return Question.objects.order_by('-pub_date')[:5] 这是之前的代码，我们现在想修改get_queryset这个方法，之前是返回最后的5条数据，现在我们希望通过时间来过滤： 1234567891011//1.from django.utils import timezonedef get_queryset(self): """ Return the last five published questions (not including those set to be published in the future). """ return Question.objects.filter( pub_date__lte=timezone.now() ).order_by('-pub_date')[:5] Question.objects.filter(pub_date__lte=timezone.now())意思是：查找Question,并且他们的pub_date&lt;=现在的时候。 1.5.3 测试我们新的页面 在polls/tests.py的文件中添加如下的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//1.from django.urls import reversedef create_question(question_text, days): """ Creates a question with the given `question_text` and published the given number of `days` offset to now (negative for questions published in the past, positive for questions that have yet to be published). """ time = timezone.now() + datetime.timedelta(days=days) return Question.objects.create(question_text=question_text, pub_date=time)class QuestionViewTests(TestCase): def test_index_view_with_no_questions(self): """ If no questions exist, an appropriate message should be displayed. """ response = self.client.get(reverse('polls:index')) self.assertEqual(response.status_code, 200) self.assertContains(response, "No polls are available.") self.assertQuerysetEqual(response.context['latest_question_list'], []) def test_index_view_with_a_past_question(self): """ Questions with a pub_date in the past should be displayed on the index page. """ create_question(question_text="Past question.", days=-30) response = self.client.get(reverse('polls:index')) self.assertQuerysetEqual( response.context['latest_question_list'], ['&lt;Question: Past question.&gt;'] ) def test_index_view_with_a_future_question(self): """ Questions with a pub_date in the future should not be displayed on the index page. """ create_question(question_text="Future question.", days=30) response = self.client.get(reverse('polls:index')) self.assertContains(response, "No polls are available.") self.assertQuerysetEqual(response.context['latest_question_list'], []) def test_index_view_with_future_question_and_past_question(self): """ Even if both past and future questions exist, only past questions should be displayed. """ create_question(question_text="Past question.", days=-30) create_question(question_text="Future question.", days=30) response = self.client.get(reverse('polls:index')) self.assertQuerysetEqual( response.context['latest_question_list'], ['&lt;Question: Past question.&gt;'] ) def test_index_view_with_two_past_questions(self): """ The questions index page may display multiple questions. """ create_question(question_text="Past question 1.", days=-30) create_question(question_text="Past question 2.", days=-5) response = self.client.get(reverse('polls:index')) self.assertQuerysetEqual( response.context['latest_question_list'], ['&lt;Question: Past question 2.&gt;', '&lt;Question: Past question 1.&gt;'] ) 仔细看一下你就会发现： 这里create_question是一个快生产question的函数。 test_index_view_with_a_past_question我们不创建任何的question对象，我们的的一些断言，这个测试就素在测试如果数据库里面没有我们需要的数据，我们该如何处理，检测了response以及response.context。这里用到了assertContains() and assertQuerysetEqual() 在下面的测试同样。 1.5.4 测试详情页面 打开polls/views.py修改为,详情页面也要过滤掉将来的时间点的数据： 1234567class DetailView(generic.DetailView): ... def get_queryset(self): """ Excludes any questions that aren't published yet. """ return Question.objects.filter(pub_date__lte=timezone.now()) 此时再添加一下测试数据，打开polls/tests.py： 1234567891011121314151617181920class QuestionIndexDetailTests(TestCase): def test_detail_view_with_a_future_question(self): """ The detail view of a question with a pub_date in the future should return a 404 not found. """ future_question = create_question(question_text='Future question.', days=5) url = reverse('polls:detail', args=(future_question.id,)) response = self.client.get(url) self.assertEqual(response.status_code, 404) def test_detail_view_with_a_past_question(self): """ The detail view of a question with a pub_date in the past should display the question's text. """ past_question = create_question(question_text='Past Question.', days=-5) url = reverse('polls:detail', args=(past_question.id,)) response = self.client.get(url) self.assertContains(response, past_question.question_text) 123456789GhCoder_Site python manage.py test pollsCreating test database for alias 'default'...System check identified no issues (0 silenced)...........----------------------------------------------------------------------Ran 10 tests in 0.058sOKDestroying test database for alias 'default'... 还有一些进阶的测试工具： Selenium[http://seleniumhq.org/] LiveServerTestCase [https://docs.djangoproject.com/en/1.11/topics/testing/tools/#django.test.LiveServerTestCase] 1.5.5 自定义项目app1.添加css样式： 在创建项目的时候，项目中的HTML/JavaScript/CSS都是用来呈现页面以及布局的时候需要用到，我们应该把这些文件统一放到static files的文件里面去。这里django.contrib.staticfiles替我们都做好了。 首先在polls的目录中添加static的文件夹，Django将会自动去找static文件夹中的文件。 在static下面在添加polls文件夹，再在polls文件夹里面再添加style.css,里面添加如下的操作： 123li a &#123; color: green;&#125; 然后在polls/templates/polls/index.html文件里面添加如下的代码： 123&#123; % load static % &#125;&lt;link rel="stylesheet" type="text/css" href="&#123; % static 'polls/style.css' % &#125;" /&gt; { % static % }tag能够生成static文件夹的绝对url。 2.添加图片的样式 创建一个images文件夹，路径为polls/static/polls/images/xxx.png,然后就可以在css的文件中添加如下的代码 123body &#123; background: white url("images/xxx.png") no-repeat right bottom;&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django第四部分，细化系统模板[官网教程]]]></title>
    <url>%2F2017%2F05%2F16%2F20170516%2F</url>
    <content type="text"><![CDATA[1.8：细化views页面的功能 打开polls/detail.html的文件，将其中的代码修改一下： 123456789101112&lt;h1&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/h1&gt;&#123; % if error_message % &#125;&lt;p&gt;&lt;strong&gt;&#123; &#123; error_message &#125; &#125;&lt;/strong&gt;&lt;/p&gt;&#123; % endif % &#125;&lt;form action="&#123; % url 'polls:vote' question.id % &#125;" method="post"&gt;&#123; % csrf_token % &#125;&#123; % for choice in question.choice_set.all % &#125; &lt;input type="radio" name="choice" id="choice&#123; &#123; forloop.counter &#125; &#125;" value="&#123; &#123; choice.id &#125; &#125;" /&gt; &lt;label for="choice&#123; &#123; forloop.counter &#125; &#125;"&gt;&#123; &#123; choice.choice_text &#125; &#125;&lt;/label&gt;&lt;br /&gt;&#123; % endfor % &#125;&lt;input type="submit" value="Vote" /&gt;&lt;/form&gt; 这里的改动比较大,在页面上显示了勾选按钮，value与question.id类型关联起来了，name的值写死为choice,当某人勾选了一个，并且点击的提交的按钮，那么就会post的数据为：choice=#。 定义了一个form, 并且method=post forloop.counter就指明了多少次循环 因为我们运用了post的请求，所以我们需要防止他们跨域请求，并且篡改数据，这里我们需要感谢Django,他给我们定义了{ % csrf_token % }这个标记，就是为了防止被篡改数据 现在来处理post过来的请求，并且做出相应的处理。打开polls/urls.py 1234567891011121314151617181920212223from django.shortcuts import get_object_or_404, renderfrom django.http import HttpResponseRedirect, HttpResponsefrom django.urls import reversefrom .models import Choice, Question# ...def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST['choice']) except (KeyError, Choice.DoesNotExist): # Redisplay the question voting form. return render(request, 'polls/detail.html', &#123; 'question': question, 'error_message': "You didn't select a choice.", &#125;) else: selected_choice.votes += 1 selected_choice.save() # Always return an HttpResponseRedirect after successfully dealing # with POST data. This prevents data from being posted twice if a # user hits the Back button. return HttpResponseRedirect(reverse('polls:results', args=(question.id,))) 这里的request.POST就是个字典类型的数据，通过取request.POST[&#39;choice&#39;]得到的是选中的id，并且以字符串的形式返回。 在request.POST中，提供了KeyError的错误，当你要去的key不在post的字段里面，就会拿到这样的错误。 注意到当成功之后，相应的votes加1之后，我们返回的不是HttpResponse,而是HttpResponseRedirect,接受一个参数，这个参数就是成功之后调教的url。并且官网提出了，当成功完成post之后，就是应该跳转页面，这不仅仅是Django要求的，而是作为web开发所必须要养成的好习惯。 最后注意到我们在HttpResponseRedirect里面用到了reverse()，其实他的作用就是为了解决硬编码的问题，其实reverse(&#39;polls:results&#39;, args=(question.id,) = /polls/3/results/ 看到成功返回的页面为results的函数： 12345from django.shortcuts import get_object_or_404, renderdef results(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/results.html', &#123;'question': question&#125;) 在这里需要创建polls/results.html的模板页面 123456789&lt;h1&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/h1&gt;&lt;ul&gt;&#123; % for choice in question.choice_set.all % &#125; &lt;li&gt;&#123; &#123; choice.choice_text &#125; &#125; -- &#123; &#123; choice.votes &#125; &#125; vote&#123; &#123; choice.votes|pluralize &#125; &#125;&lt;/li&gt;&#123; % endfor % &#125;&lt;/ul&gt;&lt;a href="&#123; % url 'polls:detail' question.id % &#125;"&gt;Vote again?&lt;/a&gt; 此时选中之后的结果页面就可以正常显示的了： 123456What's up? Not much -- 4 vote s The sky -- 1 vote Just hacking again -- 0 vote s Just kidding -- 0 vote s 这里官网提了一个意见，就是selected_choice = question.choice_set.get(pk=request.POST[&#39;choice&#39;]),这个数据是从数据库中取出来的，但是如果两个用户同一时间做次操作，并且进行投票的话，这里会存在一个竞争的关系，这里官网给出的意见是用函数F()来避免这种情况 [https://docs.djangoproject.com/en/1.11/ref/models/expressions/#avoiding-race-conditions-using-f] 1.9：使用通用视图让代码少点 可能你已经发现了，detail和results的页面非常的相近，这里我们会做出改变 这些views页面都做了一些类似的事情，根据URL从数据库中得到数据,加载模板，并且显示出来，这些操作都是雷同的，此时我们可以通过通用视图来减少我们的代码量 1.9.1 修改URLconf 打开polls/urls.py文件修改为： 1234567891011from django.conf.urls import urlfrom . import viewsapp_name = 'polls'urlpatterns = [ url(r'^$', views.IndexView.as_view(), name='index'), url(r'^(?P&lt;pk&gt;[0-9]+)/$', views.DetailView.as_view(), name='detail'), url(r'^(?P&lt;pk&gt;[0-9]+)/results/$', views.ResultsView.as_view(), name='results'), url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),] 这里做了两个改变1：一个是讲参数的名字丢该为了pk, 2:将views只想的函数方式修改了，只是是在同一个类中调用不同的属性是使用方法，现在是调用不同类的方式，或许是类是更好的条件继承、重用代码的吧。 1.9.2 修改views 打开polls/views.py文件修改为： 1234567891011121314151617181920212223242526272829from django.shortcuts import get_object_or_404, renderfrom django.http import HttpResponseRedirectfrom django.urls import reversefrom django.views import genericfrom .models import Choice, Questionclass IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list' def get_queryset(self): """Return the last five published questions.""" return Question.objects.order_by('-pub_date')[:5]class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html'class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html'def vote(request, question_id): ... # same as above, no changes needed. 这里用到了ListView和DetailView，分别需要去去继承他们，他们其实都是一些抽象的概念。 每个通用视图都需要一个model的字段，因此你需要丢一个Model字段。 DetailView显示需要从URL中获取pk的字段，所以我们在写url的时候，将quesiton_id的参数名字修改为了pk。 DetailView需要使用的模板名字为：&lt;app name&gt;/&lt;module name&gt;_detail.name，在我们现在的项目中，模板的名字为：polls/question_detail.html,这里模板名字的存在是为告诉Django需要使用特定名称的模板，而不是使用默认生成的模板，这里你就会发现detail和result虽然继承的都是DetailView,但是他们指定了不同模板名字，这就让显示不同的模板名字。 类似的ListView也是一样的，默认Django会去找&lt;app name&gt;/&lt;model name&gt;_list.html，但是由于我们定义了template_name,因此他只会找polls/index.html 在之前我们都是通过丢一个名叫question以及latest_question_list的值给模板的，对DetailView而言：question的值是默认会被生成的，因为我们运用了Django model(Question),Django 是能够通过名字自动检测的。 而在ListView中，我们用到了latest_question_list,Django默认会生成question_list,但是我们需要的是latest_question_list,因此我们需要覆写这个属性context_object_name，将它准确定义为我们需要的名字latest_question_list 模板这部分 确实还是挺复杂的，主要是我们不太熟悉一些字段的用法、含义，可以自行参考 [https://docs.djangoproject.com/en/1.11/topics/class-based-views/]]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django第三部分，重点关注如何运用系统模板,并且自定义URL[官网教程]]]></title>
    <url>%2F2017%2F05%2F15%2F20170515%2F</url>
    <content type="text"><![CDATA[1.开始写新的Views 打开polls/views.py文件，写views的函数和写其他的函数略有不同，因为他们可以接受参数，写入下面的代码： 123456789def detail(request, question_id): return HttpResponse("You're looking at question %s." % question_id)def results(request, question_id): response = "You're looking at the results of question %s." return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse("You're voting on question %s." % question_id) 写完了views的这些函数，其实这些函数只是简单的返回一些字符串，下面来出来一些关于url的函数处理polls/urls.py： 1234567891011121314from django.conf.urls import urlfrom . import viewsurlpatterns = [ # ex: /polls/ url(r'^$', views.index, name='index'), # ex: /polls/5/ url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'), # ex: /polls/5/results/ url(r'^(?P&lt;question_id&gt;[0-9]+)/results/$', views.results, name='results'), # ex: /polls/5/vote/ url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),] 现在当你再去访问/polls/34、/polls/34/results/、/polls/34/vote/你就可以看到，这些能够对应到刚才你写的几个函数了。 当你访问的url为/polls/34/的时候，此时Django将先找到项目中的urls模块，（其实就是加载项目中的urls.py的文件），它将会找到名为urlpatterns这个列表，看看在你的列表的项目中，有没有出现你访问的url的条目，当系统找到^polls/之后，就会去掉^polls/,然后将剩下的34/发送给polls.urls进行更深的解析，终于在polls/urls.py的urlpatterns列表中找到了这行代码url(r&#39;^(?P&lt;question_id&gt;[0-9]+)/$&#39;, views.detail, name=&#39;detail&#39;),因为这行代码的第二个参数是指向的views.detail函数句柄，这里其实执行的是下面的代码： 1detail(request=&lt;HttpRequest object&gt;, question_id='34') 而这里的question_id=&#39;34&#39;,部分是因为我们写的这部分正则:(?P&lt;question_id&gt;[0-9]+),括号所包含的内容将作为一个参数传给对应的函数, ?P&lt;question_id&gt;定义了传给函数的形参名 1.1:具体处理一些页面的请求 每个页面应该可以做1-2件事情，返回http的请求，可以通过HttpResponse[https://docs.djangoproject.com/en/1.11/ref/request-response/#django.http.HttpResponse], 还有些未找到页面Django也给了响应的便利返回Http404[https://docs.djangoproject.com/en/1.11/topics/http/views/#django.http.Http404], 其实说白了每个页面它希望得到的是HttpResponse能够处理正常的逻辑，要不然就是exception，打开polls/views.py 1234567from django.http import HttpResponsefrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] output = ', '.join([q.question_text for q in latest_question_list]) return HttpResponse(output) 这里当你再次访问/polls/的时候，你就可以看到在第二部分数据库操作插入的数据了，但是我们如何让我们的界面显示的好看一点呢，这里就需要引入template模板，现在我们polls的文件夹中创建templates文件夹，Django将会自动去这个文件夹中去寻找模板。 这里还要说一下，如果在settings.py文件中APP_DIRS设置的是TRUE的话，Django的模板默认就会去INSTALL_APPS去寻找对应的templates的文件夹。 系统给我们的意见是，让我们在templates文件夹下面再创建一个polls的文件夹，在polls的文件夹内再创建index.html,总的路径应该是这样的：polls/templates/polls/index.html，这样创建的是为了方便我们在调用模板的时候方便、易读polls/index.html 下面再刚创建的index.html中添加如下的代码： 123456789&#123; % if latest_question_list % &#125; &lt;ul&gt; &#123; % for question in latest_question_list % &#125; &lt;li&gt;&lt;a href="/polls/&#123; &#123; question.id &#125; &#125;/"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt; &#123; % endfor % &#125; &lt;/ul&gt;&#123; % else % &#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123; % endif % &#125; 显示的模板已经写完了，下面再将之前的views.py的函数修改一下： 12345678910111213from django.http import HttpResponsefrom django.template import loaderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] template = loader.get_template('polls/index.html') context = &#123; 'latest_question_list': latest_question_list, &#125; return HttpResponse(template.render(context, request)) 1.2：render()函数 这里我们可以通过render()函数来简写我们的模板，直接可以通过render函数,并且也不需要放回HttpResponse,也不需要loader函数来载入我们的模板了 render()函数将request作为第一个参数，模板的名字作为第二个参数，第三个参数为可选参数，返回的是HttpResponse的对象。 用render之后，代码改变为： 123456789from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 1.3：下面来处理一下404的错误页面1234567891011from django.http import Http404from django.shortcuts import renderfrom .models import Question# ...def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404("Question does not exist") return render(request, 'polls/detail.html', &#123;'question': question&#125;) 这里的在详情页面的时候，如果访问主键不存在的话，我们应该抛出404的错误，让我们能够捕捉到错误。 同时在polls/detail.html的文件中添加如在下代码： 1&#123; &#123; question &#125; &#125; 1.4：404函数的缩写get_object_or_404()1234567from django.shortcuts import get_object_or_404, renderfrom .models import Question# ...def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;) get_object_or_404()函数第一个参数为：Django的Model, 第二个参数，是一个列表，是任意数量参数的列表,当get不到任何东西的时候，就会返回Http404的对象。 1.5:使用系统模板 回到我们之前写的polls/detail.html，改为这样： 123456&lt;h1&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/h1&gt;&lt;ul&gt;&#123; % for choice in question.choice_set.all % &#125; &lt;li&gt;&#123; &#123; choice.choice_text &#125; &#125;&lt;/li&gt;&#123; % endfor % &#125;&lt;/ul&gt; 当我们运用系统的模板的时候，可以看到系统是用的点语法,例如{ { question.question_text } }，Django 先去寻找question这个对象是否存在，然后再去寻找question是否存在question_text的这个属性值。 { % for % }这是一个for循环，question.choice_set.all=question.choice_set.all()这个返回的是一个包含Choice，可迭代的集合。 系统模板更多信息[https://docs.djangoproject.com/en/1.11/topics/templates/] 1.6：去除系统模板中的硬编码 我们在写index.html模板的时候，我们写到这样一段代码&lt;li&gt;&lt;a href=&quot;/polls/{ { question.id } }/&quot;&gt;{ { question.question_text } }&lt;/a&gt;&lt;/li&gt;，通过我们在views.py的函数中将question的数据中传递到模板上，并且在模板上这样使用，道理上来说是没毛病的。 这样写的问题，在于模板和数据，紧密耦合在一起，在很多模板中，假如我一旦修改了URL，我们就得去一堆的模板中修改这个写死的url。 因为我们在polls/urls.py中已经用到了url的模块,那么我们就能够通过之前定义的url,并且知道下面将要跳转url。 123urlpatterns = [ url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'), ] 因此可以修改为： 1234//修改前&lt;li&gt;&lt;a href="/polls/&#123; &#123; question.id &#125; &#125;/"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt;//修改后&lt;li&gt;&lt;a href="&#123; % url 'detail' question.id % &#125;"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt; 如果你想要修改详情页面的url，假如现在的url不是之前的polls/12,而是最新的url：polls/specifics/12,此时你只需要在你的url中加一个一个url，例如： 123...url(r'^specifics/(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'),... 1.7:URL的命名空间 在这个项目中，我们仅仅只是创建了一个app，叫做polls,但是在实际的Django的项目中，其实会有10、20几个app, 那么我们在使用之前提到的{ % url % },Django如何区分url呢？比如我polls下面有一个detail，假如我还有个新的app，下面也有一个detail,我改怎么区分呢？ 官方的意思是去定义app_name,打开polls/url.py 1234567891011from django.conf.urls import urlfrom . import viewsapp_name = 'polls'urlpatterns = [ url(r'^$', views.index, name='index'), url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'), url(r'^(?P&lt;question_id&gt;[0-9]+)/results/$', views.results, name='results'), url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),] 并且家模板里面的代码也做一下修改： 12345//未使用app_name&lt;li&gt;&lt;a href="&#123; % url 'detail' question.id % &#125;"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt;//使用app_name = 'polls'&lt;li&gt;&lt;a href="&#123; % url 'polls:detail' question.id % &#125;"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt; ps: 最后说一下，hexo好坑呐！在markdown格式中不能出现”{ {“ 以及 “{ %”,必须要在中间添加个空格。哎！无语。。。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django第二部分[官网教程]]]></title>
    <url>%2F2017%2F05%2F14%2F20170514%2F</url>
    <content type="text"><![CDATA[学习Django的第二部分[对官网Demo教程的翻译，以及自己的一些认识]第一部分，已经使用了Django写了一个简单View，并且配置了我们的url，是的我们能够正常访问到我们新建的View页面。今天开始第二部分： 我们需要到xxxProject/settings.py文件去修改配置，我们这里主要讲的是数据库的配置。 Django默认是安装了SQLite，这里不需要额外下载什么。 如果需要用到别的数据库，可以去settings文件去修改。默认是这样的： 123456DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125; &#125; 这里解释一下： ENGINE字段根据选用数据库的不同，Django已经给我们做好了数据的枚举：django.db.backends.sqlite3,django.db.backends.postgresql,django.db.backends.mysql,django.db.backends.oracle NAME数据库的名字 如果你和我一样，不是选用的Django默认的使用的sqlite的话，除此之外，还需要配置USER,PASSWORD,HOST,我用的mysql,这里如果需要正常使用mysql的话，可能还需要安装其他的一些依赖库，这里可以参考 [https://docs.djangoproject.com/en/1.11/topics/install/#database-installation] 官方给出了demo，可以根据自己的需求进行修改 12345678910 DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.postgresql', 'NAME': 'mydatabase', 'USER': 'mydatabaseuser', 'PASSWORD': 'mypassword', 'HOST': '127.0.0.1', 'PORT': '5432', &#125;&#125; 数据库配置好之后，然后我们开始配置TIME_ZONE,默认值为America/Chicago,如果在中国的话，应该是Asia/Shanghai北京时间吧，至于时区的列表： [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones]。这里重点说一下INSTALLED_APPS的配置，放在这个选项中的列表的字符串，代表运行Django同事需要激活这些对应的Django应用，app能够在不同的project中使用，并且你也能够打包、分发给别人来使用。12345678910# Application definition INSTALLED_APPS = [ 'django.contrib.admin',//Django 的默认后台系统 'django.contrib.auth', //Django 的认证系统 'django.contrib.contenttypes', // 管理内容类型 'django.contrib.sessions', // 管理sessions 'django.contrib.messages', // 管理消息 'django.contrib.staticfiles', // 管理静态文件 ] 这些已经安装的，默认的app，至少会在后台建立1的表（现在还没有建立表呢），在执行了python manage.py migrate才会在我们的数据库里建立这里app的表。 这里我在linux环境下安装的时候，遇到点问题：包了很多奇葩的错误，这里我就说几个，我遇到的，其他我没有列出来的，可能你直接google就能找到了： 通过sudo pip install MySQL-python来安装mysql的时候包这个错 1Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-7696Ic/MySQL-python/ 直接在命令行运行:12sudo apt install libmysqlclient-devpip install mysql 还有其他的一些小问题： [http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c]执行完 python manage.py migrate 就会看到终端出现这些字样，就代表你的表已经成功生成了, 如果不信，你也可以打开自己mysql数据库，就会发现Django已经为我生成好了表了。12345678910111213141516Operations to perform: Apply all migrations: admin, auth, contenttypes, sessionsRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying sessions.0001_initial... OK 官方给出了关于migrate命令的作用，Django会去project中找我的settings.py文件，并且找到INSTALL_APPS，为这些安装的app创建必要的表, 并且官方也说了，这些默认的INSTALL_APPS并不是每个人都需要他，当不需要的时候，删除掉xxxProject/settings.py文件中对应的app，然后执行migrate就可以了。创建Model好了，现在开始我们需要创建Model了，这也是我为什么喜欢Django的最最根本的原因，Django中的Model不同于其他语言中的Model对象，而是实质性的涉及到数据库的数据。 之前在第一章的时候，我们创建了一个属于我们自己的app，名字叫做polls的app,我们现在围绕这个app创建属于这个app的Model，我们创建两个Model，一个叫做Question,一个叫Choice,Question含有一个问题字段和发布时间的字段，Choice含有两个字段一个choice的Text的字段、一个vote的字段，并且一个choice会关联一个question字段，现在开始编辑polls/models.py文件： 123456789101112from django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 这些model的类都是django.db.models.Model的子类。 这里的每个字段对应的就是数据库中的每个字段。 一些字段是需要必须的参数的，比如CharField必须有参数max_length的存在。 一些字段也可以传入一些可选的参数: 比如：IntegerField的default的字段。 ForeignKey可以通过外键的形式，将choice的类型关联到Question的类型上去，在Django的model数据中，是支持一对多，一对一，多对多的。 激活Model上面虽然外面已经创建了这两个Model，但是目前为止，还没有和我现在有Django项目关联上，在此之前，我们必须要先激活Model,并且根据我们的model代码创建出对应的数据库表的信息。 首先我们先要将我们的polls的app安装上。去settings.py的INSTALL_APPS的列表中，将我们的pollsapp添加进去。 1234567891011 INSTALLED_APPS = [ 'polls.apps.PollsConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 现在执行python manage.py makemigrations polls得到下面的信息： 1234polls/migrations/0001_initial.py - Create model Choice - Create model Question - Add field question to choice 执行makemigrations的目的是告诉Django，你已经对你Model对了一些改变，你希望Django能够保存你的这些改变。 Migrations对你Model的变化仅仅只是将这些变化以文件的形式保存在磁盘中，这些文件，你都是可以看到的polls/migrations/0001_initial.py 下面要执行migrate,将你之前Model的改变同步到数据库表中去。我们为了能够看到具体做了那些SQL上的改变，可以运行sqlmigrate,这个命令会返回对应SQL语句。执行之后，你会看到下面的返回： 12345678910111213141516GhCoder_Site python manage.py sqlmigrate polls 0001BEGIN;---- Create model Choice--CREATE TABLE `polls_choice` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `choice_text` varchar(200) NOT NULL, `votes` integer NOT NULL);---- Create model Question--CREATE TABLE `polls_question` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `question_text` varchar(200) NOT NULL, `pub_date` datetime(6) NOT NULL);---- Add field question to choice--ALTER TABLE `polls_choice` ADD COLUMN `question_id` integer NOT NULL;ALTER TABLE `polls_choice` ADD CONSTRAINT `polls_choice_question_id_c5b4b260_fk_polls_question_id` FOREIGN KEY (`question_id`) REFERENCES `polls_question` (`id`);COMMIT; 注意到下面一些关键的点： 首先表的名字是 AppName_ModelName。 每个表中为我们自动创建了主键：id类型，并且默认不为空，且自增。 外键的添加是ModelName_id。 sqlmigrate其实并没有对数据库做出相应的操作，他只是告诉你这是他将要对数据库所做出的操作，并且能够让你检查是否正确。 123456789//执行下面的命令python manage.py migrate//得到下面的信息GhCoder_Site python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, polls, sessionsRunning migrations: Applying polls.0001_initial... OK 现在你也可以通过phpmyadmin，可以看到数据库中的表都已经如我们之前model定义的那样，创建好了，这就是migragte的魅力所在，可能你在以后的开发中，你根本不需要时不时的去修改数据库，增加修改某个字段，通过migrate就能够实现，只要三个步骤，你就可以显示了了。 改变Model，增加修改字段都可以。 执行python manage.py makemigrations来为这些变化创建migrations。 执行python manage.py migrate来修改数据库表。 运用API来操作ModelDjango非常贴心地为我们提供shell的命令来操作数据。 在操作shell之前，我们首先要运行python manage.py shell。 然后我们就进入到了python的运行环境。下面这段代码是官网给我的，我觉得很详细，也很具体，我只是翻译了一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 从polls.models文件中导入Question、Choice&gt;&gt;&gt; from polls.models import Question, Choice # Import the model classes we just wrote.// 在系统的内存中是否存在Question类型的数据# No questions are in the system yet.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet []&gt;# Create a new Question.# Support for time zones is enabled in the default settings file, so# Django expects a datetime with tzinfo for pub_date. Use timezone.now()# instead of datetime.datetime.now() and it will do the right thing.// 这里创建了Question的数据结构，这个数据结构需要两个字段，一个是字符串，一个date的数据类型，date的数据类型，我这里用timezone来创建，因此这里导入了timezone的模块&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; q = Question(question_text="What's new?", pub_date=timezone.now())// q的实例执行保存的方法# Save the object into the database. You have to call save() explicitly.&gt;&gt;&gt; q.save()// 直接返回里q的id，这里返回的是int，还是long，是根据你选择的数据库来定的。# Now it has an ID. Note that this might say "1L" instead of "1", depending# on which database you're using. That's no biggie; it just means your# database backend prefers to return integers as Python long integer# objects.&gt;&gt;&gt; q.id1// 返回question的实例的属性值# Access model field values via Python attributes.&gt;&gt;&gt; q.question_text"What's new?"&gt;&gt;&gt; q.pub_datedatetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=&lt;UTC&gt;)// 同时也可以修改question实例的属性值，但是要记住保存# Change values by changing the attributes, then calling save().&gt;&gt;&gt; q.question_text = "What's up?"&gt;&gt;&gt; q.save()// 返回内存中所有的Question类型的数据# objects.all() displays all the questions in the database.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: Question object&gt;]&gt; 这里在执行Question.objects.all()，返回是&lt;QuerySet [&lt;Question: Question object&gt;]&gt;，这样可读性不是很好，官方的意思说：只要分别在model文件中覆写def __str__(self):方法就可以了。1234567891011121314from django.db import modelsfrom django.utils.encoding import python_2_unicode_compatible@python_2_unicode_compatible # only if you need to support Python 2class Question(models.Model): # ... def __str__(self): return self.question_text@python_2_unicode_compatible # only if you need to support Python 2class Choice(models.Model): # ... def __str__(self): return self.choice_text 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&gt;&gt;&gt; from polls.models import Question, Choice# Make sure our __str__() addition worked.// 从这里就可以看到我们刚才覆写“def __str__(self):”的作用了&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: What's up?&gt;]&gt;# Django provides a rich database lookup API that's entirely driven by# keyword arguments.// Django 可以通过filter字段来过滤// 也可以通过双下划线来自定义过滤条件&gt;&gt;&gt; Question.objects.filter(id=1)&lt;QuerySet [&lt;Question: What's up?&gt;]&gt;&gt;&gt;&gt; Question.objects.filter(question_text__startswith='What')&lt;QuerySet [&lt;Question: What's up?&gt;]&gt;# Get the question that was published this year.// 导入一些自定义的模块// 生成响应的实例对象，并且用来过滤&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; current_year = timezone.now().year&gt;&gt;&gt; Question.objects.get(pub_date__year=current_year)&lt;Question: What's up?&gt;# Request an ID that doesn't exist, this will raise an exception.// 如果直接通过get的方式来获取某些对象的话，如果对象不存在的话，就会抛出异常&gt;&gt;&gt; Question.objects.get(id=2)Traceback (most recent call last): ...DoesNotExist: Question matching query does not exist.# Lookup by a primary key is the most common case, so Django provides a# shortcut for primary-key exact lookups.# The following is identical to Question.objects.get(id=1).// 查询主键&gt;&gt;&gt; Question.objects.get(pk=1)&lt;Question: What's up?&gt;# Make sure our custom method worked.&gt;&gt;&gt; q = Question.objects.get(pk=1)// 调用自定义的方法&gt;&gt;&gt; q.was_published_recently()True# Give the Question a couple of Choices. The create call constructs a new# Choice object, does the INSERT statement, adds the choice to the set# of available choices and returns the new Choice object. Django creates# a set to hold the "other side" of a ForeignKey relation# (e.g. a question's choice) which can be accessed via the API.&gt;&gt;&gt; q = Question.objects.get(pk=1)# Display any choices from the related object set -- none so far.// 通过set能过找到有没有对应的外键对象存在&gt;&gt;&gt; q.choice_set.all()&lt;QuerySet []&gt;# Create three choices.// 通过create能够创建关联的对象，创建的方法其实就是就可以把它看做是简单的实例化方法，传入对应的字段就可以了。&gt;&gt;&gt; q.choice_set.create(choice_text='Not much', votes=0)&lt;Choice: Not much&gt;&gt;&gt;&gt; q.choice_set.create(choice_text='The sky', votes=0)&lt;Choice: The sky&gt;&gt;&gt;&gt; c = q.choice_set.create(choice_text='Just hacking again', votes=0)# Choice objects have API access to their related Question objects.&gt;&gt;&gt; c.question&lt;Question: What's up?&gt;# And vice versa: Question objects get access to Choice objects.// 取得所有区这个Question 关联的 Choice的对象&gt;&gt;&gt; q.choice_set.all()&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;&gt;&gt;&gt; q.choice_set.count()3# The API automatically follows relationships as far as you need.# Use double underscores to separate relationships.# This works as many levels deep as you want; there's no limit.# Find all Choices for any question whose pub_date is in this year# (reusing the 'current_year' variable we created above).// 可以通过双下划线，在数据结构中找到关系&gt;&gt;&gt; Choice.objects.filter(question__pub_date__year=current_year)&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;// 删除数据# Let's delete one of the choices. Use delete() for that.&gt;&gt;&gt; c = q.choice_set.filter(choice_text__startswith='Just hacking')&gt;&gt;&gt; c.delete() 这些shell的操作，你以为都只是在内存里操作的话，你就错了。打开你的数据库，你会发现你的这些shell的操作会实际操作到数据库的 系统更多关于shell的操作在这里，你可以自己去查阅 [https://docs.djangoproject.com/en/1.11/ref/models/relations/] [https://docs.djangoproject.com/en/1.11/topics/db/queries/] [https://docs.djangoproject.com/en/1.11/topics/db/queries/#field-lookups-intro] 下面介绍Django的一个牛逼的后台，他叫admin 首先我们得先创建我们的最高权限的用户。 执行python manage.py createsuperuser 123456GhCoder_Site python manage.py createsuperuserUsername (leave blank to use 'parallels'): gonghuanEmail address: 11@11.comPassword: Password (again): Superuser created successfully. 再次执行python manage.py runserver,然后打开http://127.0.0.1:8000/admin/，你就会看到admin的后台登录系统了。 登录进去，你只会看见user,group的模块，那如何把我们之前创建的polls的app，展现在后台呢？方便我编辑数据？ 打开polls/admin.py,并且我们需要告诉admin，Question这个数据类型，admin是有数据接口的，可以控制他。编辑如下代码： 12345from django.contrib import adminfrom .models import Questionadmin.site.register(Question) *此时我们就可以看到我们的Question的配置出现在后台了，并且可以增删改查了。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Python的Django框架搭建前后台[官网教程]]]></title>
    <url>%2F2017%2F05%2F09%2F20170509%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python–不管你之前写过多少其他语言，当你有一天回来写python的时候，你就会觉得“世界是那么的美好！”今天我就来讲讲我是如何用Python的django[https://docs.djangoproject.com] 来搭建后台的： 我是在mac的环境下搭建的，linux也试过，其实搭建环境来说，都差不多,这里就以mac为例子 首先mac或者linux的话，应该是自带python的，如果是win系统的话，你可以自己去下载[https://www.python.org/] 数据库（database）也是很重要的，因为我们想做的是一个健全的前后台系统、后期还需要给移动端提供数据来源，所以我这里选用mysql，我这里偷懒就用了MAMP一键安装，在linux下也有相应的叫LAMP,一步步点击下一步之后就完成了，这里我用的是Apache+Mysql。安装完成之后，你就可以看到mysql的端口、密码、用户名啥的（这里可能有些坑，需要自己去踩，这里就不说了，自行google),这里要弄好，因为我们后续在配置django的时候需要配置。 下面进入正式安装jdango，官方建议通过pip去安装。 1pip install -U pip 如果报错就执行下面的命令：1pip install --upgrade pip 不出意外的话，此时你的pip，应该已经安装好了。下面来安装环境，这里环境，官方的意见是安装virtualenv或者virtualenvwrapper,这里其实我都试过，你也可以试试，这里就用virtualenv [https://virtualenv.pypa.io/en/stable/] , 你也可以自己参考一下virtualenv的官方介绍 [https://virtualenv.pypa.io/en/stable/installation/] :1[sudo] pip install virtualenv 最后执行安装django的命令：1pip install Django 官方给出了严重你是否安装成功，以及安装的版本,当成功打印的时候，就代表已经成功安装了。123&gt;&gt;&gt; import django&gt;&gt;&gt; print(django.get_version())1.11 也可以直接在终端输入1python -m django --version 直接开始项目： 直接在终端输入：此时在当前路径下就会看到我们创建的GhCoder_Site文件夹： 1django-admin startproject GhCoder_Site 文件夹的结构： 123456├── GhCoder_Site│ ├── __init__.py│ ├── settings.py│ ├── urls.py│ └── wsgi.py└── manage.py 这里官方给了一些解释，我觉得很好，有助于我们的理解, 其实我之前都是写php的，深有感触–note: If your background is in plain old PHP (with no use of modern frameworks), you’re probably used to putting code under the Web server’s document root (in a place such as /var/www). With Django, you don’t do that. It’s not a good idea to put any of this Python code within your Web server’s document root, because it risks the possibility that people may be able to view your code over the Web. That’s not good for security.Put your code in some directory outside of the document root, such as /home/mycode. 官方对于每个文件夹以及文件的作用都做了一定的解释，这里我就不解释了很通俗易懂： The outer GhCoder_Site/ root directory is just a container for your project. Its name doesn’t matter to Django; you can rename it to anything you like. manage.py: A command-line utility that lets you interact with this Django project in various ways. You can read all the details about manage.py in django-admin and manage.py. The inner GhCoder_Site/ directory is the actual Python package for your project. Its name is the Python package name you’ll need to use to import anything inside it (e.g. GhCoder_Site.urls). GhCoder_Site/init.py: An empty file that tells Python that this directory should be considered a Python package. If you’re a Python beginner, read more about packages in the official Python docs. GhCoder_Site/settings.py: Settings/configuration for this Django project. Django settings will tell you all about how settings work. GhCoder_Site/urls.py: The URL declarations for this Django project; a “table of contents” of your Django-powered site. You can read more about URLs in URL dispatcher. GhCoder_Site/wsgi.py: An entry-point for WSGI-compatible web servers to serve your project. See How to deploy with WSGI for more details. 下面直接运行下面的命令：1python manage.py runserver 你会得到这样的反馈：123456789101112Performing system checks...System check identified no issues (0 silenced).//请忽略这里You have 13 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.Run 'python manage.py migrate' to apply them.May 09, 2017 - 07:08:16Django version 1.11, using settings 'GhCoder_Site.settings'Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 此时打开浏览器，输入http://127.0.0.1:8000/，你就会看到Welcome to Django” page, in pleasant, light-blue pastel. It worked!，就代表成功了。切换端口：1python manage.py runserver 8080 切换ip、监听所有的ip1python manage.py runserver 0:8000 Django的开发模式都是依赖于一个个app，这一点我非常喜欢，后期就算项目很大，也不会很乱，创建第一个app:1python manage.py startapp polls 结构如下：123456789101112131415161718192021.├── db.sqlite3├── GhCoder_Site│ ├── __init__.py│ ├── __init__.pyc│ ├── settings.py│ ├── settings.pyc│ ├── urls.py│ ├── urls.pyc│ ├── wsgi.py│ └── wsgi.pyc├── manage.py└── polls ├── admin.py ├── apps.py ├── __init__.py ├── migrations │ └── __init__.py ├── models.py ├── tests.py └── views.py 创建第一个views,打开polls/views.py,输入：12def index(request): return HttpResponse("Hello, world, You are in polls app") 现在配置一下路由,到文件polls,创建一个名为urls.py的文件。将之前写的view和这个url对应上：123456from django.conf.urls import url from . import views urlpatterns = [ url(r'^$', views.index, name='index') ] 最后将app的url，写到项目中的urls.py的文件里面去，到GhCoder_Site/urls.py文件里面，添加如下代码：1234567from django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [ url(r'^polls/', include('polls.urls')), url(r'^admin/', admin.site.urls),] 这里关于include的官方介绍： The include() function allows referencing other URLconfs. Note that the regular expressions for the include() function doesn’t have a $ (end-of-string match character) but rather a trailing slash. Whenever Django encounters include(), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing. The idea behind include() is to make it easy to plug-and-play URLs. Since polls are in their own URLconf (polls/urls.py), they can be placed under “/polls/”, or under “/fun_polls/”, or under “/content/polls/”, or any other path root, and the app will still work. 此时你访问http://127.0.0.1:8000/polls/就看到你刚才写的view以及url]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object-C 网管、以及切换AppDelegate的RootViewCtroller]]></title>
    <url>%2F2017%2F05%2F05%2F20170505%2F</url>
    <content type="text"><![CDATA[昨天将最新版1.9.5发布上线。总结一下这一版本中踩过的坑。产品的需求： app中默认是游客身份，随着不同身份的切换，可能需要切换不同的网管。(假如请求的url为: http://www.siji.com/a.php,那么随着身份的切换的话，可能 http://www.siji.com需要修改为http://www.chengke.com)，并且有些请求，是不需要依赖身份的：(比如登录部分请求就是http://www.login.com/login.php、支付部分的请求就是http://www.pay.com/pay.php)。 app中需要区分两种身份(例如 1.司机身份 2.乘客身份)，未来可能还需要更多身份去切换，伴随着身份切换，可能UI上会发生重大的改变，例如：司机身份是UITabBarController为rootViewController的，乘客身份只是(UIViewController+UISlideViewController)侧滑的样式。 之前发布的版本，有一点很重的线程安全的问题，我没有考虑到，现在我已经做了响应的修改了。在关于能够修改字典、数组的方法中我都用到了NSRecursiveLock，从而能够保证线程是安全的。属性的相关安全性，我也查了些资料：[https://zhuanlan.zhihu.com/p/23998703] 解决第一个问题： 首先我这里希望我在app刚进来的时候，就配置好，并且我这里希望他是线程安全，并且方便get/set值。这里我选用单例。并且在系统刚进来的时候就配置, 我已经加入cocoapods了：[https://github.com/Ghstart/GateWayObject]： 12345678910111213141516171819- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[RootWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; //1.设置默认URL，就是其中一种身份对应的URL //2.设置一些URL的映射，不会根据之前身份设置来修改 [GateWayObject sharedInstanceWithDefaultURL:@"https://cz.redlion56.com/gwcz/" ReflectURLS:@&#123; @"user/login.do": @"https://login.redlion56.com/gwlogin/user/login.do", @"uic/user/logout.do": @"https://cz.redlion56.com/gwcz/uic/user/logout.do" &#125;]; // 3. 设置乘客身份对应的网管 [[GateWayObject currentGateWay] setGateWayURL:@"https://cz.redlion56.com/gwcz/" forKeyObject:carownerRole]; // 4.设置乘客对应的网管 [[GateWayObject currentGateWay] setGateWayURL:@"https://sj.redlion56.com/gwsj/" forKeyObject:driverRole];&#125; 123456789// 5.并且还可以根据相应的条件来切换网管 if (xxx) &#123; [[GateWayObject currentGateWay] swichGateWayBaseOn:carownerRole]; &#125; else &#123; [[GateWayObject currentGateWay] swichGateWayBaseOn:driverRole]; &#125; 12345678910// 7.直接可以取得次环境下对应的正确URL[self GET:[[GateWayObject currentGateWay] currentURLBaseOnRelativeURL:url] parameters:parameters success:^(NSURLSessionDataTask *task, id responseObject) &#123; &#125; &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; if (failure &amp;&amp; error.code != -999 &amp;&amp; ![error.localizedDescription isEqualToString:@"已取消"]) &#123; failure(error); &#125; &#125;]; 下面看一下我的.h文件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546@interface GateWayObject : NSObject@property (nonatomic, readonly) NSString *currentRelateURL;///////////-init-///////////////* ** 获得当前的网管 */+ (GateWayObject *)currentGateWay;/* ** 网管实例化方法 ** 默认网关 */+ (GateWayObject *)sharedInstanceWithDefaultURL:(NSString *)url;/* ** 网关实例化 ** 可以配置一些默认的URL对应的一些网关 */+ (GateWayObject *)sharedInstanceWithDefaultURL:(NSString *)url ReflectURLS:(NSDictionary *)reflectURLS;/* ** 设置网关 */- (void)setGateWayURL:(NSString *)url forKeyObject:(id)keyObject;/* ** 设置默认的一些网关，优先级仅次于http/https */- (void)setDefaultRelativeURL:(NSString *)relativeURL fullURL:(NSString *)fullURL;/* ** 根据之前的设置的身份切换网管 ** 返回值为true则切换成功 false失败 */- (BOOL)swichGateWayBaseOn:(id)keyObject;/* ** 取得当前URL */- (NSString *)currentURLBaseOnRelativeURL:(NSString *)url;@end 第二个问题的解决方案，自定义RootWindow,让它集成于 UIWindow，并且覆写，然后自己写一套新的stroyboard，每次身份切换的时候，直接切换keyWindow的rootViewController123456789101112131415161718192021222324252627- (void)setRootViewController:(UIViewController *)rootViewController&#123; // 这里我发现在某些设备上由于push、present之后就不能够正常销毁,这里就需要你去判断，做相应的pop、dismiss之后，在去setRootViewController // 但是后来又发现系统的navigation的栈，栈的弹出需要时间才能弹出，不是立刻弹出啊的，这里就很鸡肋了，目前我还没想到啥解决方案。 [UIViewController fastToRootVC]; //remove old rootViewController's sub views for (UIView* subView in self.rootViewController.view.subviews) &#123; [subView removeFromSuperview]; &#125; //remove old rootViewController's view [self.rootViewController.view removeFromSuperview]; //set new rootViewController [super setRootViewController:rootViewController]; //remove empty UILayoutContainerView(s) remaining on root window for (UIView *subView in self.subviews) &#123; if (subView.subviews.count == 0) &#123; [subView removeFromSuperview]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Object-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PHP7的新坑]]></title>
    <url>%2F2017%2F03%2F27%2F20170327%2F</url>
    <content type="text"><![CDATA[距离上次写PHP已经过了2、3年了，最近闲来无事，想再整整PHP。我是通过mac安装了虚拟机，Ubuntn16.04的版本，在安装PHP环境的时候，就发现很多坑，一些小问题google可以查到的我这里就不说了，在安装完Apache、PHP、Mysql的时候，并且安装完Phpmyadmin的时候，会报错： 1The mysqli extension is missing.... google一搜就会发现：1sudo apt-get install php5-mysql 这里对应的php5的安装，那你这里是写php7.0-mysql还是写php7.1-mysql就需要看你安装php的版本号了。你可以通过&lt;?php echo phpinfo();?&gt;、也可以通过php --version可以知道，你需要安装的是多少。在调用mysql的时候，之前我记得我很久之前就一直都在使用mysql_connect()这个函数来连接数据库，但是最近我发现我通过这个函数、没有任何的反馈，通过try/catch也没有任何error、这个问题一直纠结了好久，今天才发现原来在php7的版本的时候，已经完全废弃了这个函数了，而是已经使用mysqli_connect(),这里是PHP官方手册的说明：1234Warning本扩展自 PHP 5.5.0 起已废弃，并在自 PHP 7.0.0 开始被移除。应使用 MySQLi 或 PDO_MySQL 扩展来替换之。参见 MySQL：选择 API 指南以及相关 FAQ 来获取更多信息。用以替代本函数的有：mysqli_connect()PDO::__construct() 所以我这里就用mysqli_connect()来替换，我这里建立一个video的库，并且建了一个test的表：123456789101112131415161718192021222324$servername = "localhost";$username = "root";$password = "123456789";$dbname = "video";// Create connection$conn = new mysqli($servername, $username, $password, $dbname);// Check connectionif ($conn-&gt;connect_error) &#123; die("Connection failed: " . $conn-&gt;connect_error);&#125; $sql = "SELECT * FROM test";$result = $conn-&gt;query($sql);if($result -&gt; num_rows &gt; 0) &#123; while($row = $result -&gt; fetch_assoc()) &#123; echo "Name: ".$row["name"]."-Status: ".$row["status"]."-Time:".$row["time"]."&lt;br&gt;"; &#125;&#125; else &#123; echo 'no datas';&#125;$result-&gt;close();]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新Reveal2的一些问题]]></title>
    <url>%2F2017%2F03%2F15%2F20170315%2F</url>
    <content type="text"><![CDATA[最近任务也不是很多，尽量逼自己把每天学的一些的东西都记录下来。 这张图来自简书APP，也是一个朋友闻起来来的，他说这是在无数据、无网络的状态下就会出现这样的界面，这个是怎么做到的呢？ 1 . 我当时想了一下，还是觉得要用collectionView来实现吧，其实热门文章的内容，其实自己看就会发现，他就一种cell格式，而热门专题应该就是用collectionview来做的吧。 2 .后来一拍脑子觉得不对啊，这tm得多烦啊，而且这个仅仅只是无数据的一种页面的展示啊，要我做，那就直接一张image遮罩着不就行了。 猜想了半天还是用Reveal来看一下吧。1 .由于很长时间不用Reveal了，而且我之前的Reveal还是1.x的版本，然后用越狱机器一看，一直导入失败，一直在报这个错误(❌) The operation couldn’t be completed. The app is linked against an older version of the Reveal library. You may need to update the Reveal library in your app. 2 .后来发现之前导入到机器中的一个libReveal.dylib的文件以及找不到了，这下，我tm傻眼了，我一直以为让我更新一下这个所谓的动态库呢！ 后来google了一下，发现了官方的回复： We no longer ship a dynamic library starting with Reveal 2, we include an iOS 8+ framework instead. The good news is that you should be able to make a copy of, and rename the framework’s binary (RevealServer.framework/ReveaServer) to libReveal.dylib and then follow the instructions as before 最后还发现几个好玩的东西： 可以发现真的就如我的猜想，他其实这些都是之前就定死的一个image，遮罩在上面的，其他也就不用说了。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Reveal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试Swift搭建服务器-建立自己的网站]]></title>
    <url>%2F2017%2F02%2F25%2F20170225%2F</url>
    <content type="text"><![CDATA[学习Paul大神的swift-server，我也尝试用Swift来搭建自己的网站。这里主要依赖的是IBM开源的Kitura框架。 环境搭建 （Mac下） 因为我们是在自己的mac上搭建环境，所以需要下载Docker[https://docs.docker.com/docker-for-mac/] 这个软件，这个软件的作用就相当于一台看不见的虚拟机，能够在mac上运行Linux。 下载完成之后，建立根目录文件夹。 1234cd ~/Desktopmkdir servercd serverdocker run -itv $(pwd):/projects --name projects -w /projects -p 8089:8089 -p 8090:8090 -p 5984:5984 twostraws/server-side-swift /bin/bash 3 . 这里docker开头的命令，是让doker软件来运行的，其中’/projects’ 指的是文件内建立以projects开头的文件默认指向的是当前的文件路径，并且建立的8090、5984这两个端口。 4 . 建立好之后你就会看到类似如下的返回值： 1root@f2429f0045db:/projects# 建立第一个文件 运行如下命令： 1234cd ~/Desktop/servermkdir project1cd project1swift package init --type executable 最后一行命令可能比较困惑，其实这行命令就是告诉swift package（这里的swift package相当于OC中的cocoapods、或者NodeJS中的npm一样）,我们需要建立一个新的项目，’–type executable‘的意思是我们希望建立一个独立的部分。看到如下返回值就代表成功了：123456Creating executable package: project1Creating Package.swiftCreating .gitignoreCreating Sources/Creating Sources/main.swiftCreating Tests/ 2 .运行： 1swift build 3 . 再运行 1.build/debug/project1 当看到”Hello world!”就代表已经成功了。 4 .再运行 1swift package generate-xcodeproj 此时用Xcode打开刚刚生成的project1.xcodeproj,切换project1&gt;Sources&gt;project1,当控制台中打印“Hello world!” 5 . 找到Main.swift文件，更换内容，我们引入路由模块，并且实例化，并且监听8090端口 123456import Kituralet router = Router()Kitura.addHTTPServer(onPort: 8090, with: router)Kitura.run() 此时打开浏览器”http://localhost:8090&quot;,大功告成！！！ 环境搭建 （Linux下） 先下载适合你Linux版本的Swift的版本[https://swift.org/download/] 其实这里Kitura的官网给出了教程，你也可以按照官方的教程走下去。[http://www.kitura.io/en/starter/settingup.html] 12$ sudo apt-get update$ sudo apt-get install clang libicu-dev libcurl4-openssl-dev libssl-dev 1$ export PATH=&lt;path to uncompressed tar contents&gt;/usr/bin:$PATH 2 .这里已经介绍解释的很清楚了，就是将&lt;&gt;以及其中的内容替换成你刚才下载并解压下来的Swift包路径，假设我的路径为/home/gh/swift-3.0.2-release/, 那就可以在终端运行： 1$ export PATH=/home/gh/swift-3.0.2-release/usr/bin:$PATH 3 .紧接着运行,看到正常的返回就代表已经安装正常。 1swift --version 4 .下面的方法步骤就和之前在Mac上的配置是一样的了，你也可以参考Kitura的教程[http://www.kitura.io/en/starter/gettingstarted.html]]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习阿里开源项目BeeHive(三)]]></title>
    <url>%2F2016%2F12%2F01%2F20161201%2F</url>
    <content type="text"><![CDATA[最后总结一下整个BeeHive项目的搭建。以及我看完之后的一些质疑和想法，有些作者以及给出了回答，会在下一版本的更新中进行修改。 先贴上我自己画的一个提纲 首先，为什么每个ViewController都需要配备一个配备一个Module的文件？因为他需要通过+(void)load{}的方法，动态的将moduleInfo的信息存储下来，这里是存储在BHModuleManager文件中的self.BHModules此时这里存储的都是字符串，还没有创建为实例对象。为什么有些module的文件中没有load方法，但是他还是在启动之前也注册进去了呢？答：因为这里作者都是通过宏的的形式，来快速实现加载的信息，本质上和+(void)load{}是一样的。BH_EXPORT_MODULE(NO) 这里在官方的demo中看到TestAppDelegate进行了ModuleConfigName、ServiceConfigName的设置，不设置可以吗？答：可以！！这里在BHContext对象实例化的时候，已经默认设置了初始值了。 这里假如我有新的功能，我应该往哪里去添加呢？答：这里只是我的猜想-&gt;应该在BHContext中去添加，因为在BHContext实例化的时候，就顺带实例化了一系列的对象：BHShortCutItem、BHOpenURLItem、BHNotificationItem、BHUserActivity、BHConfig,并且这些对象都是单例，这里我保持我的态度。这里的if调试时作者的笔误，他会在下一版本更新 if ([BHInstance isKindOfClass:[BHContext class]]) {}1234567891011121314151617181920-(instancetype)init&#123; self = [super init]; if (self) &#123; self.modulesByName = [[NSMutableDictionary alloc] initWithCapacity:1]; self.servicesByName = [[NSMutableDictionary alloc] initWithCapacity:1]; self.moduleConfigName = @"BeeHive.bundle/BeeHive"; self.serviceConfigName = @"BeeHive.bundle/BHService";#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80400 self.touchShortcutItem = [BHShortcutItem new];#endif self.openURLItem = [BHOpenURLItem new]; self.notificationsItem = [BHNotificationsItem new]; self.userActivityItem = [BHUserActivityItem new]; &#125; return self;&#125; 1234567891011121314+(instancetype) shareInstance&#123; static dispatch_once_t p; static id BHInstance = nil; dispatch_once(&amp;p, ^&#123; BHInstance = [[[self class] alloc] init]; if ([BHInstance isKindOfClass:[BHContext class]]) &#123; ((BHContext *) BHInstance).config = [BHConfig shareInstance]; &#125; &#125;); return BHInstance;&#125; 系统是在什么时候载入本地的组件信息的呢？答：是在哎BeeHive调用setContext对象的时候，进行调用的。并且这里通过context中的文件名，进行拼接，返回plist文件的信息。 比起在这里将self.BHModules 文件信息换成了响应的实例对象 那看到各个Module都会调用modSetUp、modInit类似的方法，那这些方法是在什么时候调用的？答：是在调用父类的Appdelegate的方法的时候调用的， 初了一些主动调用的上面这些方法，那什么时候才会调用系统的方法，类似进入后台、被挂起、进入前台。答：这是在appdelegate的响应方法调用的时候，也会调用。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习阿里开源项目BeeHive(二)]]></title>
    <url>%2F2016%2F11%2F28%2F20161128%2F</url>
    <content type="text"><![CDATA[紧接着前面那篇文章，回到BHAppDelegate.m的文件里面的1- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 之前已经把所有的timeProdiler的这个类的作用，实例，已经public的方法都已经说了。在这个方法的实现中，作者还做了另外一件事情。 123456[[BHModuleManager sharedManager] tiggerEvent:BHMSetupEvent];[[BHModuleManager sharedManager] tiggerEvent:BHMInitEvent];dispatch_async(dispatch_get_main_queue(), ^&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMSplashEvent];&#125;); BHModuleManager从字面上理解应该就是管理模块之前调用逻辑的意思，并且在BHModuleManager.m中，我们可以看出来这个类也是个单例。 在init之后，紧接着就是调用- (void)tiggerEvent:(BHModuleEventType)eventType;的方法。 在这个方法的实现中可以看到一个很长的swich语句，遍历你传入的一个枚举类型，来做一系列的事情。 先看在didFinishLaunch中，第一次调用这个方法，传入的参数为BHMSetupEvent。 123case BHMSetupEvent:[self handleModuleEvent:kSetupSelector];break; 123456789101112131415- (void)handleModuleEvent:(NSString *)selectorStr&#123; SEL seletor = NSSelectorFromString(selectorStr); [self.BHModules enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([moduleInstance respondsToSelector:seletor]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks" [moduleInstance performSelector:seletor withObject:self.wholeContext];#pragma clang diagnostic pop [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@"%@ --- %@", [moduleInstance class], NSStringFromSelector(seletor)]]; &#125; &#125;];&#125; 可以看到传入了一个字符串作为入参，而这个参数写在这个文件的.m中。static NSString *kSetupSelector = @&quot;modSetUp:&quot;;写死了。 紧接着在handleModuleEvent的实现中，通过runtime的NSSelectorFromString的方法将字符串转化为SEL的类型。 再枚举BHModules数组，从枚举中我们发现，不是所有的object对象都添加在BHModules的MutableArray中，这些object的对象必须要遵守id&lt;BHModuleProtocol&gt;的协议。 查询数组中有没有对象可以响应这个方法的，如果有的话，就调用这个方法，并且开始reordTime。 并且为了消除编译器所报的警告，可以通过添加#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;,来消除warning。 紧接着调用了同一个方法，却传入了不同的参数1234567[[BHModuleManager sharedManager] tiggerEvent:BHMInitEvent]; case BHMInitEvent: //special [self handleModulesInitEvent]; break; 123456789101112131415161718192021222324252627282930313233- (void)handleModulesInitEvent&#123; [self.BHModules enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123; __weak typeof(&amp;*self) wself = self; void ( ^ bk )(); bk = ^()&#123; __strong typeof(&amp;*self) sself = wself; if (sself) &#123; if ([moduleInstance respondsToSelector:@selector(modInit:)]) &#123; [moduleInstance modInit:sself.wholeContext]; &#125; &#125; &#125;; [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@"%@ --- modInit:", [moduleInstance class]]]; if ([moduleInstance respondsToSelector:@selector(async)]) &#123; BOOL async = [moduleInstance async]; if (async) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; bk(); &#125;); &#125; else &#123; bk(); &#125; &#125; else &#123; bk(); &#125; &#125;];&#125; 首先循环遍历self.BHModules这个数组对象，先用Timer 开始记录下init方法的时间。 判断数组中的元素是否响应async的方法, 这个- (BOOL)async;的方法定义在BHModuleProtocol中，如果响应了这个方法，就取得这个方法的返回值,从字面上判断这个变量记录了是否运行在多线程中，这里我只是个猜测。 如果是在多线程中，就回到主线程中来执行上面所定义的block：void ( ^ bk )();，如果不是的话或者没有响应async,都直接运行这个block，应该默认状态下就是主线程了。 从代码上看来，就是不管在什么线程或者是否响应async的方法，上面的block是肯定要执行的。 block中所做的事情也很简单，就是判断这个元素对象是否响应- (void)modInit:(BHContext *)context;,这个protocol的代理方法，如果响应的话，就会执行这段代码，至于这里的BHContext的对象，我目前没看到在哪里传入进来，这里只看到了一个Setter的方法。 12345- (void)setWholeContext:(BHContext *)wholeContext&#123; _wholeContext = wholeContext; self.modulesConfigFilename = _wholeContext.moduleConfigName;&#125; 最后执行的一个方法123dispatch_async(dispatch_get_main_queue(), ^&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMSplashEvent]; &#125;); 这个方法和[self handleModuleEvent:kSetupSelector];一样，除了传入的参数不同，响应的方法不同，其他都是一样。 这里还要强制要求这个方法的调用一定要在主线程中。 这样就已经把自定义的BHAppDelegate的主要几个实现已经介绍了一下，下面来看看demo中的实现。在TestAppDelegate的didFinishLaunchingWithOptions的方法中。这四行代码涉及到了同一个对象BHContext,从字面上判断应该是上下文对象，应该是对象之间的调用会需要用它来记录一下，这里是我的猜测1234[BHContext shareInstance].application = application;[BHContext shareInstance].launchOptions = launchOptions;[BHContext shareInstance].moduleConfigName = @"BeeHive.bundle/BeeHive";//可选，默认为BeeHive.bundle/BeeHive.plist[BHContext shareInstance].serviceConfigName = @"BeeHive.bundle/BHService"; 在BHContext.m的代码中可以看出来，这个对象也是个单例，在这个单例的init方法中：1234567891011121314151617181920-(instancetype)init&#123; self = [super init]; if (self) &#123; self.modulesByName = [[NSMutableDictionary alloc] initWithCapacity:1]; self.servicesByName = [[NSMutableDictionary alloc] initWithCapacity:1]; self.moduleConfigName = @"BeeHive.bundle/BeeHive"; self.serviceConfigName = @"BeeHive.bundle/BHService";#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80400 self.touchShortcutItem = [BHShortcutItem new];#endif self.openURLItem = [BHOpenURLItem new]; self.notificationsItem = [BHNotificationsItem new]; self.userActivityItem = [BHUserActivityItem new]; &#125; return self;&#125; 定义了modulesByName、servicesByName为NSMutableDictionary的对象，只能容纳一个元素。 定义了moduleConfigName、serviceConfigName为String的对象。 在系统大于8.0.4的时候，支持3D touch的话，会额外设置一个对象，这个对象里面就两个对象，一个是UIApplicationShortcutItem *shortcutItem;, 一个是typedef void (^shortcutItemCompletionHandler)(BOOL);,都是在调用3D touch的时候会调用到。 涉及到了另一个对象BHOpenURLItem,这个对象含有三个变量NSURL *openURL;,NSString *sourceApplication;,NSDictionary *options;。 设计了通知的一个对象BHNotificationsItem,这个对象含有五个变量：NSError *notificationsError;,NSData *deviceToken;,NSDictionary *userInfo;,typedef void (^notificationResultHandler)(UIBackgroundFetchResult);,UILocalNotification *localNotification;。 还有一个涉及到用户信息的一个对象：BHUserActivityItem,含有四个变量：NSString *userActivityType;,NSUserActivity *userActivity;,NSError *userActivityError;, typedef void (^restorationHandler)(NSArray *);。 总体看来这个对象完成的功能很多，并且以后很多类似3D touch 这种针对某种系统的新功能都可以在这个类中来拓展，而且很方便使用。 在本类的shareInstance的方法中：123456dispatch_once(&amp;p, ^&#123; BHInstance = [[[self class] alloc] init]; if ([BHInstance isKindOfClass:[BHContext class]]) &#123; ((BHContext *) BHInstance).config = [BHConfig shareInstance]; &#125; &#125;); 这里在设置config的变量之前判断if ([BHInstance isKindOfClass:[BHContext class]]) {}这个说实话，我没太明白这么做的原因是什么，上面都已经BHInstance = [[[self class] alloc] init];调用了，那这个判断还有什么意思吗？并且这个对象是继承的NSObject的对象。 这里的BHConfig对象，从代码上看也是一个单例，并且定义了一系列存储，判断是否存在，在.m的文件中定义了一个NSMutableDictionary *config;的对象，统一存储在这个里面，可以是对象类型，也可以是一些基础的数据类型。 1234[BHContext shareInstance].application = application;[BHContext shareInstance].launchOptions = launchOptions;[BHContext shareInstance].moduleConfigName = @"BeeHive.bundle/BeeHive";//可选，默认为BeeHive.bundle/BeeHive.plist[BHContext shareInstance].serviceConfigName = @"BeeHive.bundle/BHService"; 现在可以看出来，首先这4行代码就是简单的赋值的动作，有些类的值你可以不赋值，类似的有：moduleConfigName,serviceConfigName,因为在对象实例化的时候，就已经进行了赋值。 紧接着在下面的两行代码中涉及到了一个新的对象：12[BeeHive shareInstance].enableExpection = YES;[[BeeHive shareInstance] setContext:[BHContext shareInstance]]; 123456789101112#pragma mark - Private-(void)setContext:(BHContext *)context&#123; _context = context; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self loadStaticServices]; [self loadStaticModules]; &#125;);&#125; 首先在BeeHive.m的文件中，可以看出来，这个对象也是个单例。 紧接着在public的属性中，设置了全局了BHContext的对象，并且将它保存下来，并且在这里复写了Setter的方法,并且在Setter方法的时候,又调用了两个新的方法，并且这两个方法有且仅调用一次。 123456789-(void)loadStaticServices&#123; [BHServiceManager sharedManager].enableException = self.enableExpection; [[BHServiceManager sharedManager] setWholeContext:self.context]; [[BHServiceManager sharedManager] registerLocalServices];&#125; 在loadStaticServices的方法中，又创建了一个BHServiceManager的单例对象。 在BHServiceManager中设计了enableException的属性。 在BHServiceManager中设置了BHContext的对象，将BHContext对象也能够在BHServiceManager中能够持有这个对象。 最后调用到了loadStaticServices中的registerLocalServices的方法。方法如下： 123456789101112131415- (void)registerLocalServices&#123; NSString *serviceConfigName = self.wholeContext.serviceConfigName; NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@"plist"]; if (!plistPath) &#123; return; &#125; NSArray *serviceList = [[NSArray alloc] initWithContentsOfFile:plistPath]; [self.lock lock]; [self.allServices addObjectsFromArray:serviceList]; [self.lock unlock];&#125; 通过传入的context找到serviceConfigName的变量，拼接成plist文件名，如果项目中确实存在的话，就打开这个文件的内容。 这里通过锁，来将plist文件中取到的变量NSArray，存储到allServices私有变量中去。 另一个方法：12345678- (void)loadStaticModules&#123; [[BHModuleManager sharedManager] setWholeContext:self.context]; [[BHModuleManager sharedManager] loadLocalModules]; [[BHModuleManager sharedManager] registedAllModules];&#125; 上面已经分析过了，这个BHModuleManager也是一个单例。首先将全局的context的变量设置上去，并且将context中的moduleConfigName的变量赋值给modulesConfigFilename。 将刚才的变量modulesConfigFilename拼接成plist文件，然后将取得的数据放入到数组中。 在registedAllModules的方法中，听过比较字典中的moduleLevel的value值，进行比较、排序，然后通过枚举，挨个实例化对象之后，在存入BHModules的可变数组中。 1id&lt;HomeServiceProtocol&gt; homeVc = [[BeeHive shareInstance] createService:@protocol(HomeServiceProtocol)]; 123456789101112131415161718192021222324252627282930313233- (id)createService:(Protocol *)service&#123; id implInstance = nil; if (![self checkValidService:service] &amp;&amp; self.enableException) &#123; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@"%@ protocol does not been registed", NSStringFromProtocol(service)] userInfo:nil]; &#125; Class implClass = [self serviceImplClass:service]; implInstance = [[implClass alloc] init]; if (![implInstance respondsToSelector:@selector(singleton)]) &#123; return implInstance; &#125; NSString *serviceStr = NSStringFromProtocol(service); if ([implInstance singleton]) &#123; id protocol = [[BHContext shareInstance].servicesByName objectForKey:serviceStr]; if (protocol) &#123; return protocol; &#125; else &#123; [[BHContext shareInstance].servicesByName setObject:implInstance forKey:serviceStr]; &#125; &#125; else &#123; [[BHContext shareInstance].servicesByName setObject:implInstance forKey:serviceStr]; &#125; return implInstance;&#125; 紧接着调用了BeeHive的public的方法：- (id)createService:(Protocol *)proto;传入一个protocol，返回一个id类型的对象。 其实这里self checkValidService:service值是判断之前registerLocalServices这个里面有没有遵循这个protocol的，假如没有，并且开启self.enableException的话，他就会抛出一个NSException。 否则就会遵循这个protocol的类，并且返回。 判断这个类有没有遵循BHServiceProtocol这个协议的singleton,并且实现，假如没有实现的话，就直接返回这个对象，不再往下执行了。 根据这个protocol在[BHContext shareInstance].servicesByName字典中查找有没有对应value值，如果有的话，就直接放回这个对象，如果没有的话，放回对象的同时，将这个protocol存储到这个[BHContext shareInstance].servicesByName字典中。 最后讲个homeVC设置为Appdelegate的RootWindow。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习阿里开源项目BeeHive(-)]]></title>
    <url>%2F2016%2F11%2F25%2F20161125%2F</url>
    <content type="text"><![CDATA[学习阿里开源 BeeHive ,每次学习别人写的框架，或者好东西都会让自己学到很多东西，废话不多说，直接扯代码。源码中的几个小问题：1. 在Example中，程序的入口文件TestAppDelegate,你就惊奇地发现，他不是继承了UIAppDelegate，也不是继承了UIAppDelegate的子类，而是自己写了一个&quot;AppDelegate&quot; 1@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt; 在 BHAppDelegate.m的文件中，我们发现这个类实现了很多appDelegae的很多代理方法 123456789101112131415161718192021222324- (void)applicationWillResignActive:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMWillResignActiveEvent];&#125;- (void)applicationDidEnterBackground:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMDidEnterBackgroundEvent];&#125;- (void)applicationWillEnterForeground:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMWillEnterForegroundEvent];&#125;- (void)applicationDidBecomeActive:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMDidBecomeActiveEvent];&#125;- (void)applicationWillTerminate:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMWillTerminateEvent];&#125; ####当然这里先忽略，我们一点点说： 1234567891011121314151617181920- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;#ifdef DEBUG self.timeProdiler = [BHTimeProfiler sharedTimeProfiler];#endif [[BHModuleManager sharedManager] tiggerEvent:BHMSetupEvent]; [[BHModuleManager sharedManager] tiggerEvent:BHMInitEvent]; dispatch_async(dispatch_get_main_queue(), ^&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMSplashEvent]; &#125;);#ifdef DEBUG [self.timeProdiler printOutTimeProfileResult]; [self.timeProdiler saveTimeProfileDataIntoFile:@"BeeHiveTimeProfiler"];#endif return YES;&#125; 在debug状态下，这个程序启动的方法创建了一个timeProdiler的实例，并且在return之前执行了timeProdiler的两个方法。进入到 BHTimeProfiler.m的文件里面发现，这个类是一个单例。在这个类的init的方法中发现12345678910- (instancetype)initTimeProfilerWithMainKey:(NSString *)mainKey&#123; self = [super init]; if (self) &#123; _mainIdentifier = [mainKey copy]; _lastTime = CACurrentMediaTime(); _recordStartTime = CACurrentMediaTime(); &#125; return self;&#125; 用一个字符串对私有的_mainIdentifier的字符串类型进行了赋值。 创建了一个时间的值赋给了_lastTime。 创建了一个时间的值赋给了_recordStartTime。这里的时间类型并没有用NSDate去实例化，而是用了CACurrentMediaTime，这个时间在设备上所有进程都是全局的，并且在设备休眠的状态的时候，这个值会暂停 123456789- (void)recordEventTime:(NSString *)eventName&#123;#ifdef DEBUG NSString *keyName = [eventName copy]; [self.identifiers addObject:keyName]; [self.timeDataDic setObject:@(CACurrentMediaTime()) forKey:keyName];#endif&#125; 只有在debug的状态下调用这个public的方法才有意义。这个方法很简单，其实就是用mutableArray来存储keyName,并且将时间的值作为value存储在MutableDictionary中。这其实没什么好说的，但是这里有一点却引起了我的注意： 12345678#if __has_feature(objc_generics)# define TM__GENERICS(class, ...) class&lt;__VA_ARGS__&gt;#else# define TM__GENERICS(class, ...) class#endif#define TMMutableArrayWith(valueType) TM__GENERICS(NSMutableArray, valueType)#define TMMutableDictionaryWith(keyType, valueType) TM__GENERICS(NSMutableDictionary, keyType, valueType) __has_feature(objc_generics)判断是否支持Obj-C泛型的特征。 ...表示，这个表示符里面可以接受0个，或者1个，或者多个参数。 除了第一个class的参数，其他的参数作为一个整体在__VA_ARGS__里面返回。 1234567891011121314- (void)printOutTimeProfileResult&#123;#ifdef DEBUG for (NSString *eventName in self.identifiers) &#123; NSAssert([self.timeDataDic objectForKey:eventName] != nil &amp;&amp; [[self.timeDataDic objectForKey:eventName] isKindOfClass:[NSNumber class]], @"Save Wrong Type TimeStamp"); CFTimeInterval current = [[self.timeDataDic objectForKey:eventName] doubleValue]; printf("[%s] time stamp: %gms and execute for %gms -&gt; \n", [eventName UTF8String], (current - self.recordStartTime) * 1000, (current - self.lastTime) * 1000); self.lastTime = current; &#125;#endif&#125; 遍历keyName的数组，拿到每个keyName，先去字典中找对应的时间值，假如没有的话，就只会断点断住。 算出现在的时间值，与lastTime,recordTime的值得差值。 最后加lastTime的值重新设置为当前的值。 1234567891011121314151617181920212223242526272829- (void)saveTimeProfileDataIntoFile:(NSString *)fileName&#123; NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *filePath = [documentPath stringByAppendingPathComponent:[fileName stringByAppendingPathExtension:@"txt"]]; NSLog(@"TMTimeProfiler::SaveFilePath is %@", filePath); BOOL res=[[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:nil]; if (!res) &#123; return; &#125; NSFileHandle *handle = [NSFileHandle fileHandleForWritingAtPath:filePath]; for (NSString *eventName in self.identifiers) &#123; CFTimeInterval current = [[self.timeDataDic objectForKey:eventName] doubleValue]; NSString *output = [NSString stringWithFormat:@"%@ time stamp %g and execute for %g\n", eventName, current, (current - self.lastTime) * 1000]; [handle writeData:[output dataUsingEncoding:NSUTF8StringEncoding]]; self.lastTime = current; &#125; [handle closeFile];&#125; 这个函数的作用就是传入一个文件的名字，然后将启动时间，record时间，记录下来，这个没什么好说的。 123456789101112131415161718- (void)postTimeProfileResultNotification&#123; NSMutableArray *logArray = [NSMutableArray array]; for (NSString *eventName in self.identifiers) &#123; CFTimeInterval current = [[self.timeDataDic objectForKey:eventName] doubleValue]; [logArray addObject: @&#123;@"eventName":eventName,@"costTime": @((current - self.lastTime) * 1000)&#125;]; self.lastTime = current; &#125; [[NSNotificationCenter defaultCenter] postNotificationName:kTimeProfilerResultNotificationName object:nil userInfo:@&#123;kNotificationUserInfoKey:logArray&#125;];&#125; 1.用NSNotificationCenter，将上次lastTime与现在时间的差值作为NSNotificationCenter中的userInfo的参数传输出去。这样只要监听这个NSNotificationCenter，你每次post就能接受到这个全局的通知。光这一个时间的统计功能，产品、技术上就能做好多文章。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建私有的Cocoapods]]></title>
    <url>%2F2016%2F10%2F28%2F20161028%2F</url>
    <content type="text"><![CDATA[创建私有Cocoapods,最近一直想将自己的App模块化，就想就App拆成每个模块组件，比如：登录模块、网络模块、消息模块、用户中心模块…但是基于这些想法，我首先要先搞定私有化Cocoapods的问题，这样团队中新人，想调用的时候，就能够快速，便捷的调用了，只需要 pod xxx 1.先到自己的git账号，创建一个新的仓库 ，我们取名字 GH 2.开始终端，找到一个合适的位置： 1cd ~/Desktop 3.初始化pod 1pod lib create GH 4.接着系统会问一下问题，你可以自己按照项目需求来回答，也可以参照我的 123456789101112131415What language do you want to use?? [ Swift / ObjC ] &gt; ObjCWould you like to include a demo application with your library? [ Yes / No ] &gt; YesWhich testing frameworks will you use? [ Specta / Kiwi / None ] &gt; NoneWould you like to do view based testing? [ Yes / No ] &gt; NoWhat is your class prefix? &gt; GG 5.修改一下pod的配置文件,pod的配置文件应该都是一样的后缀名，我这里叫 Gh.podspec steps1.这里我先讲description的描述内容注释掉123#s.description = &lt;&lt;-DESC#TODO: Add long description of the pod here.# DESC 2.修改homepage的路径，在第24行1s.homepage = 'https://github.com/Ghstart/Gh' 3.修改git的路径，在第28行1s.source = &#123; :git =&gt; 'https://github.com/Ghstart/Gh.gi t', :tag =&gt; s.version.to_s &#125; 5.保存好退出，再次进入到那个文件夹中，将文件内容提交到github上,我这里选择的是命令的方式，你也可以用github客户端 1234567cd Ghgit initgit remote add origin https://github.com/Ghstart/GH.git // 这个路径在你刚才新建仓库的那个页面就能找到git add .git commit -m 'Gh first creats private own cocoapods'git tag 0.1.0 // 这里的0.1.0在刚才的配置文件里有，对应起来就好了git push -u origin master --tags 最后再去你刚才新建仓库的页面刷新一下，就会发现奇迹。。 现在开始添加自己的类 找到存放类的目录下，/Users/自己的mac名字/Desktop/Gh/Gh/Classes，在这个文件夹下面，你会发现一个名字叫做ReplaceMe.m，这个真是太贴心了，cocoapods都已经为我们想到了，在这里你先删除这个类，然后添加自己想要的类，然后在走一下下面的命令。 我觉得这里，你既然已经修改了内容，或者想发布第一版本，那么修改配置文件的tags修改为0.1.1 1234git add .git commit -m"add files"git tag 0.1.1git push -u origin master --tags 现在到自己的github页面熟悉一下，就会发现自己创建的0.1.1的版本，以及新添加的文件。下面我们需要将我们自己创建的这个cocoapods提交给cocoapods审核，并且发布。 12pod lib lint Gh.podspec // 认证通过pod trunk push // 提交 123456在最后 pod trunk push 时候如果报错 如：[!] Authentication token is invalid or unverified. Either verify it with the email that was sent or register a new session.这说明你之前的认证token已经失效了，重新注册一下就好了，输入以下命令： pod trunk register gonghuan2020@gmail.com 'gonghuan'然后在重新 pod trunk push 就可以了。 123456如果弹 [!] The spec did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it).pod trunk push --allow-warnings如果弹 You can use the `--no-clean` option to inspect any issue.pod lib lint GateWayObject.podspec --allow-warnings --no-clean 大功告成！！这里cocoapods是一个很关键的问题，尤其你刚跟新pod或者xcode，那问题会很多，建议出现一些奇葩的问题，可以先卸载cocoapods，然后再装最新的稳定版本。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 实战(-)]]></title>
    <url>%2F2016%2F10%2F21%2F20161021%2F</url>
    <content type="text"><![CDATA[实战(-) React-Native 重写红狮物流App的项目。下面的的几次博客我会以完成一个现有的项目，将它整体都用React重写。项目我已经上传到github[https://github.com/Ghstart/HongshiWuliuRN]首先找到index.ios.js文件，由于我们的app的架构就是主流的tab的这种，所以我这里用到了TabBarIOS的主件，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, TabBarIOS&#125; from 'react-native';import Task from './ios_views/task';import Goods from './ios_views/goods'import Home from './ios_views/home'import Message from './ios_views/message'import Setting from './ios_views/setting'class HongshiWuLiuRN extends Component &#123; constructor() &#123; super(); this.state = &#123; selected: 'home' &#125; &#125; _renderView(moduleName) &#123; switch (moduleName) &#123; case 'task': return ( &lt;Task/&gt; ); break; case 'goods': return ( &lt;Goods/&gt; ); break; case 'home': return ( &lt;Home/&gt; ); break; case 'message': return ( &lt;Message/&gt; ); break; case 'setting': return ( &lt;Setting/&gt; ); break; default: return ( &lt;View&gt;&lt;/View&gt; ); break; &#125; &#125; render() &#123; return( &lt;TabBarIOS tintColor = '#e23f42' &gt; &lt;TabBarIOS.Item title = "任务" selected = &#123; this.state.selected === 'task' &#125; icon = &#123;require('./images/mission@2x.png')&#125; selectedIcon=&#123;require('./images/mission-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'task' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title = "货源" selected = &#123; this.state.selected === 'goods' &#125; icon = &#123;require('./images/goods@2x.png')&#125; selectedIcon=&#123;require('./images/goods-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'goods' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title = "首页" selected = &#123; this.state.selected === 'home' &#125; icon = &#123;require('./images/home@2x.png')&#125; selectedIcon=&#123;require('./images/home-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'home' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title = "消息" selected = &#123; this.state.selected === 'message' &#125; icon = &#123;require('./images/news@2x.png')&#125; selectedIcon=&#123;require('./images/news-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'message' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title = "设置" selected = &#123; this.state.selected === 'setting' &#125; icon = &#123;require('./images/user@2x.png')&#125; selectedIcon=&#123;require('./images/user-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'setting' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123;&#125;);AppRegistry.registerComponent('HongshiWuLiuRN', () =&gt; HongshiWuLiuRN); 首先你先不要运行，我先解释一下几点比较重要的问题： 引入系统主件(关于系统主件，你可以直接copy就好，这里我的意见就是官方建议那种写法，你就以这种写法为主)、第三方主件、以及自己定义的主件(这里一定要理清楚自己写的主件的路径)。 12345678910111213141516// 引入系统主件import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, TabBarIOS&#125; from 'react-native';// 引入自定义的主件import Task from './ios_views/task';import Goods from './ios_views/goods'import Home from './ios_views/home'import Message from './ios_views/message'import Setting from './ios_views/setting' 如何定义主件,这里我目前写了两个方法，也是最常使用的两个方法：其中constructor是这个主件的实例化方法，而真正让视图渲染到屏幕上的是render的方法，你可以在这里添加想渲染上去的视图内容。 123456789class HongshiWuLiuRN extends Component &#123; constructor() &#123; super(); &#125; render() &#123; &#125;&#125; 如何定义主件视图的样式，这里我们就需要用到stylesheet 所创创建的对象，在这里你就可以像写CSS样式一样，来定义视图了。 123const styles = StyleSheet.create(&#123;&#125;); 如何定义应用的入口文件，就想C函数一样，需要一个main函数作为入口文件，在RN中，我需要使用AppRegistry来注册这个主件，同时也作为入口文件。 1AppRegistry.registerComponent('HongshiWuLiuRN', () =&gt; HongshiWuLiuRN); 如何添加图片，你可以发现这段代码 导入图片和自定义的主件是一样，需要写清楚图片所在的路径，这里为了调试，你可以先注释到： 12icon = &#123;require('./images/news@2x.png')&#125;selectedIcon=&#123;require('./images/news-1@2x.png')&#125; 整个TabBar的功能，是由TabBarIOS来实现的，具体在这里，我们可以通过设置tintColor = ‘#e23f42’可以设置TabBar点选适合的颜色，而具体的图片的样式，文字，以及点击的方法就需要在TabBarIOS.Item来进行设置,重点说一下这个这段代码：这里定义一个私有方法，传入了一个字符串类型的参数，在拿到的参数的时候，我用swich的的方法，根据传入不同的参数，返回不同的自定义的主件 12345678910111213141516171819202122232425262728293031323334&#123;this._renderView(this.state.selected)&#125; _renderView(moduleName) &#123; switch (moduleName) &#123; case 'task': return ( &lt;Task/&gt; ); break; case 'goods': return ( &lt;Goods/&gt; ); break; case 'home': return ( &lt;Home/&gt; ); break; case 'message': return ( &lt;Message/&gt; ); break; case 'setting': return ( &lt;Setting/&gt; ); break; default: return ( &lt;View&gt;&lt;/View&gt; ); break; &#125; &#125; 这里根据自定义主件的路径，可以猜到，我在同级目录下创建一个ios_views的文件夹，在ios_views的文件下我有创建了四个js文件： goods.js、home.js、message.js、setting.js、task.js,代码如下,这个五个文件，你目前可以一样的代码，只需要修改相应的名字，就可以了： 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, View, NavigatorIOS&#125; from 'react-native';class home_views extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;/View&gt; ); &#125;&#125;class home extends Component &#123; render() &#123; return( &lt;NavigatorIOS initialRoute=&#123;&#123; component: home_views, title: "红狮物流", titleTextColor: '#fff', barTintColor: '#e23f42', &#125;&#125; /&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123;&#125;);module.exports = home 这里用到了NavigatorIOS的主件，这个就是强大的路由主件。你可以看到，在里面必须要定义初始路由对应于哪个主件，以及nav的背景色，title，字体颜色等等。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习React Native中]]></title>
    <url>%2F2016%2F08%2F24%2F20160824%2F</url>
    <content type="text"><![CDATA[其实从去年我就一直看学习并看React Native,开始学习只是为了兴趣，现在项目中用到了有些更新的功能，我就是用React native 来做的。其实还是蛮好的，但是我发现更新实在是太快了，现在官网的稳定版本是0.31版本 使用 打开terminal, cd到某个路径下，执行命令 react-native init helloworld[^这里的helloword就是你创建的项目名字]如果出现这样的代码就代码创建成功。 12345678910To run your app on iOS: cd /Users/gonghuan/Desktop/helloworld react-native run-ios - or - Open /Users/gonghuan/Desktop/helloworld/ios/helloworld.xcodeproj in Xcode Hit the Run buttonTo run your app on Android: Have an Android emulator running (quickest way to get started), or a device connected cd /Users/gonghuan/Desktop/helloworld react-native run-android 此时你可以通过类似react-native run-ios可以直接调起iOS模拟器，此时你可以看到你的终端不断在解析，然后就可以成功运行了。 说到这里，应该你已经可以运行你的app了，至于之前要安装 brew node等等，我这里就不再多说了，你可以去官网上走一遍，很简单。 工具 我这里我选用的是atom，这里说一个我遇到的小问题，也许你也会遇到，在我们使用atom的时候，需要安装一些插件来帮助我们能够更加高效的写代码，就比如facebook开发的Nuclide 按照官方install的说明，我们可以知道有两种安装的方式，一种就是通过直接在终端输入apm install nuclide,但是说实话，我就成功过一次，而且还是要挂vpn，之后就一直没有成功过了，这我就呵呵了。 官方建议第二种方式：直接在atom-&gt;Setting Views-&gt;Manage Packages,搜索Nuclide，直接安装。 第三种：通过这种方式你可以安装Themes、packages 1234 cd ~/.atom/packagesgit clone [packgae-url] # git clone https://github.com/facebook/nuclidecd [package] #nuclidenpm install ###好了，到目前为止，你已经可以，我们已经可以开始运行，并且可以安装自己喜欢的插件，已经修改自己喜欢的主题了。下面我们开始coding,我们先通过atom打开我们之前创建的helloworld的项目，并且找到index.ios.js,删除里面所有的代码，不要着急，我们会慢慢的添加进去所有的代码。 1234567891011class firstRN extends Component &#123; render() &#123; return( &lt;Text&gt; Hello world &lt;/Text&gt; ); &#125;&#125;AppRegistry.registerComponent('helloworld', ()=&gt;firstRN); 这里我们先创建一个firstRN的类，继承自Component对象，这里你先不要管，我们后面都会解释的。 第二步，我们用AppRegistry这个注册一个对象，这个对象的名字是我们应用的名字‘helloworld’，第二个参数指向的是我们刚才创建的firstRN类。 我们点击模拟器，发现报错，Unhandled JS Exception:xxxx: Can&#39;t find variable: Component,在文件头部添加 12import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text &#125; from 'react-native'; The AppRegistry just tells React Native which component is the root one for the whole application. You won’t be thinking about AppRegistry a lot - there will probably just be one call to AppRegistry.registerComponent in your whole app. It’s included in these examples so you can paste the whole thing into your index.ios.js or index.android.js file and get it running.—-这里是官方给的AppRegistry，其实AppRegistry只做了一件事情，就是告诉这个应用，谁是整个应用的根控制器，这样你可以通过修改index.ios.js来修改iOS的根控制器是啥？安卓也是一样，修改的index.android.js再次刷新模拟器，就会发现左上角会出现我们写的Hello world的文字。这里我们觉得样式好丑，那该怎么办，没事，RN也是可以做到修改的。 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text , StyleSheet &#125; from 'react-native';class firstRN extends Component &#123; render() &#123; return( &lt;Text style = &#123;styles.helloWorldStyle&#125;&gt; Hello world &lt;/Text&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; helloWorldStyle: &#123; color:'red', fontSize:30, fontWeight:'bold' &#125;&#125;)AppRegistry.registerComponent('helloworld', ()=&gt;firstRN); 这里我们需要在import中导读 StyleSheet,因为我们需要在后面的设置样式的时候，用到这个类。直接在text后面添加style的样式熟悉直接在后面创建styles的属性，通过StyleSheet来创建。再次刷新模拟器，你就可以看到效果了。 先说这么多，后期我们还会说到很多在app开发中遇到的各种问题，导航栏，网络请求，传值等等。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因为我不想打卡，不要问我为什么？？]]></title>
    <url>%2F2016%2F08%2F15%2F20160815%2F</url>
    <content type="text"><![CDATA[最近一直没啥时间来整理一些学习资料以及学习的内容，感觉这样不是很好。又由于公司要打卡了，所以我就写写我是怎么不打卡的吧！O(∩_∩)O~~~ mac电脑先安装抓包神器：Charles (网上有很多这个使用教程，我就不多说了，毕竟是工具，没啥难度) 点击Help-&gt;Local IP Address,将本机的IP打印出来，然后在手机里面设置代理为相应的IP，端口为：8888 此时你就可以开始看到数据的返回、和请求了。 ![1.pi](media/14712518179704/1.pic.jpg) 然后你就可以看到你想要的代码请求了，其实这个Android和iOS,还有点不同，Android返回的代码不是text/json,而是text/html,我在我代码中加入了代码格式的转换。 1234567891011__block NSDictionary *par = @&#123;@&quot;employeeNo&quot;:pp.employeeNo,@&quot;coord&quot;:@&quot;30.249812,120.211494&quot;,@&quot;img_ids&quot;:@&quot;&quot;,@&quot;identifier&quot;: pp.identifier,@&quot;type&quot;: @&quot;0&quot;&#125;&#125;; AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; [manager POST:@&quot;http://xxxx/HSSCM/appmail/employeeRecordManage/sign.do&quot; parameters:par success:^(AFHTTPRequestOperation * _Nonnull operation, id _Nonnull responseObject) &#123; NSLog(@&quot;%@&quot;,operation); NSLog(@&quot;%@&quot;,responseObject); &#125; failure:^(AFHTTPRequestOperation * _Nullable operation, NSError * _Nonnull error) &#123; NSLog(@&quot;%@&quot;,operation); NSLog(@&quot;%@&quot;,error); &#125;]; 你或许已经发现了参数的规律了，这里的employeeNO就是我们之前抓包的用户唯一标示符（安卓这边还耍了个心眼，取了一个很怪的名字，视图误导我们） coord就是经纬度，用逗号链接起来的一个字符串 img_ids我不知道是个什么东西，反正可有可无 identifior是手机的udid（iOS中这样称呼吧）,这里我猜想他的employeeNO与手机identifior是一一对应的，所以这也就解释了为什么我在换手机的时候，会报错 type:0–就是签出，1–就是签到 ##现在问题都已经分析完了，我们该用什么对策来自动帮我们打卡呢。 ####由于必须需要内网才能打卡，我们不能外网或者4G的条件下打卡，折让我们很蛋疼，这里我想到几个解决方案： 安卓的手机，可以借用一款叫做&lt;按键精灵&gt;的app,但是有个条件就是你必须拿到root权限，这样就可以录制你按键的动作，你可以指定时间执行。 公司的电脑、或者测试机，安装一个teamViewer，这样你就可以在家里远程操控他。 公司的测试机充当服务器的功能、一直在跑，这样我需要关心的只有一件事：手机有电。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 - (NSArray *)setUPDatas:(TypeStatus)typeStatus &#123; NSMutableArray *datas = [NSMutableArray new]; NSArray *employeeNos = @[@"31330034", @"31330040", @"31330035"]; NSArray *identifiers = @[@"05B7A575-2D2A-4006-890A-D0994EFF3DAC", @"a000004f73cb94", @"1B65EB63-487B-49BF-B751-F2D544175BE7"]; for (int i = 0 ; i &lt; employeeNos.count ; i++) &#123; People *people = [[People alloc] init]; people.employeeNo = employeeNos[i]; people.coord = @"30.249812,120.211494"; people.img_ids = @""; people.identifier = identifiers[i]; if (typeStatus == LogIn) &#123; people.type = @"1"; &#125; else &#123; people.type = @"0"; &#125; people.random_signInMin = [self getRandomNumber:5 to:25]; people.random_signInSec = [self getRandomNumber:1 to:59]; people.random_signOutMin = [self getRandomNumber:5 to:25]; people.random_signOutSec = [self getRandomNumber:1 to:59]; [datas addObject:people]; &#125; return [datas copy]; &#125; - (int)getRandomNumber:(int)from to:(int)to &#123; return (int)(from + (arc4random() % (to - from + 1))); &#125;#### 我在这里实例化了用户的对象，在这个对象生成的同事，就已经确定这个对象签到的时间，和签出的时间（在某个数范围内随机生成）。if (hour == signOutHour) &#123; // 签出--0 if (self.needSignOut.count == 0) return; for (int i = 0 ; i &lt; self.needSignOut.count; i++) &#123; People *pp = self.needSignOut[i]; if (pp.random_signOutMin &lt; min || (pp.random_signOutMin == min &amp;&amp; pp.random_signOutSec &lt;= sec)) &#123; par = @&#123; @"employeeNo":pp.employeeNo, @"coord": @"30.249812,120.211494", @"img_ids":@"", @"identifier": pp.identifier, @"type": pp.type&#125;; [self SignOrSignOut:par week:week time:[NSString stringWithFormat:@"%ld:%ld:%ld",(long)hour,(long)min,(long)sec]]; &#125; &#125; &#125; 12345678910111213141516171819- (void)needToRemove:(TypeStatus)status identifior:(NSString *)identifior realtime:(NSString *)realtime&#123; if (status == LogIn) &#123; for (int i = 0 ; i &lt; self.needSignIn.count; i++) &#123; NSMutableDictionary *tempDic = [NSMutableDictionary new]; People *pp = self.needSignIn[i]; if ([pp.identifier isEqualToString:identifior] &amp;&amp; ![identifior isEqualToString:@""]) &#123; NSLog(@"移除people:%@---loginMin:%ld----loginSec:%ld",pp.identifier,(long)pp.random_signInMin, (long)pp.random_signInSec); [self.needSignIn removeObject:pp]; if (pp.identifier != nil) [tempDic setObject:pp.identifier forKey:@"iden"]; [tempDic setObject:[NSString stringWithFormat:@"签到时间:%ld:%ld:%ld", signInHour, pp.random_signInMin, pp.random_signInSec] forKey:@"time"]; if (realtime != nil) [tempDic setObject:realtime forKey:@"realtime"]; if (tempDic != nil) [self.tableViewDatas addObject:tempDic]; &#125; &#125; 这里你会发现我在遍历的同事，又对mutableArray对象进行的操作，开始一直crash，会报这个错：collection __nsarraym was mutated while being enumerated 意思就是说，你在遍历这个对象的同事，又对这个对象进行了添加、删除的操作。这里给你三种解决的思路。 1 1for (int i = 0 ; i &lt; self.needSignIn.count; i++) &#123;&#125; 替换 1for (People *pp in self.needSignIn) &#123;&#125; 2 123NSSortDescriptor *sd1 = [NSSortDescriptor sortDescriptorWithKey:nil ascending:NO];//yes升序排列，no,降序排列NSArray *myary = [ary sortedArrayUsingDescriptors:[NSArray arrayWithObjects:sd1, nil]];//注意这里的ary进行排序后会生产一个新的数组指针，myary，不能在用ary,ary还是保持不变的。for (People *pp in myary) &#123;&#125; 3 1生成一个零时的数组，用来遍历，之前的数据用来操作。 其实这里有个问题，想了好久才想明白：为什么正序排列不行，倒序就可以呢？？,为什么for不行，但是forin的可以呢？ ####其实for的语句可以等同于：假如说我有10个元素，在第一个的时候，我就remove了，那是不是到了第九个的时候就越界了呢？？ 1int count = arr.count; for (i=0;i&lt;count;i++) &#123;&#125; 倒序同样的道理： 12int count = arr.count;for (i = count - 1;i&gt;=0 ;i—) &#123;&#125; 当我移除当前这个的时候，其实比不影响我其他的元素布局。但是这两种情况，假如你使用for的语句格式，就不会有问题了 1for (int i = 0 ; i &lt; self.needSignIn.count; i++) &#123;&#125; ###总结一句话： 当我们正序遍历时,如果删除了一个,那么没有遍历到的元素位置都会往前移动一位,这样系统就无法确定接下来遍历是从删除位置开始呢,还是从删除位置下一位开始呢 对于逆序遍历就不会,因为我们逆序遍历时,遇到匹配的元素删除后,位置改变的是遍历过得元素,而没有遍历到的元素位置却没有改变,所以遍历能够正常进行.]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Obeject-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建SDK中所遇到的坑]]></title>
    <url>%2F2016%2F05%2F10%2F20160510%2F</url>
    <content type="text"><![CDATA[其实开始之前，我找到一篇很不错的文章，想翻译的，但是google了一下，发现已经有好多人翻译过这篇文章了，这里我就不再多说什么了，把原文的链接贴出来。https://www.raywenderlich.com/65964/create-a-framework-for-ios,这里我就说一下，我在搭建sdk的时候，遇到的坑吧。 其实你要是能够走完上面的流程，你基本上已经完成了80%了，剩下的就是发现问题，再去打包。 第一个错误*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;Could not find a storyboard named &#39;XXXXname&#39; in bundle NSBundle 这个错误可能直接就会导致app起不来，一启动就会crash，这里需要将所有你用到xib，storyboard的文件都统一作出修改。其实这个问题在遇到用xib/SB创建的cell的时候、在xib/SB中添加图片的时候需要将[UIImage imageNamed:@&quot;&quot;] =======&gt; 修改为 [UIImage imageNamed:@&quot;xxxx.bundle/xxxxName&quot;] 12345UIStoryboard *main = [UIStoryboard storyboardWithName:@"xxxxName" bundle:[NSBundle mainBundle]];修改为===============================UIStoryboard *main = [UIStoryboard storyboardWithName:@"xxxx.bundle/xxxxName" bundle:[NSBundle mainBundle]]; 第二个错误可能会在Iphone4的时候，直接无法build,直接报这个错： dyld: Symbol not found: ___NSDictionary0__ 1需要将项目中的build Phases 中的core foundation的stastu的状态 从Required修改为Optional 后续如果还有其他的bug，我再贴出来吧！]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Obeject-c</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于学习UITableViewCell的高度计算的框架-UITableView-FDTemplateLayoutCell。]]></title>
    <url>%2F2016%2F05%2F05%2F20160505%2F</url>
    <content type="text"><![CDATA[学习UITableView的高度计算的框架 这里学习的是UITableView-FDTemplateLayoutCellhttps://github.com/forkingdog/UITableView-FDTemplateLayoutCell你也可以自己去下载并且学习。 他的文件很简单，直接在UITableView的高度放回中去调用方法：直接调用UITableView 中(FDTemplateLayoutCell)的category的方法,其实他的category里面一共写了三种可以计算高度的方法，这是其中的一种： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration &#123; //1. if (!identifier) &#123; return 0; &#125; //2. UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier]; // Manually calls to ensure consistent behavior with actual cells. (that are displayed on screen) [templateLayoutCell prepareForReuse]; //8. // Customize and provide content for our template cell. if (configuration) &#123; configuration(templateLayoutCell); &#125; return [self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];//2.- (__kindof UITableViewCell *)fd_templateCellForReuseIdentifier:(NSString *)identifier &#123; //.... //4. if (!templateCellsByIdentifiers) &#123; templateCellsByIdentifiers = @&#123;&#125;.mutableCopy; objc_setAssociatedObject(self, _cmd, templateCellsByIdentifiers, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; //5. if (!templateCell) &#123; templateCell = [self dequeueReusableCellWithIdentifier:identifier]; NSAssert(templateCell != nil, @"Cell must be registered to table view for identifier - %@", identifier); //6. templateCell.fd_isTemplateLayoutCell = YES; templateCell.contentView.translatesAutoresizingMaskIntoConstraints = NO; templateCellsByIdentifiers[identifier] = templateCell; [self fd_debugLog:[NSString stringWithFormat:@"layout cell created - %@", identifier]]; &#125; //....)//3./** * Returns the value associated with a given object for a given key. * * @param object The source object for the association. * @param key The key for the association. * * @return The value associated with the key \e key for \e object. * * @see objc_setAssociatedObject */OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)//6./// Indicate this is a template layout cell for calculation only./// You may need this when there are non-UI side effects when configure a cell./// Like:/// - (void)configureCell:(FooCell *)cell atIndexPath:(NSIndexPath *)indexPath &#123;/// cell.entity = [self entityAtIndexPath:indexPath];/// if (!cell.fd_isTemplateLayoutCell) &#123;/// [self notifySomething]; // non-UI side effects/// &#125;/// &#125;///@property (nonatomic, assign) BOOL fd_isTemplateLayoutCell;//7.- (BOOL)fd_isTemplateLayoutCell &#123; return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)setFd_isTemplateLayoutCell:(BOOL)isTemplateLayoutCell &#123; objc_setAssociatedObject(self, @selector(fd_isTemplateLayoutCell), @(isTemplateLayoutCell), OBJC_ASSOCIATION_RETAIN);&#125; 这里假如不传入identifior的值得话，他就直接直接返回0，表示不计算高度了。 这里根据传入的identifior的值，来找到相应的UITableViewCell 这里是runtime源码中所申明的，可以看到这个是根据给的Object以及给的Key来返回一个对象 第一次申明的话，它就会创建一个空的可变字典对象,字典的对象是{},key是String, value是UITableViewCell。 当第一次没有UITableViewCell的对象的时候，就开始在重用池中，找UITableViewCell的对象,并将UITableViewCell对象塞进之前的字典对象。 这边在塞入UITableViewCell对象的时候，通过category(7.)来这是这个UITableViewCell的属性，这个作者的用意就是表明这个只是用计算高度的。 如果需要在cell中设置cell元素中的值，就在这里设置。最后拿到UITableViewCell的对象。 最后将拿到的UITableViewCell的对象丢到这个函数中计算123456- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell &#123; // Auto layout engine does its math // 6. fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; [cell.contentView removeConstraint:widthFenceConstraint];&#125; 这里首先获得这个UITableViewCell的宽度，赋值给contentViewWidth的对象。 下面判断这个cell中有没有设置accessoryView的这个view，如果设置了accessoryView的话，这个cell的宽度按会稍微小一点（16 + CGRectGetWidth(cell.accessoryView.frame)） 否则会根据accessoryView的类型不同，需要减去不同的宽度。 fd_enforceFrameLayout是用autolayout的、还是使用的frame的布局。 通过NSLayoutConstraint，将cell.contentView的宽度设置为contentViewWidth。 直接返回高度，并将约束移除掉。这里我不是很明白，为什么要这样做。 如果这里的UITableview的格式如果不是UITableViewCellSeparatorStyleNone，高度可能会有点偏差，加上这个偏差（1.0 / [UIScreen mainScreen].scale） ##Demo中第二种方法，其他参数都是一样的，就是多了一个cacheByIndexPath,就是根据IndexPath的对象来存储刚才计算的高度。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/// This method does what "-fd_heightForCellWithIdentifier:configuration" does, and/// calculated height will be cached by its index path, returns a cached height/// when needed. Therefore lots of extra height calculations could be saved.////// No need to worry about invalidating cached heights when data source changes, it/// will be done automatically when you call "-reloadData" or any method that triggers/// UITableView's reloading.////// @param indexPath where this cell's height cache belongs.///- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration &#123; // Hit cache //1. if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123; [self fd_debugLog:[NSString stringWithFormat:@"hit cache by index path[%@:%@] - %@", @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]]; return [self.fd_indexPathHeightCache heightForIndexPath:indexPath]; &#125; //9. CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration]; [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath]; [self fd_debugLog:[NSString stringWithFormat: @"cached by index path[%@:%@] - %@", @(indexPath.section), @(indexPath.row), @(height)]]; return height;&#125;//2.- (BOOL)existsHeightAtIndexPath:(NSIndexPath *)indexPath &#123; //6. NSNumber *number = self.heightsBySectionForCurrentOrientation[indexPath.section][indexPath.row]; return ![number isEqualToNumber:@-1];&#125;//3.- (void)buildCachesAtIndexPathsIfNeeded:(NSArray *)indexPaths &#123; [indexPaths enumerateObjectsUsingBlock:^(NSIndexPath *indexPath, NSUInteger idx, BOOL *stop) &#123; //4. [self buildSectionsIfNeeded:indexPath.section]; //5. [self buildRowsIfNeeded:indexPath.row inExistSection:indexPath.section]; &#125;];&#125;- (void)buildSectionsIfNeeded:(NSInteger)targetSection &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; for (NSInteger section = 0; section &lt;= targetSection; ++section) &#123; if (section &gt;= heightsBySection.count) &#123; heightsBySection[section] = [NSMutableArray array]; &#125; &#125; &#125;];&#125;- (void)buildRowsIfNeeded:(NSInteger)targetRow inExistSection:(NSInteger)section &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; NSMutableArray&lt;NSNumber *&gt; *heightsByRow = heightsBySection[section]; for (NSInteger row = 0; row &lt;= targetRow; ++row) &#123; if (row &gt;= heightsByRow.count) &#123; heightsByRow[row] = @-1; &#125; &#125; &#125;];&#125;//6.typedef NSMutableArray&lt;NSMutableArray&lt;NSNumber *&gt; *&gt; FDIndexPathHeightsBySection;//7.- (CGFloat)heightForIndexPath:(NSIndexPath *)indexPath &#123; [self buildCachesAtIndexPathsIfNeeded:@[indexPath]]; NSNumber *number = self.heightsBySectionForCurrentOrientation[indexPath.section][indexPath.row];&#125;//8.- (FDIndexPathHeightsBySection *)heightsBySectionForCurrentOrientation &#123; return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation) ? self.heightsBySectionForPortrait: self.heightsBySectionForLandscape;&#125; 和上面方法一样的我就不说了，这里的高度缓存部分还是蛮有意思的，这里新建了一个fd_indexPathHeightCache的对象，这个对象就是用来管理缓存的部分，对象继承的是NSObject 通过传入的indexPath来返回这个对象是否已经缓存进去了。 在将indexPath的对象打包成NSArray的对象，对到下一个函数中 将indexPath.section,如果数组中不含有这个section的话，那就新建一个，通过6.可以知道，这个是个二位数组，最外层数组的index的数目就是section 下一个方法就是根据section，找到里面一层的数组，这个数组放的就是对应的rows的对象，如果没有就会默认塞入一个-1的值。 再根据同样的方法，到二维数组中查找对象，如果不是我们之前塞入的-1,那就是true，否则就是false。 这里我没看懂，已经知道在缓存中存在了，为什么还要再掉一遍[self buildCachesAtIndexPathsIfNeeded:@[indexPath]]; 这里可以知道，作者根据横竖屏设置了两个不同的数据，就是为了分别存储、提取。 如果之前没有缓存的话，它会先去调用一遍之前计算高度的方法，然后将计算出来的高度，丢到之前的二维数组中去。 ###第三种的计算方式，就是根据每个model设置不同key值来存储高度。123456789101112131415161718/// This method caches height by your model entity's identifier./// If your model's changed, call "-invalidateHeightForKey:(id &lt;NSCopying&gt;)key" to/// invalidate cache and re-calculate, it's much cheaper and effective than "cacheByIndexPath".////// @param key model entity's identifier whose data configures a cell.///- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration &#123; //1. // Hit cache if ([self.fd_keyedHeightCache existsHeightForKey:key]) &#123; CGFloat cachedHeight = [self.fd_keyedHeightCache heightForKey:key]; [self fd_debugLog:[NSString stringWithFormat:@"hit cache by key[%@] - %@", key, @(cachedHeight)]]; return cachedHeight; &#125; //2. @property (nonatomic, strong) NSMutableDictionary&lt;id&lt;NSCopying&gt;, NSNumber *&gt; *mutableHeightsByKeyForPortrait;&#125; 作者也说了，这个效率会比之前按照indexPath的计算效率要高。 通过这个，我们大概就知道，作者所谓的效率高，应该就是这个意思，这里不是什么二维数组，而是一个NSMutableDictionary对象。其他基本上类似。 最后说一下自己的一个疑问：第二种方法中，作者为什么不将key和value经过简单的运算，作为key，来用NSDictionary来存储数据呢？作者的解释是：里面要配合 section row 的insert remove的话，会比较麻烦。所以作者最后还是选择的二维数组。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Obeject-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于图片圆角的功能学习。]]></title>
    <url>%2F2016%2F04%2F19%2F20160418%2F</url>
    <content type="text"><![CDATA[图片的性能问题，基本上面试的时候，都会被问到，现在在自己的app中，我也是为了解决的性能的问题，所以了解了一些关于图片性能的库，看一下源码, 现在应该有很多这种库了。我看的是这个：https://github.com/CoderJackyHuang/HYBImageCliped 这个库是通过Category来分别实现这些功能，首先看看UIView的Category,是怎么实现的UIView的圆角。 1234567891011121314151617/** * 使用指定的图片来填充，但是生成的是圆形图片，背景颜色为白色。 * * @param image 图片名称或者图片对象，甚至支持NSData * @param targetSize 生成指定大小的图片 * @param isEqualScale 是否等比例缩放图片 * @param backgroundColor 默认取最顶层父视图的背景色，若为透明，则取本身背景色，若也为透明，则取白色 * @parma callback 只有当图片真正被裁剪成功后，才会回调，返回裁剪后的图片 * * @return 裁剪前的图片 */- (UIImage *)hyb_setCircleImage:(id)image size:(CGSize)targetSize isEqualScale:(BOOL)isEqualScale backgrounColor:(UIColor *)backgroundColor onCliped:(HYBClipedCallback)callback; 这只是其中一种Public的方法，我是按照Demo来看的。但是无论哪一种Public的方法，最终调用的都是统一的一个Private 的方法。 12345678- (UIImage *)hyb_private_setImage:(id)image size:(CGSize)targetSize cornerRadius:(CGFloat)cornerRadius rectCorener:(UIRectCorner)rectCorner backgroundColor:(UIColor *)bgColor isEqualScale:(BOOL)isEqualScale isCircle:(BOOL)isCircle onCliped:(HYBClipedCallback)callback 里面有个这个方法：可以看出来，假如你不设置bgColor这个属性的话，他会遍历循环，一直会找到最顶层的父类，去除父类的颜色。所以我觉得你要是没事话，还是自己设置一下颜色吧！这边假如层级很复杂，并且元素很多的话，这个性能可能会让你哭吧... 123456789101112 if (bgColor == nil || CGColorEqualToColor(bgColor.CGColor, [UIColor clearColor].CGColor)) &#123; UIView *superview = self.superview; while (superview.backgroundColor == nil || CGColorEqualToColor(superview.backgroundColor.CGColor, [UIColor clearColor].CGColor)) &#123; if (!superview) &#123; break; &#125; superview = [superview superview]; &#125; bgColor = superview.backgroundColor;&#125; 好吧，下面这段代码又要提到面试宝典中啥经典话题了，如何在category中给现有的类添加属性呢？http://nshipster.com/associated-objects/Matt 大神曾经写过，你可以看一下。 123456789__block UIImage *clipedImage = nil; //1. dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //2. willBeClipedImage.hyb_pathColor = self.hyb_pathColor; willBeClipedImage.hyb_pathWidth = self.hyb_pathWidth; willBeClipedImage.hyb_borderColor = self.hyb_borderColor; willBeClipedImage.hyb_borderWidth = self.hyb_borderWidth; &#125;); 123456789101112这里涉及到的pathColor,pathWidth,borderColor,borderWidth,都是通过在runtime的特性，在已有的类中添加属性的方式来存储和使用的。- (UIColor *)hyb_pathColor &#123; UIColor *color = objc_getAssociatedObject(self, s_hyb_image_pathColorKey); if (color) &#123; return color; &#125; return [UIColor whiteColor];&#125;//...下面都是换汤不换药的。 下面涉及到真正的画图部分了 这里另起一个线程来绘制圆角。这里我有个问题：每个图片都创建一个线程，这个是不是有点问题。而且这个dispatch_get_global_queue也有问题，Global Dispatch Queue创建的队列,其线程数目是不定的,是根据XNU内核决定的。我觉得这一点，源码中没有解释。 绘制圆角的核心函数是这个。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//1.- (UIImage *)hyb_private_clipImageToSize:(CGSize)targetSize cornerRadius:(CGFloat)cornerRadius corners:(UIRectCorner)corners backgroundColor:(UIColor *)backgroundColor isEqualScale:(BOOL)isEqualScale isCircle:(BOOL)isCircle &#123;&#125; CGContextRef ctx = UIGraphicsGetCurrentContext(); //2. if (isCircle) &#123; CGContextAddEllipseInRect(ctx, rect); &#125; else &#123; CGContextAddRect(ctx, rect); &#125; CGContextClip(ctx); [self drawInRect:rectImage]; //3. CGContextSetStrokeColorWithColor(ctx, [borderColor CGColor]); CGContextSetLineWidth(ctx, borderWidth); if (isCircle) &#123; CGContextStrokeEllipseInRect(ctx, rectImage); CGContextStrokeEllipseInRect(ctx, rect); &#125; else if (cornerRadius == 0) &#123; CGContextStrokeRect(ctx, rectImage); CGContextStrokeRect(ctx, rect); &#125; //4. UIBezierPath *path2 = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:CGSizeMake(cornerRadius + minusPath1 ,cornerRadius + minusPath1)]; //5. UIImage *finalImage = UIGraphicsGetImageFromCurrentImageContext(); return finalImage; 里面更新size做了一些文章。是到底要做截成一个正圆，还是只截在哪个角的圆。 如果是正圆、并且不带圆角的话，就用core graphic来画。 内线和外线的绘制、以及粗细、颜色。 如果不是正圆、带圆角的多边形的图形，用UIBezierPath 曲线来绘制。关键是第二个参数，是一个枚举类型，代表哪一个或者哪一些圆角需要绘制、苹果官方的文档为corners: A bitmask value that identifies the corners that you want rounded. You can use this parameter to round only a subset of the corners of the rectangle. 最后直接将绘制的图形返回出来。 最后说一点、无论是UIbutton、UIImage、还是什么、笔者的思路都是先在UIView中添加方法、再在UIImage添加方法、并且进行调用、绘制图形，并且返回。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Obeject-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习YYModel]]></title>
    <url>%2F2016%2F04%2F01%2F20160401%2F</url>
    <content type="text"><![CDATA[以YYModel的例子，它以类的方式调用 1234567+ (instancetype)yy_modelWithJSON:(id)json &#123; NSDictionary *dic = [self _yy_dictionaryWithJSON:json]; return [self yy_modelWithDictionary:dic];&#125;&lt;!-- 1. 直接将json的格式丢给这个函数 --&gt;&lt;!-- 2. 然后调用下面的这个函数，主要是讲这个json转化为NSDictionary的格式，如果是字符串会将字符串转化为NSData,然后再转化为NSDictionary --&gt; 1+ (NSDictionary *)_yy_dictionaryWithJSON:(id)json &#123; 现在开始进入最重要的函数部分了 12//这个函数里获取model元是通过调用下面的方法，cls是获取本类而得到的Class类型+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary &#123;&#125; 1[_YYModelMeta metaWithClass:cls] 1234567891011121314151617181920212223+ (instancetype)metaWithClass:(Class)cls &#123; if (!cls) return nil; static CFMutableDictionaryRef cache; static dispatch_once_t onceToken; //1.. static dispatch_semaphore_t lock; dispatch_once(&amp;onceToken, ^&#123; cache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); lock = dispatch_semaphore_create(1); &#125;); dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls)); dispatch_semaphore_signal(lock); if (!meta || meta-&gt;_classInfo.needUpdate) &#123; meta = [[_YYModelMeta alloc] initWithClass:cls]; if (meta) &#123; dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta)); dispatch_semaphore_signal(lock); &#125; &#125; return meta;&#125; 1234&lt;!-- //以信号量的方式保持同步，作用是为了从cache的内存中获取meta的数据是同步的。 --&gt;dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls)); dispatch_semaphore_signal(lock); 123456789&lt;!-- //或者在讲meta的值塞入内存中保持同步 --&gt; if (!meta || meta-&gt;_classInfo.needUpdate) &#123; meta = [[_YYModelMeta alloc] initWithClass:cls]; if (meta) &#123; dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta)); dispatch_semaphore_signal(lock); &#125; &#125; 1234567&lt;!-- 其中创建meta的时候回调用 --&gt;meta = [[_YYModelMeta alloc] initWithClass:cls];- (instancetype)initWithClass:(Class)cls &#123; YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls]; ..... &#125; 12345678910111213141516 &lt;!-- 这里涉及到YYClassInfo的实例化方法,通过runtime的一些方法，找到本类，父类，元类。 --&gt; - (instancetype)initWithClass:(Class)cls &#123; if (!cls) return nil; self = [super init]; _cls = cls; _superCls = class_getSuperclass(cls); _isMeta = class_isMetaClass(cls); if (!_isMeta) &#123; _metaCls = objc_getMetaClass(class_getName(cls)); &#125; _name = NSStringFromClass(cls); [self _update]; _superClassInfo = [self.class classInfoWithClass:_superCls]; return self;&#125; 然后在_update的方法中 12345678910111213141516171819202122232425&lt;!-- 这里讲model中的方法、属性，ivar以key-value的形式存放在字典中。本类调用完后会在父类中调用再调用一遍。 --&gt; Class cls = self.cls; unsigned int methodCount = 0; Method *methods = class_copyMethodList(cls, &amp;methodCount); if (methods) &#123; NSMutableDictionary *methodInfos = [NSMutableDictionary new]; _methodInfos = methodInfos; for (unsigned int i = 0; i &lt; methodCount; i++) &#123; YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:methods[i]]; if (info.name) methodInfos[info.name] = info; &#125; free(methods); &#125; unsigned int propertyCount = 0; objc_property_t *properties = class_copyPropertyList(cls, &amp;propertyCount); if (properties) &#123; NSMutableDictionary *propertyInfos = [NSMutableDictionary new]; _propertyInfos = propertyInfos; for (unsigned int i = 0; i &lt; propertyCount; i++) &#123; YYClassPropertyInfo *info = [[YYClassPropertyInfo alloc] initWithProperty:properties[i]]; if (info.name) propertyInfos[info.name] = info; &#125; free(properties); &#125;.... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!-- * 最最关键的映射来了，YYModel把这个功能用一个递归函数来实现了。 --&gt;// create mapper NSMutableDictionary *mapper = [NSMutableDictionary new]; NSMutableArray *keyPathPropertyMetas = [NSMutableArray new]; NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new]; if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) &#123; NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper]; [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) &#123; _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName]; if (!propertyMeta) return; [allPropertyMetas removeObjectForKey:propertyName]; if ([mappedToKey isKindOfClass:[NSString class]]) &#123; if (mappedToKey.length == 0) return; propertyMeta-&gt;_mappedToKey = mappedToKey; NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;]; if (keyPath.count &gt; 1) &#123; propertyMeta-&gt;_mappedToKeyPath = keyPath; [keyPathPropertyMetas addObject:propertyMeta]; &#125; propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil; mapper[mappedToKey] = propertyMeta; &#125; else if ([mappedToKey isKindOfClass:[NSArray class]]) &#123; NSMutableArray *mappedToKeyArray = [NSMutableArray new]; for (NSString *oneKey in ((NSArray *)mappedToKey)) &#123; if (![oneKey isKindOfClass:[NSString class]]) continue; if (oneKey.length == 0) continue; NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;]; if (keyPath.count &gt; 1) &#123; [mappedToKeyArray addObject:keyPath]; &#125; else &#123; [mappedToKeyArray addObject:oneKey]; &#125; if (!propertyMeta-&gt;_mappedToKey) &#123; propertyMeta-&gt;_mappedToKey = oneKey; propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil; &#125; &#125; if (!propertyMeta-&gt;_mappedToKey) return; propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray; [multiKeysPropertyMetas addObject:propertyMeta]; propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil; mapper[mappedToKey] = propertyMeta; &#125; &#125;]; &#125; &lt;!-- * 源码中就可以看出，这个映射的函数，你需要复写modelCustomPropertyMapper 这个函数 * 映射这个函数，你可以定义一个NSString的字符串，假如你得字符串中含有“.”这个的话，他就会将这个字符串以“.”分隔成NSArray,然后存入到_mappedToKeyPath 这个变量中。 * 映射也可以是一个NSArray,这样就可以实现同一个model映射到不同的key上了。 --&gt;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Obeject-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2016%2F03%2F28%2F20160328%2F</url>
    <content type="text"><![CDATA[最近身边发生了太多太多事情，让我认识到了生命是多么的脆弱。满怀期望等待着一个什么的到来、可惜Ta却悄悄地离开了我们。我现在只想好好爱着我身边肉丝，一辈子都呵护在她身边，一直保护她，爱护她，不要让她收到一点点的伤害。 为了Rose、我了这个家、为了TA到来。我要好好鼓励工作，给你们最好的未来。 123while(!isSuccess)&#123; func keepMoving()&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>我</tag>
      </tags>
  </entry>
</search>