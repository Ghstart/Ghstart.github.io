<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React-Native 0.46 最新环境配置]]></title>
    <url>%2F2017%2F07%2F31%2F20170731%2F</url>
    <content type="text"><![CDATA[隔了好久，闲来无事，看到自己github上React-Native的项目好久没有更新了，所以想继续搞搞它，但是发现好多坑。 打开官网 https://facebook.github.io/react-native/，我所用的都是最新的版本0.46, 点击链接到https://facebook.github.io/react-native/docs/getting-started.html,点击Build Projects with Native Code，会有一个Demo，按照这个Demo一步步操作，会遇到很多的坑，这里我记录一下： 1.先运行Android的机器，发现会报未找到SDK的问题，具体如下： 12345FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring project ':app'.&gt; SDK location not found. Define location with sdk.dir in the local.properties file or with an ANDROID_HOME environment variable. 解决：以mac为例子，找到~/.bashrc的文件，也有可能是~/.zshrc的文件 123451. vim ~/.bashrc2. export ANDROID_HOME=~/Library/Android/sdk export PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools 2.再次运行react-native run-android 想执行真机的话, 报这如下错误： 1Could not run adb reverse: Command failed: /Users/gonghuan/Library/Android/sdk/platform-tools/adb -s K21GAMN590201150 reverse tcp:8081 tcp:8081 这里假如你的系统是Android 5.0以上的话，应该就不会有这个问题了，但是如果你的安卓机器和我的一样，都是低于Android 5.0的话：, 以我的手机为例[安卓4.4.4]，解决： 1234567891. (Android 5.0以下)通过Wi-Fi连接你的本地开发服务器首先确保你的电脑和手机设备在同一个Wi-Fi环境下。2. 在设备上运行你的React Native应用。和打开其它App一样操作。你应该会看到一个“红屏”错误提示。这是正常的，下面的步骤会解决这个报错。3. 摇晃设备，或者运行adb shell input keyevent 82，可以打开开发者菜单。4. 点击进入Dev Settings。5. 点击Debug server host for device。6. 输入你电脑的IP地址和端口号（譬如10.0.1.1:8081）。在Mac上，你可以在系统设置/网络里找查询你的IP地址。在Windows上，打开命令提示符并输入ipconfig来查询你的IP地址。在Linux上你可以在终端中输入ifconfig来查询你的IP地址。7. 回到开发者菜单然后选择Reload JS。` 3.运行react-native run-android的时候，启动模拟器，我这边报这个错误： 1Error: No available formula with the name "android-sdk" 解决途径：1. 如果你已经按照官网 [https://facebook.github.io/react-native/docs/getting-started.html] 的教程，走完，但是还是报错的话就执行下面的命令： 1234567brew tap caskroom/caskbrew cask install android-sdkbrew cask install android-platform-tools]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习设计模式-迭代器模式]]></title>
    <url>%2F2017%2F07%2F13%2F20170713%2F</url>
    <content type="text"><![CDATA[代码写多了，就想把代码写好，将代码写好，就必然要学习设计模式，今天重点学习一下迭代器模式和组合模式。这里我参照的学习是以JAVA为参照的《Header First》设计模式，我这里会以Object-c的格式来重写，最后以一个我项目中的实例来说明一下。1.1 迭代器设计模式： 问题：这里有两个类：一个是煎饼餐厅菜类PancakeHouseMenu(这里假设代码中是以数组的形式来存储),一个是普通餐厅类DinerMenu(这里假设是以字典的形式来存储),他们都有自己原有的代码，以及逻辑，现在如何将这两个菜单类合并成一个类更好给用户调用。 这个是PancakeHouseMenu的代码 123456789101112131415161718192021222324252627282930313233343536373839#import "PancakeHouseMenu.h"#import "Pancak.h"@interface PancakeHouseMenu ()@property (nonatomic, strong) NSMutableArray *items;@end@implementation PancakeHouseMenu- (instancetype)init &#123; if (self = [super init]) &#123; [self addItem:@"cake_A" isVege:YES price:0.23]; [self addItem:@"cake_B" isVege:NO price:0.53]; [self addItem:@"cake_C" isVege:YES price:1.2]; &#125; return self;&#125;- (void)addItem:(NSString *)itemName isVege:(BOOL)isVege price:(CGFloat)price &#123; Pancak *cake = [Pancak pancakName:itemName isVege:isVege price:price]; if (cake != nil) [self.items addObject:cake];&#125;- (NSArray &lt;Pancak *&gt;*) menuItems; &#123; return [self.items copy];&#125;#pragma mark - Getter Methods- (NSMutableArray *)items &#123; if (_items == nil) _items = [NSMutableArray new]; return _items;&#125;@end 这个是DinerMenu的代码 123456789101112131415161718192021222324252627282930313233343536373839404142#import "DinerMenu.h"#import "Diner.h"@interface DinerMenu ()@property (nonatomic, strong) NSMutableDictionary *items;@property (nonatomic, assign) NSInteger numberOfItems;@end@implementation DinerMenu- (instancetype)init &#123; if (self = [super init]) &#123; self.numberOfItems = 0; [self addItem:@"Diner_A" isVege:YES price:2.32]; [self addItem:@"Diner_B" isVege:NO price:5.33]; [self addItem:@"Diner_C" isVege:YES price:1.27]; &#125; return self;&#125;- (NSDictionary *) menuItems &#123; return [self.items copy];&#125;- (void)addItem:(NSString *)itemName isVege:(BOOL)isVege price:(CGFloat)price &#123; Diner *diner = [Diner DinerName:itemName isVege:isVege price:price]; if (diner != nil &amp;&amp; itemName != nil) &#123; [self.items setObject:diner forKey:@(self.numberOfItems)]; self.numberOfItems ++; &#125;&#125;- (NSMutableDictionary *)items &#123; if (_items == nil) _items = [NSMutableDictionary new]; return _items;&#125;@end 通过比较就可以看出这两个的区别。存储数据分别用的是NSMutableArray和NSMutableDictionary 如果此时我需要分别打印响应的数据的时候的，就需要这样： 123456789101112131415161718192021- (void)printMenu &#123; self.pancakeMenu = [PancakeHouseMenu new]; NSArray *pancakeItems = self.pancakeMenu.menuItems; self.dinerMenu = [DinerMenu new]; NSDictionary *dinerItems = self.dinerMenu.menuItems; for (int i = 0 ; i &lt; pancakeItems.count ; i++) &#123; Pancak *pancake = pancakeItems[i]; NSLog(@"%@", pancake); &#125; NSLog(@"--------------------"); for (int i = 0 ; i &lt; dinerItems.count; i ++ ) &#123; Diner *diner = dinerItems[@(i)]; NSLog(@"%@", diner); &#125; &#125; 结果如下： 12345672017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] pancake:[name:cake_A--isvege:1--price:0.23]2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] pancake:[name:cake_B--isvege:0--price:0.53]2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] pancake:[name:cake_C--isvege:1--price:1.20]2017-07-12 16:54:00.992 Learn_Iterator_Composite_Pattern[6245:186657] --------------------2017-07-12 16:54:00.993 Learn_Iterator_Composite_Pattern[6245:186657] diner:[name:Diner_A--isvege:1--price:2.32]2017-07-12 16:54:00.993 Learn_Iterator_Composite_Pattern[6245:186657] diner:[name:Diner_B--isvege:0--price:5.33]2017-07-12 16:54:00.993 Learn_Iterator_Composite_Pattern[6245:186657] diner:[name:Diner_C--isvege:1--price:1.27] 这样第一个问题就出现了，这里两家餐厅的菜单存储的数据结构没法控制，这里需要打印菜单的时候，就需要分别遍历两个数据 解决版本：封装变化的部分（这里变化的部分就是循环遍历的地方） 这里创建一个protocol,代码如下： 1234567891011121314151617@protocol Iterator &lt;NSObject&gt;/** 是否这个聚合中存在更多的元素 @return 返回bool值 */- (BOOL)hasNext;/** 返回下一个对象 @return 下一个对象 */- (id)next;@end 创建一个新的类DinerMenuIterator,这个类是Iterator具体实现的类，具体实现： 12345678910111213141516171819202122232425262728293031323334#import "DinerMenuIterator.h"@interface DinerMenuIterator ()@property (nonatomic, strong) NSDictionary *items;@property (nonatomic, assign) NSInteger position;@end@implementation DinerMenuIterator- (instancetype)initWithItems:(NSDictionary *)items &#123; if (self = [super init]) &#123; self.position = 0; self.items = items; &#125; return self;&#125;- (BOOL)hasNext &#123; if (self.position &gt;= self.items.count) return NO; return YES;&#125;- (id)next &#123; if ([self hasNext]) &#123; id item = self.items[@(self.position)]; self.position ++; return item; &#125; return nil;&#125;@end 修改DinerMenu的类： 12345678910111213/** 返回菜单项 @return 菜单总数据 *///- (NSDictionary *) menuItems;/** 迭代器的接口 @return 迭代器对象 */- (id&lt;Iterator&gt;)iterator; .m 文件的具体实现： 1234567- (id&lt;Iterator&gt;)iterator &#123; return [[DinerMenuIterator alloc] initWithItems:[self.items copy]];&#125;//- (NSDictionary *) menuItems &#123;// return [self.items copy];//&#125; 这样打印代码如下： 12345678910111213141516171819202122- (void)printMenu &#123; self.pancakeMenu = [PancakeHouseMenu new]; id &lt;Iterator&gt;pancakIterator = [self.pancakeMenu iterator]; self.dinerMenu = [DinerMenu new]; id &lt;Iterator&gt;dinerIterator = [self.dinerMenu iterator]; [self iterate_print_menu:pancakIterator]; NSLog(@"--------------------"); [self iterate_print_menu:dinerIterator]; &#125;- (void)iterate_print_menu:(id&lt;Iterator&gt;)it &#123; while (it.hasNext) &#123; NSLog(@"%@", it.next); &#125;&#125; 这样就解决了游走于每一个元素内部之间，而不需要暴露内部的实现。 迭代器模式：提供一种方法顺序访问聚合对象中各个元素，而又不暴露其内部的实现。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习《iOS Animations》]]></title>
    <url>%2F2017%2F07%2F04%2F20170704%2F</url>
    <content type="text"><![CDATA[最近一直在学习《iOS Animations》这本书，记录一下学习到知识点： 这本都快看完了，一直觉得没啥可做笔记的，以为UI动画的一些用法，你知道就是知道，不知道就是不知道，知道了 就觉得很容易，所以觉得这是一个熟能生巧的技能，但是想想，这本书都快看完了，还是要留下一些什么，所以觉得记些东西。 Animating Constraints 如何在动画中修改约束 最简单的就是获取NSLayoutConstraint!的属性值，直接修改对象的constant可以直接实现约束值的改变。官方的api解释如下： Unlike the other properties, the constant may be modified after constraint creation. Setting the constant on an existing constraint performs much better than removing the constraint and adding a new one that’s just like the old but for having a new constant. 12@IBOutlet weak var menuHeightConstraint: NSLayoutConstraint!menuHeightConstraint.constant = isMenuOpen ? 200.0 : 60.0 1.1 添加动画 运用类似这些apianimate(withDuration:animations:)就可以实现动画。 可以在animations的closure里面添加动画的代码，也可以在外面修改完响应的约束代码，然后直接在closure中调用self.view.layoutIfNeeded() 123UIView.animate(withDuration: 1.0, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 10.0, options: .curveEaseIn, animations: &#123; self.view.layoutIfNeeded() &#125;, completion: nil) 1.2 遍历修改约束1234567titleLabel.superview?.constraints.forEach &#123; constraint in if constraint.firstItem === titleLabel &amp;&amp; constraint.firstAttribute == .centerX &#123; constraint.constant = isMenuOpen ? -100.0 : 0.0 return &#125;&#125; 这里的作用就是遍历titleLabel的父视图的约束. 表达式firstItem.firstAttribute = secondItem.secondAttribute + constant 删除某个约束，是通过 isActive的属性来设置的，isActive的属性为false的时候，就代表去除约束, 当设置isActive的属性值为false,视图的层级会删除约束，并且如果没有对象引用它，它就会从内存中去除掉。 1.3 添加新的约束 1.在刚才枚举中，可以通过循环，并且创建一个新的约束，并且替换掉： 12345678910let newConstraint = NSLayoutConstraint( item: titleLabel, attribute: .centerY, relatedBy: .equal, toItem: titleLabel.superview!, attribute: .centerY, multiplier: isMenuOpen ? 0.67 : 1.0, constant: 5.0)newConstraint.identifier = "TitleCenterY"newConstraint.isActive = true 通过设置identifier的属性值，来找到视图层级的元素，通过设置isActive来告诉Autolayout将其应用到当前的布局中去。 如果是手动编写autolayout的代码，创建完新的约束后，需要通过addConstraint,将新的约束添加到视图上去。 但是系统更偏向于使用NSLayoutConstraint.activate(_:)的类方法,接受一个 constraint的数组，性能更优，官方api的解释如下: Convenience method that activates each constraint in the contained array, in the same manner as setting active=YES. This is often more efficient than activating each constraint individually. 2. 12345let conX = imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor)let conBottom = imageView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: imageView.frame.height)let conWidth = imageView.widthAnchor.constraint(equalTo: view.widthAnchor, multiplier: 0.33, constant: -50)let conHeight = imageView.heightAnchor.constraint(equalTo: imageView.widthAnchor)NSLayoutConstraint.activate([conX, conBottom, conWidth, conHeight])]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习算法]]></title>
    <url>%2F2017%2F06%2F20%2F20170620%2F</url>
    <content type="text"><![CDATA[前两天闲来无事有重新温习了一下算法，用Swift3重写了一下算法：今天先写一下O(n^2)的两种算法：选择排序、插入排序，以及算法复杂度为O(nlogn)的：递归排序 项目我已经丢到github上了，可以自己去下载： [https://github.com/Ghstart/play_with_algorithm] 1.1 准备工作 首先写算法，我需要有准备为我产生测试用例的方法，因此我定义了了一个类Helper,并且写静态方法： 12345678static func generateSources(count: Int) -&gt; [Int] &#123; var sources: [Int] = [Int]() for _ in 1...count &#123; let randomNum: UInt32 = arc4random_uniform(1_000_000) sources.append(Int(randomNum)) &#125; return sources &#125; 学习算法必不可少的，就是需要去验证我的算法，是否正确，这里我写了一个静态方法去验证我的算法是否排序正确： 12345678910111213141516static func isSorted(testSources: [Int]) -&gt; Bool &#123; if testSources.count &lt; 3 &#123; assert(true, "你逗我呢？？就几个自己数") return false &#125; for i in 0...testSources.count - 2 &#123; if testSources[i] &gt; testSources[i + 1] &#123; return false &#125; &#125; return true &#125; 写算法，我必须要去计算每个算法所执行的时间，通过Unit Test的measure可以来看出每个方法执行的时间，这里我也写了一个静态方法： 12345678static func executeTime(whichFunctionName: String, testSources: [Int], operation: ([Int]) -&gt; ([Int])) &#123; let methodStart = Date() let tt = operation(testSources) let methodFinished = Date() let executionTime = methodFinished.timeIntervalSince(methodStart) print(String(format:"执行%@花费%.9fs", whichFunctionName, executionTime)) assert(Helper.isSorted(testSources: tt), "排序后还是存在问题！！") &#125; 1.2 开始coding 选择排序，其实说白了，就找索引, 从当前位置一直往后找，并且判断，如果小，就找出他的索引，再继续往后找，直到到最后一位, 这里注意，它是不能提前结束的，所以这就是为什么说他会比插入排序慢了： 123456789101112131415161718192021222324252627/** * 选择排序 */ func selectionSort(sources: [Int]) -&gt; [Int] &#123; var sources = sources for i in 0..&lt;sources.count &#123; var minIndex = i for j in i+1..&lt;sources.count &#123; if sources[j] &lt; sources[minIndex] &#123; minIndex = j &#125; &#125; if minIndex != i &#123; swap(&amp;sources[minIndex], &amp;sources[i]) &#125; &#125; return sources &#125; 插入排序，是从第二个位置开始往前找，判断前面的是否比他大，比他大的话，就将前面的数字往后挪，因此类推： 12345678910111213141516171819202122232425/** * 插入排序 */ func insertionSort(sources: [Int]) -&gt; [Int] &#123; var sources = sources for i in 1..&lt;sources.count &#123; let e = sources[i] var j = i - 1 while ( j &gt;= 0 &amp;&amp; sources[j] &gt; e) &#123; sources[j + 1] = sources[j] j = j - 1 &#125; sources[j+1] = e &#125; return sources &#125; 递归排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 归并排序 */ func mergeSort(sources: [Int]) -&gt; [Int] &#123; var sources = sources __mergeSort(sources: &amp;sources, l: 0, r: sources.count - 1) return sources &#125; func __mergeSort( sources: inout [Int], l: Int, r: Int) &#123; if l &gt;= r &#123; return &#125; let mid: Int = (l + r) / 2 __mergeSort(sources: &amp;sources, l: l, r: mid) __mergeSort(sources: &amp;sources, l: mid+1, r: r) __merge(sources: &amp;sources, l: l, mid: mid, r: r) &#125; // [l...mid] [mid+1...r] func __merge(sources: inout [Int], l: Int, mid: Int, r: Int) &#123; var aux = [Int]() for i in l...r &#123; aux.insert(sources[i], at: i-l) &#125; var i: Int = l var j: Int = mid + 1 for k in l...r &#123; if i &gt; mid &#123; sources[k] = aux[j-l] j = j + 1 &#125; else if j &gt; r &#123; sources[k] = aux[i-l] i = i + 1 &#125; else if aux[i-l] &lt; aux[j-l] &#123; sources[k] = aux[i-l] i = i + 1 &#125; else &#123; sources[k] = aux[j-l] j = j + 1 &#125; &#125; &#125; 1.3 测试： 如何调用： 12345678910override func viewDidLoad() &#123; super.viewDidLoad() let arr = Helper.generateSources(count: 1_000) let arr1 = arr Helper.executeTime(whichFunctionName: "插入排序", testSources: arr, operation: insertionSort) Helper.executeTime(whichFunctionName: "选择排序", testSources: arr1, operation: selectionSort) &#125; 控制台的打印： 12执行插入排序花费0.016882956s执行选择排序花费0.023320019s]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Android开发基础笔记Tips]]></title>
    <url>%2F2017%2F05%2F31%2F20170531%2F</url>
    <content type="text"><![CDATA[学习Android, 最近正好有时间，可以系统的看看Android的系统开发，记录下学习的笔记，供今后参考。1.1 基础环境： 使用的IDE为：Android Studio. SDK 最低的版本为：Android 4.1. LinearLayout是布局组件，可以从继承关系上看出关系, 继承自View的子类ViewGroup，并且FrameLayout,TableLayout,RelativeLayout他们都是继承自ViewGroup 1234// 继承关系public class LinearLayout extends ViewGrouppublic abstract class ViewGroup extends View implements ViewParent, ViewManager 1.2 UI属性:123match_parent: 视图与其父视图大小相同wrap_content: 视图将根据展示的内容自动调整大小android:orientation: LinearLayout 具有的属性，决定子组件是“水平”还是“垂直”排列 字符串，对某个组件setString的时候，你会发现是这样写的：@string/xxxx, 这里需要注意一下：android:text属性值不是字符串值，而是对字符串资源的应用，其实这时候你setString的时候，实际上是去app/res/values的文件夹中查找strings.xml。 1&lt;string name="xxxx"&gt;YYYYYY&lt;/string&gt; 随意创建一个文件，系统会默认给我们创建一些代码： 这里的R.java文件是在代码编译的时候创建的: 1234567public class QuizActivity extends AppCompatActivity &#123; @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_quiz);&#125; AppCompatActivity是Activity的子类 activity创建完后，需要获取自己的界面： 123public void setContentView(@LayoutRes int layoutResID) &#123;&#125; 这里的layoutResID就是要在资源中来寻找相应的资源。资源文件需要从app/res目录下寻找，和TextView中获取字符串的方法是一样的，需要去app/res/values中的strings.xml中去寻找： 123public final void setText(@StringRes int resid) &#123;&#125; 1.3 按钮的点击：1234567mNextButton = (Button) findViewById(R.id.next_button); mNextButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); 1.4 Toast的提示信息：1Toast.makeText(CurrentActivity.this, R.string.xxx, Toast.LENGTH_SHORT).show(); 1.5 生命周期 不存在 -&gt;(onCreate)-&gt; 停止（不可见）-&gt;(onStart)-&gt;暂停（可见）-&gt; (onResume) 运行（可见 &amp; 在前台） 运行（可见 &amp; 在前台）-&gt;(onPause)-&gt; 暂停（可见 -&gt;(onStop)-&gt; 停止（不可见 -&gt;(onDestory)-&gt; 不存在 在创建了Activity之后，并且此实例出现在屏幕之前会调用onCreate的方法 转屏幕的时候，生命周期的改变： 当屏幕发生转动的时候，Activity的生命周期会从新再走一遍，也就是 上面的会先按照 2 -&gt; 1,每次转屏都会这样。 想要在转屏的时候，保存数据，可以调用下面onSaveInstanceState的方法来保存数据，下次在需要的时候，可以获取数据： 1234567891011121314@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putInt(KEY_INDEX, mCurrentIndex);&#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (savedInstanceState != null) &#123; mCurrentIndex = savedInstanceState.getInt(KEY_INDEX); &#125; &#125; 但是转屏并且保存数据的生命周期方法的调用顺序为： onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestory()]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习爬虫Scrapy[官网教程]]]></title>
    <url>%2F2017%2F05%2F25%2F20170525%2F</url>
    <content type="text"><![CDATA[1.学习爬虫框架 Scrapy 前几天一直在正Django的框架，现在基本上已经ok了，如果我们需要自己创建属于自己的网站、需要前台展示数据，后台可以编辑数据，可以插入到数据库，可以建立自己的数据类型，使用Django已经够了，那么现在有一个很重要的难题：数据从哪里来？怎么获取？如何存取？-&gt; Scrapy能够很好满足我们这些需求。 目前文档是线上最新的版本:Scrapy 1.3[https://docs.scrapy.org/en/latest/] 1.1 什么是Scrapy scrapy是一个web端抓取网站数据的框架，可以用来数据挖掘，信息处理等等 1.2 安装Scrapy 安装scrapy官网建议两种途径： 1.使用conda:12conda install -c conda-forge scrapy 2.使用pip: 12pip install Scrapy 官方建议，我们在安装Scrapy的时候，最好安装自己创建的虚拟环境中a dedicated virtualenv，这样至少不会与系统的包产生冲突。 virtualenv的安装网址为：[http://sourabhbajaj.com/mac-setup/Python/virtualenv.html] 12345678910//1.cd myproject///2.virtualenv venv // 如果你的系统已经安装了python2已经python3，但是你现在想建立一个python3的环境// virtualenv -p python3 envname//3.source venv/bin/activate//4.pip install Scrapy 执行完上面的4行命令，此时应该就可以安装好了Scrapy了。 执行一下pip list，看一下安装scrapy系统默认给我们安装了什么： 1234567891011121314151617181920212223242526272829303132333435(venv) ➜ venv pip listPackage Version---------------- -------appdirs 1.4.3asn1crypto 0.22.0attrs 17.1.0Automat 0.6.0cffi 1.10.0constantly 15.1.0cryptography 1.8.1cssselect 1.0.1enum34 1.1.6idna 2.5incremental 16.10.1ipaddress 1.0.18lxml 3.7.3packaging 16.8parsel 1.2.0pip 9.0.1pyasn1 0.2.3pyasn1-modules 0.0.8pycparser 2.17PyDispatcher 2.0.5pyOpenSSL 17.0.0pyparsing 2.2.0queuelib 1.4.2Scrapy 1.3.3service-identity 16.0.0setuptools 35.0.2six 1.10.0Twisted 17.1.0w3lib 1.17.0wheel 0.29.0zope.interface 4.4.1 lxml[http://lxml.de/], 高效的xml和html的解析框架，最低版本为3.4 parsel[https://pypi.python.org/pypi/parsel] ,在lxml的封装，解析html/xml的数据 w3lib[https://pypi.python.org/pypi/w3lib], 处理页面的url以及encodings twisted[https://twistedmatrix.com/trac/], 异步的网络请求框架。最低版本为：14.0 cryptography和pyOpenSSL(最低版本为0.14) 多重网络安全 1.3 开始抓取数据： 现在我们开始爬取页面，这里就爬取一下这个页面：http://quotes.toscrape.com/，这个网站列举了很多著名的导演，这个抓取的目的有下面几个： 创建一个新的Scrapy对象. 写一个spider对象抓取网站，并且解析数据 用命令行导出抓取的数据 改变规则，递归的抓取数据 运用spider的参数 1.3.1 新建scrapy项目12345678910//1.scrapy startproject tutorial//2.New Scrapy project 'tutorial', using template directory '/Users/gonghuan/Desktop/myproject/venv/lib/python2.7/site-packages/scrapy/templates/project', created in: /Users/gonghuan/Desktop/myproject/venv/tutorialYou can start your first spider with: cd tutorial scrapy genspider example example.com 1.3.2 创建我们第一个spider1234567891011121314151617181920import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): page = response.url.split("/")[-2] filename = 'quotes-%s.html' % page with open(filename, 'wb') as f: f.write(response.body) self.log('Saved file %s' % filename) spider是Scrapy用来抓取数据的类 必须要继承scrapy.Spider，并且要初始化请求，抓取规则，解析数据的规则等等 name被赋值为quotes,这是作为项目的唯一标示符，必须唯一的。 start_requests的方法，必须要返回一个可以递归的request请求。 parse的方法，用来处理下载下来的response，response的参数保存在TextResponse的实例中。 parse的作用：1: 解析response,并将爬去下来的dics解析成我们需要的数据，2: 并且找到新的url数据，并且创建新的request 最后执行scrapy crawl quotes,这个命令quotes就是我们刚才定义的name,然后他们将会向quotes.toscrape.com这个域名发起请求,终端也会出现下面的返回： 1234567891011... (omitted for brevity)2016-12-16 21:24:05 [scrapy.core.engine] INFO: Spider opened2016-12-16 21:24:05 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)2016-12-16 21:24:05 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:60232016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (404) &lt;GET http://quotes.toscrape.com/robots.txt&gt; (referer: None)2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://quotes.toscrape.com/page/1/&gt; (referer: None)2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://quotes.toscrape.com/page/2/&gt; (referer: None)2016-12-16 21:24:05 [quotes] DEBUG: Saved file quotes-1.html2016-12-16 21:24:05 [quotes] DEBUG: Saved file quotes-2.html2016-12-16 21:24:05 [scrapy.core.engine] INFO: Closing spider (finished)... 此时检查项目的文件夹，会出现quotes-1.html、quotes-2.html这样的两个文件，就代表已经成功抓取下来了。 刚才在start_requests的函数中，我们返回了scrapy.Request的对象，当这些请求一旦接受到服务器返回的response的时候，就会立刻调用callback的方法，也就是parse的方法，这个方法会包含刚才我们的请求的url以及相应的参数。 1.3.3 简写代码 其实我们发现start_requests其实就是通过对于的url生成相应的scrapy.Request的对象，但其实我们可以不用实现start_requests的方法，我们可以直接定义一个start_urls的列表，里面的元素就是相应的请求url,一旦你定义了这个对象，start_requests会默认从start_urls来获取url 即使在你的代码中没有指定的callback函数，parse的函数也会默认来处理每个url发起的请求，主要也是因为parse是系统默认的方法（当你没有准确的指定callback） 修改为如下的代码： 123456789101112131415import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] def parse(self, response): page = response.url.split("/")[-2] filename = 'quotes-%s.html' % page with open(filename, 'wb') as f: f.write(response.body) 1.3.4 解析数据 官方的建议，最好的解析是在shell [https://docs.scrapy.org/en/latest/topics/shell.html#topics-shell] 的操作下，在我们刚才创建的虚拟环境下执行如下的脚本scrapy shell &quot;http://quotes.toscrape.com/page/1/&quot; 看到如下的终端返回： 123456789101112131415[ ... Scrapy log here ... ]2016-09-19 12:09:27 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://quotes.toscrape.com/page/1/&gt; (referer: None)[s] Available Scrapy objects:[s] scrapy scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s] crawler &lt;scrapy.crawler.Crawler object at 0x7fa91d888c90&gt;[s] item &#123;&#125;[s] request &lt;GET http://quotes.toscrape.com/page/1/&gt;[s] response &lt;200 http://quotes.toscrape.com/page/1/&gt;[s] settings &lt;scrapy.settings.Settings object at 0x7fa91d888c10&gt;[s] spider &lt;DefaultSpider 'default' at 0x7fa91c8af990&gt;[s] Useful shortcuts:[s] shelp() Shell help (print this help)[s] fetch(req_or_url) Fetch request (or URL) and update local objects[s] view(response) View response in a browser&gt;&gt;&gt; 我们如何获取response里面的元素呢？可以通过css [https://www.w3.org/TR/selectors/] 执行response.css(&#39;title&#39;),就可以在终端看到如下的返回： 1[&lt;Selector xpath='descendant-or-self::title' data='&lt;title&gt;Quotes to Scrape&lt;/title&gt;'&gt;] 执行response.css(&#39;title&#39;)返回的是一个类似列表的一个东西，这个东西叫做SelectorList,这个列表里面就是搜索的对象，这些对象是Selector,这些Selector就是包装这些XML/HTML的外壳。你可以直接通过Selector直接获得里面的值： 12&gt;&gt;&gt; response.css('title').extract()['&lt;title&gt;Quotes to Scrape&lt;/title&gt;'] 你会发现还是一个列表，不是我们想要的值，这时我们就需要对css进行过滤，添加::text，就表示我们想要的只是&lt;title&gt;标签中对应的值 12&gt;&gt;&gt; response.css('title::text').extract()['Quotes to Scrape'] 返回的还是一个列表，但是你确定你需要的是第一个元素的话，可以这样直接使用extract_first取得列表中的元素,这样为了避免产生IndexError： 12&gt;&gt;&gt; response.css('title::text').extract_first()'Quotes to Scrape' 除了使用extract()以及extract_first(),还是可以使用re()，就是通过正则来筛选解析的数据 123456&gt;&gt;&gt; response.css('title::text').re(r'Quotes.*')['Quotes to Scrape']&gt;&gt;&gt; response.css('title::text').re(r'Q\w+')['Quotes']&gt;&gt;&gt; response.css('title::text').re(r'(\w+) to (\w+)')['Quotes', 'Scrape'] 1.3.4 除了使用CSS，你也可以使用XPath来查找元素 例如： 1234&gt;&gt;&gt; response.xpath('//title')[&lt;Selector xpath='//title' data='&lt;title&gt;Quotes to Scrape&lt;/title&gt;'&gt;]&gt;&gt;&gt; response.xpath('//title/text()').extract_first()'Quotes to Scrape' XPath是非常形象具体，并且功能强大的，CSS的选择器也是通过一些接口来转化为XPath的，虽然XPath没有CSS那么出名，但是它还是非常强大的，官方也是建议学习使用XPath，给出相关的链接： [https://docs.scrapy.org/en/latest/topics/selectors.html#topics-selectors] [http://zvon.org/comp/r/tut-XPath_1.html] [http://plasmasturm.org/log/xpath101/] 1.3.5 解析数据 现在你已经知道了一些关于选择器，获取数据的方法，现在就可以完善我们之前的爬虫了 刚才我们爬去的的页面中，你会发现每个http://quotes.toscrape.com都含有一下的html： 123456789101112131415&lt;div class="quote"&gt; &lt;span class="text"&gt;“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”&lt;/span&gt; &lt;span&gt; by &lt;small class="author"&gt;Albert Einstein&lt;/small&gt; &lt;a href="/author/Albert-Einstein"&gt;(about)&lt;/a&gt; &lt;/span&gt; &lt;div class="tags"&gt; Tags: &lt;a class="tag" href="/tag/change/page/1/"&gt;change&lt;/a&gt; &lt;a class="tag" href="/tag/deep-thoughts/page/1/"&gt;deep-thoughts&lt;/a&gt; &lt;a class="tag" href="/tag/thinking/page/1/"&gt;thinking&lt;/a&gt; &lt;a class="tag" href="/tag/world/page/1/"&gt;world&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 还是通过shell的方法来测试，执行下面的代码: 1234//1.scrapy shell 'http://quotes.toscrape.com//2.response.css("div.quote") 当然也可以把筛选后的数据，复制给每个变量： 1quote = response.css("div.quote")[0] 现在也可以通过解析quote来获得下面的值：title/author/tag 123456789&gt;&gt;&gt; title = quote.css("span.text::text").extract_first()&gt;&gt;&gt; title'“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”'&gt;&gt;&gt; author = quote.css("small.author::text").extract_first()&gt;&gt;&gt; author'Albert Einstein'&gt;&gt;&gt; tags = quote.css("div.tags a.tag::text").extract()&gt;&gt;&gt; tags['change', 'deep-thoughts', 'thinking', 'world'] 已经可以知道我们是如何来获取数据的了，现在我们就可以遍历循环，并且将爬去下来的数据插入到我们的Python的字典数据结构中： 123456789&gt;&gt;&gt; for quote in response.css("div.quote"):... text = quote.css("span.text::text").extract_first()... author = quote.css("small.author::text").extract_first()... tags = quote.css("div.tags a.tag::text").extract()... print(dict(text=text, author=author, tags=tags))&#123;'tags': ['change', 'deep-thoughts', 'thinking', 'world'], 'author': 'Albert Einstein', 'text': '“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”'&#125;&#123;'tags': ['abilities', 'choices'], 'author': 'J.K. Rowling', 'text': '“It is our choices, Harry, that show what we truly are, far more than our abilities.”'&#125; ... a few more of these, omitted for brevity&gt;&gt;&gt; 1.3.5 更新我们的spide代码： 现在回到我们之前新建的spider的项目中去，到目前为止，我们还真正去获取任何的数据，我们只是做了一件事情，就是讲页面的html的代码保存在本地，我们可以将每个页面的数据，爬去下来，并且将这些数据放下Python的字典的数据结构中，并且返回回去。代码如下： 1234567891011121314151617import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('small.author::text').extract_first(), 'tags': quote.css('div.tags a.tag::text').extract(), &#125; 运行之后看到如下的返回： 12342016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://quotes.toscrape.com/page/1/&gt;&#123;'tags': ['life', 'love'], 'author': 'André Gide', 'text': '“It is better to be hated for what you are than to be loved for what you are not.”'&#125;2016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://quotes.toscrape.com/page/1/&gt;&#123;'tags': ['edison', 'failure', 'inspirational', 'paraphrased'], 'author': 'Thomas A. Edison', 'text': "“I have not failed. I've just found 10,000 ways that won't work.”"&#125; 1.3.6 保存数据 最简单的保存形式就是通过Feed exports [https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-exports] 这里我们可以执行下面的代码保存为json的格式： 1scrapy crawl quotes -o quotes.json 此时在文件中就会出现一个名叫quotes.json的文件，其实就是我们刚才爬去下来的数据。 其实在一些简单的爬虫项目中，这样写，其实已经足够了，但是在一些复杂的大型项目中，可以写Item Pipeline[https://docs.scrapy.org/en/latest/topics/item-pipeline.html#topics-item-pipeline], 其实这个功能就是对应的项目的中tutorial/pipelines.py, scrapy项目默认会帮你创建的。 1.3.7 获取更多的url 其实刚才在项目中，我们只是爬去了两个url，并且也知道如何去解析他们，但是可能我们需要的是爬去整个网站的url，比如我们在爬去一个页面的时候，遇到这样的html,我们就需要计算并且获取对应的url: 12345&lt;ul class="pager"&gt; &lt;li class="next"&gt; &lt;a href="/page/2/"&gt;Next &lt;span aria-hidden="true"&gt;&amp;rarr;&lt;/span&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 此时你可能需要获取的是a里面对应的href的值： 12&gt;&gt;&gt; response.css('li.next a::attr(href)').extract_first()'/page/2/' 现在我们可以修改我们的spider的代码了，并且不需要指定几个url了，我们需要将这些逻辑都放到parse的函数中去： 123456789101112131415161718192021import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', ] def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('small.author::text').extract_first(), 'tags': quote.css('div.tags a.tag::text').extract(), &#125; next_page = response.css('li.next a::attr(href)').extract_first() if next_page is not None: next_page = response.urljoin(next_page) yield scrapy.Request(next_page, callback=self.parse) 上面的代码很容易看出，当解析完数据之后，我们就会寻找下一页的url,并且发现这里写的是一个相对的url，这里可以通过urljoin()这个函数来拼接url，并且yields回去一个新的request，当拿到的respsonse又会回到parse的函数中来解析 scrapy的下载机制：当你yields一个新的请求，scrapy会发送改请求，并注册一个回调方法，以便在完成的时候能够解析他。 1.3.8 简化发送的请求 为了简化发送的请求，我们可以用response.follow, 而不是新建一个新的Request 1234567891011121314151617181920import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', ] def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('span small::text').extract_first(), 'tags': quote.css('div.tags a.tag::text').extract(), &#125; next_page = response.css('li.next a::attr(href)').extract_first() if next_page is not None: yield response.follow(next_page, callback=self.parse) 与scrapy.Request不同，response.follow是支持相对路径，其实就是这个follow它会替我们做response.urljoin,并且response.follow返回是一个Request的实例。 之前的代码，取的是列表中的第一项元素，但是我们也可以枚举这个列表，来调用response.follow 123456for href in response.css('li.next a::attr(href)'): yield response.follow(href, callback=self.parse) // 也可以进行简写for a in response.css('li.next a'): yield response.follow(a, callback=self.parse) 对于抓取作者信息，我们可以自定义自己的回调函数 1234567891011121314151617181920212223242526import scrapyclass AuthorSpider(scrapy.Spider): name = 'author' start_urls = ['http://quotes.toscrape.com/'] def parse(self, response): # follow links to author pages for href in response.css('.author + a::attr(href)'): yield response.follow(href, self.parse_author) # follow pagination links for href in response.css('li.next a::attr(href)'): yield response.follow(href, self.parse) def parse_author(self, response): def extract_with_css(query): return response.css(query).extract_first().strip() yield &#123; 'name': extract_with_css('h3.author-title::text'), 'birthdate': extract_with_css('.author-born-date::text'), 'bio': extract_with_css('.author-description::text'), &#125; 这里当找到author相关的链接，我们会回调我们自定义的函数parse_author,在这个函数里，我们顶一个帮助函数，帮助我们具体还获取里面的值，在parse函数中，我们会找到下一页的请求，然后继续发送请求，回调函数还是我们的parse的函数. 这里有个关键的问题，我们不需要担心同一个url发送多次，易导致进入死循环，Scrapy默认是能够过滤已经请求过的url，并且你还可以通过在settings.py的文件中设置DUPEFILTER_CLASS [https://docs.scrapy.org/en/latest/topics/settings.html#std:setting-DUPEFILTER_CLASS]。 1.3.9 在spider中传递参数 我们可以通过下面的-a来传递参数，这些参数默认是传递到Spider中的__init__函数中去，并且能够成为spider的属性值 1scrapy crawl quotes -o quotes-humor.json -a tag=humor 例如上面的命令，我传递了tag的值，这样我就可以在我的spider项目中能够通过self.tag来获取传进来的值，也可以通过这样的值来请求准确url,其实就是请求的是这样的url: http://quotes.toscrape.com/tag/humor 12345678910111213141516171819202122import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): url = 'http://quotes.toscrape.com/' tag = getattr(self, 'tag', None) if tag is not None: url = url + 'tag/' + tag yield scrapy.Request(url, self.parse) def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('small.author::text').extract_first(), &#125; next_page = response.css('li.next a::attr(href)').extract_first() if next_page is not None:]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django第五/六部分，基本的测试用例[官网教程]]]></title>
    <url>%2F2017%2F05%2F17%2F20170517%2F</url>
    <content type="text"><![CDATA[经过前四部分的学习，此时我们已经创建了我们第一个app：polls, 并且根据我们自己的需求，修改了url，修改了对应的view函数，连接数据库，插入数据库相应的数据，并将数据库里的数据捞出来，显示在模板上，这似乎就是我们在前四部分做的事情，说起来简单，但是做好、做精细却不容易。下面我们会为我们的app提供测试的功能。1.1 什么是自动测试 测试是对代码对好检测，测试能够针对不同层面进行测试(1.对某个特定的方法是否按照预期返回都能够进行测试。2.有的人会对整个项目的整体操作做相应的测试用户输入具体的某些值，得到预期的一些值)，其实这里的测试与第二部分运用shell的操作是差不多的。 而自动化测试区别在于，一旦你的自动化测试生成了之后，当你修改了代码之后，你不需要再花时间人工去测试，自动可以测试你的代码。 1.2 写第一个测试用例 polls的应用存在一些小bug，在Question的Model中定义了这样一个方法，这个方法能够判断我们发布的时间是不是在一天之内的，如果在一天之内就会返回True，否则就是False： 12def was_published_recently(self): return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1) 运用shell,在终端输入python manager.py shell，然后再输入下面的代码： 12345678&gt;&gt;&gt; import datetime&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; from polls.models import Question&gt;&gt;&gt; # create a Question instance with pub_date 30 days in the future&gt;&gt;&gt; future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))&gt;&gt;&gt; # was it published recently?&gt;&gt;&gt; future_question.was_published_recently()True 这个显然是错误的，距离我发布的时间30天，应该返回false 开始写自动化测试来发现暴露这个bug，至少在今后，不会再出现类似的问题了。 打开polls/tests.py的文件，添加如下的代码： 123456789101112131415161718import datetimefrom django.utils import timezonefrom django.test import TestCasefrom .models import Questionclass QuestionMethodTests(TestCase): def test_was_published_recently_with_future_question(self): """ was_published_recently() should return False for questions whose pub_date is in the future. """ time = timezone.now() + datetime.timedelta(days=30) future_question = Question(pub_date=time) self.assertIs(future_question.was_published_recently(), False) 这里创建了一个django.test.TestCase的子类，实例化了一个Question的对象，通过传入一个time的参数，然后断言question的was_published_recently()返回的为false 执行python manage.py test polls 12345678910111213141516Creating test database for alias 'default'...System check identified no issues (0 silenced).F======================================================================FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionMethodTests)----------------------------------------------------------------------Traceback (most recent call last): File "/path/to/mysite/polls/tests.py", line 16, in test_was_published_recently_with_future_question self.assertIs(future_question.was_published_recently(), False)AssertionError: True is not False----------------------------------------------------------------------Ran 1 test in 0.001sFAILED (failures=1)Destroying test database for alias 'default'... 执行python manage.py test polls是让Django去在polls这个app 应用中查找你写的测试用例，当Django查找到django.test.TestCase的子类，Django将会为这个测试创建一些数据，Django接着去寻找以test开头的测试方法,在刚才我们创建的test_was_published_recently_with_future_question这个函数，第二行中，传入了一个pub_date创建了一个Question的实例对象，接着就断言question的was_published_recently()返回为False, 但是实际上返回的是True,这也就是导致我们断言失败的原因所在。 1.3 修改bug 此时我们已经知道了如果我们设置的pub_date是将来的时间的话，Question.was_published_recently()就应该返回的是False,所以打开polls/models.py修改为： 123def was_published_recently(self): now = timezone.now() return now - datetime.timedelta(days=1) &lt;= self.pub_date &lt;= now 再次执行python manage.py test polls就会得到下面的正确反馈： 123456789GhCoder_Site python manage.py test pollsCreating test database for alias 'default'...System check identified no issues (0 silenced)..----------------------------------------------------------------------Ran 1 test in 0.002sOKDestroying test database for alias 'default'... 1.4 更全面的测试 依旧测试was_published_recently()这个函数，让我们的测试更加全面，添加如下的两个方法： 1234567891011121314151617def test_was_published_recently_with_old_question(self): """ was_published_recently() should return False for questions whose pub_date is older than 1 day. """ time = timezone.now() - datetime.timedelta(days=30) old_question = Question(pub_date=time) self.assertIs(old_question.was_published_recently(), False)def test_was_published_recently_with_recent_question(self): """ was_published_recently() should return True for questions whose pub_date is within the last day. """ time = timezone.now() - datetime.timedelta(hours=1) recent_question = Question(pub_date=time) self.assertIs(recent_question.was_published_recently(), True) 这里我们添加了超过一天的数据，以及一天之内的数据，测试返回回来都和我们的断言是一样的，这样我就能更加保证我们的代码没有问题了。 1.5 测试View 之前我们的测试都是测试驱动的标准来写测试的，但是这也并不能涵盖我们所有的代码，测试驱动我们重点去关心具体的代码实现，但是测试view的话，我们重点是通过浏览器来模拟用户进行测试。 1.5.1 Django测试客户端 Django是提供测试客户端来模拟用户来具体与view进行交互，我们可以在tests.py文件中写代码，也可以通过shell来完成。 其实说白了就是看不到界面，完全是通过shell脚本来模拟请求，能够正常解析到response、response_code、response.content、response.context等等 我们先通过shell来完成测试环境的设置: 1234567891011121314151617181920212223242526272829//1.python manager.py shell//2.&gt;&gt;&gt; from django.test.utils import setup_test_environment&gt;&gt;&gt; setup_test_environment()&gt;&gt;&gt; from django.test import Client&gt;&gt;&gt; # create an instance of the client for our use&gt;&gt;&gt; client = Client()&gt;&gt;&gt; # get a response from '/'&gt;&gt;&gt; response = client.get('/')&gt;&gt;&gt; # we should expect a 404 from that address; if you instead see an&gt;&gt;&gt; # "Invalid HTTP_HOST header" error and a 400 response, you probably&gt;&gt;&gt; # omitted the setup_test_environment() call described earlier.&gt;&gt;&gt; response.status_code404&gt;&gt;&gt; # on the other hand we should expect to find something at '/polls/'&gt;&gt;&gt; # we'll use 'reverse()' rather than a hardcoded URL&gt;&gt;&gt; from django.urls import reverse&gt;&gt;&gt; response = client.get(reverse('polls:index'))&gt;&gt;&gt; response.status_code200&gt;&gt;&gt; response.contentb'\n &lt;ul&gt;\n \n &lt;li&gt;&lt;a href="/polls/1/"&gt;What&amp;#39;s up?&lt;/a&gt;&lt;/li&gt;\n \n &lt;/ul&gt;\n\n'&gt;&gt;&gt; response.context['latest_question_list']&lt;QuerySet [&lt;Question: What's up?&gt;]&gt; 1.5.2 改善我们的View 在第四部分的时候，我们依据类的形式来创建了view,在polls/views.py的文件中： 1234567class IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list' def get_queryset(self): """Return the last five published questions.""" return Question.objects.order_by('-pub_date')[:5] 这是之前的代码，我们现在想修改get_queryset这个方法，之前是返回最后的5条数据，现在我们希望通过时间来过滤： 1234567891011//1.from django.utils import timezonedef get_queryset(self): """ Return the last five published questions (not including those set to be published in the future). """ return Question.objects.filter( pub_date__lte=timezone.now() ).order_by('-pub_date')[:5] Question.objects.filter(pub_date__lte=timezone.now())意思是：查找Question,并且他们的pub_date&lt;=现在的时候。 1.5.3 测试我们新的页面 在polls/tests.py的文件中添加如下的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//1.from django.urls import reversedef create_question(question_text, days): """ Creates a question with the given `question_text` and published the given number of `days` offset to now (negative for questions published in the past, positive for questions that have yet to be published). """ time = timezone.now() + datetime.timedelta(days=days) return Question.objects.create(question_text=question_text, pub_date=time)class QuestionViewTests(TestCase): def test_index_view_with_no_questions(self): """ If no questions exist, an appropriate message should be displayed. """ response = self.client.get(reverse('polls:index')) self.assertEqual(response.status_code, 200) self.assertContains(response, "No polls are available.") self.assertQuerysetEqual(response.context['latest_question_list'], []) def test_index_view_with_a_past_question(self): """ Questions with a pub_date in the past should be displayed on the index page. """ create_question(question_text="Past question.", days=-30) response = self.client.get(reverse('polls:index')) self.assertQuerysetEqual( response.context['latest_question_list'], ['&lt;Question: Past question.&gt;'] ) def test_index_view_with_a_future_question(self): """ Questions with a pub_date in the future should not be displayed on the index page. """ create_question(question_text="Future question.", days=30) response = self.client.get(reverse('polls:index')) self.assertContains(response, "No polls are available.") self.assertQuerysetEqual(response.context['latest_question_list'], []) def test_index_view_with_future_question_and_past_question(self): """ Even if both past and future questions exist, only past questions should be displayed. """ create_question(question_text="Past question.", days=-30) create_question(question_text="Future question.", days=30) response = self.client.get(reverse('polls:index')) self.assertQuerysetEqual( response.context['latest_question_list'], ['&lt;Question: Past question.&gt;'] ) def test_index_view_with_two_past_questions(self): """ The questions index page may display multiple questions. """ create_question(question_text="Past question 1.", days=-30) create_question(question_text="Past question 2.", days=-5) response = self.client.get(reverse('polls:index')) self.assertQuerysetEqual( response.context['latest_question_list'], ['&lt;Question: Past question 2.&gt;', '&lt;Question: Past question 1.&gt;'] ) 仔细看一下你就会发现： 这里create_question是一个快生产question的函数。 test_index_view_with_a_past_question我们不创建任何的question对象，我们的的一些断言，这个测试就素在测试如果数据库里面没有我们需要的数据，我们该如何处理，检测了response以及response.context。这里用到了assertContains() and assertQuerysetEqual() 在下面的测试同样。 1.5.4 测试详情页面 打开polls/views.py修改为,详情页面也要过滤掉将来的时间点的数据： 1234567class DetailView(generic.DetailView): ... def get_queryset(self): """ Excludes any questions that aren't published yet. """ return Question.objects.filter(pub_date__lte=timezone.now()) 此时再添加一下测试数据，打开polls/tests.py： 1234567891011121314151617181920class QuestionIndexDetailTests(TestCase): def test_detail_view_with_a_future_question(self): """ The detail view of a question with a pub_date in the future should return a 404 not found. """ future_question = create_question(question_text='Future question.', days=5) url = reverse('polls:detail', args=(future_question.id,)) response = self.client.get(url) self.assertEqual(response.status_code, 404) def test_detail_view_with_a_past_question(self): """ The detail view of a question with a pub_date in the past should display the question's text. """ past_question = create_question(question_text='Past Question.', days=-5) url = reverse('polls:detail', args=(past_question.id,)) response = self.client.get(url) self.assertContains(response, past_question.question_text) 123456789GhCoder_Site python manage.py test pollsCreating test database for alias 'default'...System check identified no issues (0 silenced)...........----------------------------------------------------------------------Ran 10 tests in 0.058sOKDestroying test database for alias 'default'... 还有一些进阶的测试工具： Selenium[http://seleniumhq.org/] LiveServerTestCase [https://docs.djangoproject.com/en/1.11/topics/testing/tools/#django.test.LiveServerTestCase] 1.5.5 自定义项目app1.添加css样式： 在创建项目的时候，项目中的HTML/JavaScript/CSS都是用来呈现页面以及布局的时候需要用到，我们应该把这些文件统一放到static files的文件里面去。这里django.contrib.staticfiles替我们都做好了。 首先在polls的目录中添加static的文件夹，Django将会自动去找static文件夹中的文件。 在static下面在添加polls文件夹，再在polls文件夹里面再添加style.css,里面添加如下的操作： 123li a &#123; color: green;&#125; 然后在polls/templates/polls/index.html文件里面添加如下的代码： 123&#123; % load static % &#125;&lt;link rel="stylesheet" type="text/css" href="&#123; % static 'polls/style.css' % &#125;" /&gt; { % static % }tag能够生成static文件夹的绝对url。 2.添加图片的样式 创建一个images文件夹，路径为polls/static/polls/images/xxx.png,然后就可以在css的文件中添加如下的代码 123body &#123; background: white url("images/xxx.png") no-repeat right bottom;&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django第四部分，细化系统模板[官网教程]]]></title>
    <url>%2F2017%2F05%2F16%2F20170516%2F</url>
    <content type="text"><![CDATA[1.8：细化views页面的功能 打开polls/detail.html的文件，将其中的代码修改一下： 123456789101112&lt;h1&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/h1&gt;&#123; % if error_message % &#125;&lt;p&gt;&lt;strong&gt;&#123; &#123; error_message &#125; &#125;&lt;/strong&gt;&lt;/p&gt;&#123; % endif % &#125;&lt;form action="&#123; % url 'polls:vote' question.id % &#125;" method="post"&gt;&#123; % csrf_token % &#125;&#123; % for choice in question.choice_set.all % &#125; &lt;input type="radio" name="choice" id="choice&#123; &#123; forloop.counter &#125; &#125;" value="&#123; &#123; choice.id &#125; &#125;" /&gt; &lt;label for="choice&#123; &#123; forloop.counter &#125; &#125;"&gt;&#123; &#123; choice.choice_text &#125; &#125;&lt;/label&gt;&lt;br /&gt;&#123; % endfor % &#125;&lt;input type="submit" value="Vote" /&gt;&lt;/form&gt; 这里的改动比较大,在页面上显示了勾选按钮，value与question.id类型关联起来了，name的值写死为choice,当某人勾选了一个，并且点击的提交的按钮，那么就会post的数据为：choice=#。 定义了一个form, 并且method=post forloop.counter就指明了多少次循环 因为我们运用了post的请求，所以我们需要防止他们跨域请求，并且篡改数据，这里我们需要感谢Django,他给我们定义了{ % csrf_token % }这个标记，就是为了防止被篡改数据 现在来处理post过来的请求，并且做出相应的处理。打开polls/urls.py 1234567891011121314151617181920212223from django.shortcuts import get_object_or_404, renderfrom django.http import HttpResponseRedirect, HttpResponsefrom django.urls import reversefrom .models import Choice, Question# ...def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST['choice']) except (KeyError, Choice.DoesNotExist): # Redisplay the question voting form. return render(request, 'polls/detail.html', &#123; 'question': question, 'error_message': "You didn't select a choice.", &#125;) else: selected_choice.votes += 1 selected_choice.save() # Always return an HttpResponseRedirect after successfully dealing # with POST data. This prevents data from being posted twice if a # user hits the Back button. return HttpResponseRedirect(reverse('polls:results', args=(question.id,))) 这里的request.POST就是个字典类型的数据，通过取request.POST[&#39;choice&#39;]得到的是选中的id，并且以字符串的形式返回。 在request.POST中，提供了KeyError的错误，当你要去的key不在post的字段里面，就会拿到这样的错误。 注意到当成功之后，相应的votes加1之后，我们返回的不是HttpResponse,而是HttpResponseRedirect,接受一个参数，这个参数就是成功之后调教的url。并且官网提出了，当成功完成post之后，就是应该跳转页面，这不仅仅是Django要求的，而是作为web开发所必须要养成的好习惯。 最后注意到我们在HttpResponseRedirect里面用到了reverse()，其实他的作用就是为了解决硬编码的问题，其实reverse(&#39;polls:results&#39;, args=(question.id,) = /polls/3/results/ 看到成功返回的页面为results的函数： 12345from django.shortcuts import get_object_or_404, renderdef results(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/results.html', &#123;'question': question&#125;) 在这里需要创建polls/results.html的模板页面 123456789&lt;h1&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/h1&gt;&lt;ul&gt;&#123; % for choice in question.choice_set.all % &#125; &lt;li&gt;&#123; &#123; choice.choice_text &#125; &#125; -- &#123; &#123; choice.votes &#125; &#125; vote&#123; &#123; choice.votes|pluralize &#125; &#125;&lt;/li&gt;&#123; % endfor % &#125;&lt;/ul&gt;&lt;a href="&#123; % url 'polls:detail' question.id % &#125;"&gt;Vote again?&lt;/a&gt; 此时选中之后的结果页面就可以正常显示的了： 123456What's up? Not much -- 4 vote s The sky -- 1 vote Just hacking again -- 0 vote s Just kidding -- 0 vote s 这里官网提了一个意见，就是selected_choice = question.choice_set.get(pk=request.POST[&#39;choice&#39;]),这个数据是从数据库中取出来的，但是如果两个用户同一时间做次操作，并且进行投票的话，这里会存在一个竞争的关系，这里官网给出的意见是用函数F()来避免这种情况 [https://docs.djangoproject.com/en/1.11/ref/models/expressions/#avoiding-race-conditions-using-f] 1.9：使用通用视图让代码少点 可能你已经发现了，detail和results的页面非常的相近，这里我们会做出改变 这些views页面都做了一些类似的事情，根据URL从数据库中得到数据,加载模板，并且显示出来，这些操作都是雷同的，此时我们可以通过通用视图来减少我们的代码量 1.9.1 修改URLconf 打开polls/urls.py文件修改为： 1234567891011from django.conf.urls import urlfrom . import viewsapp_name = 'polls'urlpatterns = [ url(r'^$', views.IndexView.as_view(), name='index'), url(r'^(?P&lt;pk&gt;[0-9]+)/$', views.DetailView.as_view(), name='detail'), url(r'^(?P&lt;pk&gt;[0-9]+)/results/$', views.ResultsView.as_view(), name='results'), url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),] 这里做了两个改变1：一个是讲参数的名字丢该为了pk, 2:将views只想的函数方式修改了，只是是在同一个类中调用不同的属性是使用方法，现在是调用不同类的方式，或许是类是更好的条件继承、重用代码的吧。 1.9.2 修改views 打开polls/views.py文件修改为： 1234567891011121314151617181920212223242526272829from django.shortcuts import get_object_or_404, renderfrom django.http import HttpResponseRedirectfrom django.urls import reversefrom django.views import genericfrom .models import Choice, Questionclass IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list' def get_queryset(self): """Return the last five published questions.""" return Question.objects.order_by('-pub_date')[:5]class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html'class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html'def vote(request, question_id): ... # same as above, no changes needed. 这里用到了ListView和DetailView，分别需要去去继承他们，他们其实都是一些抽象的概念。 每个通用视图都需要一个model的字段，因此你需要丢一个Model字段。 DetailView显示需要从URL中获取pk的字段，所以我们在写url的时候，将quesiton_id的参数名字修改为了pk。 DetailView需要使用的模板名字为：&lt;app name&gt;/&lt;module name&gt;_detail.name，在我们现在的项目中，模板的名字为：polls/question_detail.html,这里模板名字的存在是为告诉Django需要使用特定名称的模板，而不是使用默认生成的模板，这里你就会发现detail和result虽然继承的都是DetailView,但是他们指定了不同模板名字，这就让显示不同的模板名字。 类似的ListView也是一样的，默认Django会去找&lt;app name&gt;/&lt;model name&gt;_list.html，但是由于我们定义了template_name,因此他只会找polls/index.html 在之前我们都是通过丢一个名叫question以及latest_question_list的值给模板的，对DetailView而言：question的值是默认会被生成的，因为我们运用了Django model(Question),Django 是能够通过名字自动检测的。 而在ListView中，我们用到了latest_question_list,Django默认会生成question_list,但是我们需要的是latest_question_list,因此我们需要覆写这个属性context_object_name，将它准确定义为我们需要的名字latest_question_list 模板这部分 确实还是挺复杂的，主要是我们不太熟悉一些字段的用法、含义，可以自行参考 [https://docs.djangoproject.com/en/1.11/topics/class-based-views/]]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django第三部分，重点关注如何运用系统模板,并且自定义URL[官网教程]]]></title>
    <url>%2F2017%2F05%2F15%2F20170515%2F</url>
    <content type="text"><![CDATA[1.开始写新的Views 打开polls/views.py文件，写views的函数和写其他的函数略有不同，因为他们可以接受参数，写入下面的代码： 123456789def detail(request, question_id): return HttpResponse("You're looking at question %s." % question_id)def results(request, question_id): response = "You're looking at the results of question %s." return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse("You're voting on question %s." % question_id) 写完了views的这些函数，其实这些函数只是简单的返回一些字符串，下面来出来一些关于url的函数处理polls/urls.py： 1234567891011121314from django.conf.urls import urlfrom . import viewsurlpatterns = [ # ex: /polls/ url(r'^$', views.index, name='index'), # ex: /polls/5/ url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'), # ex: /polls/5/results/ url(r'^(?P&lt;question_id&gt;[0-9]+)/results/$', views.results, name='results'), # ex: /polls/5/vote/ url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),] 现在当你再去访问/polls/34、/polls/34/results/、/polls/34/vote/你就可以看到，这些能够对应到刚才你写的几个函数了。 当你访问的url为/polls/34/的时候，此时Django将先找到项目中的urls模块，（其实就是加载项目中的urls.py的文件），它将会找到名为urlpatterns这个列表，看看在你的列表的项目中，有没有出现你访问的url的条目，当系统找到^polls/之后，就会去掉^polls/,然后将剩下的34/发送给polls.urls进行更深的解析，终于在polls/urls.py的urlpatterns列表中找到了这行代码url(r&#39;^(?P&lt;question_id&gt;[0-9]+)/$&#39;, views.detail, name=&#39;detail&#39;),因为这行代码的第二个参数是指向的views.detail函数句柄，这里其实执行的是下面的代码： 1detail(request=&lt;HttpRequest object&gt;, question_id='34') 而这里的question_id=&#39;34&#39;,部分是因为我们写的这部分正则:(?P&lt;question_id&gt;[0-9]+),括号所包含的内容将作为一个参数传给对应的函数, ?P&lt;question_id&gt;定义了传给函数的形参名 1.1:具体处理一些页面的请求 每个页面应该可以做1-2件事情，返回http的请求，可以通过HttpResponse[https://docs.djangoproject.com/en/1.11/ref/request-response/#django.http.HttpResponse], 还有些未找到页面Django也给了响应的便利返回Http404[https://docs.djangoproject.com/en/1.11/topics/http/views/#django.http.Http404], 其实说白了每个页面它希望得到的是HttpResponse能够处理正常的逻辑，要不然就是exception，打开polls/views.py 1234567from django.http import HttpResponsefrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] output = ', '.join([q.question_text for q in latest_question_list]) return HttpResponse(output) 这里当你再次访问/polls/的时候，你就可以看到在第二部分数据库操作插入的数据了，但是我们如何让我们的界面显示的好看一点呢，这里就需要引入template模板，现在我们polls的文件夹中创建templates文件夹，Django将会自动去这个文件夹中去寻找模板。 这里还要说一下，如果在settings.py文件中APP_DIRS设置的是TRUE的话，Django的模板默认就会去INSTALL_APPS去寻找对应的templates的文件夹。 系统给我们的意见是，让我们在templates文件夹下面再创建一个polls的文件夹，在polls的文件夹内再创建index.html,总的路径应该是这样的：polls/templates/polls/index.html，这样创建的是为了方便我们在调用模板的时候方便、易读polls/index.html 下面再刚创建的index.html中添加如下的代码： 123456789&#123; % if latest_question_list % &#125; &lt;ul&gt; &#123; % for question in latest_question_list % &#125; &lt;li&gt;&lt;a href="/polls/&#123; &#123; question.id &#125; &#125;/"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt; &#123; % endfor % &#125; &lt;/ul&gt;&#123; % else % &#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123; % endif % &#125; 显示的模板已经写完了，下面再将之前的views.py的函数修改一下： 12345678910111213from django.http import HttpResponsefrom django.template import loaderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] template = loader.get_template('polls/index.html') context = &#123; 'latest_question_list': latest_question_list, &#125; return HttpResponse(template.render(context, request)) 1.2：render()函数 这里我们可以通过render()函数来简写我们的模板，直接可以通过render函数,并且也不需要放回HttpResponse,也不需要loader函数来载入我们的模板了 render()函数将request作为第一个参数，模板的名字作为第二个参数，第三个参数为可选参数，返回的是HttpResponse的对象。 用render之后，代码改变为： 123456789from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 1.3：下面来处理一下404的错误页面1234567891011from django.http import Http404from django.shortcuts import renderfrom .models import Question# ...def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404("Question does not exist") return render(request, 'polls/detail.html', &#123;'question': question&#125;) 这里的在详情页面的时候，如果访问主键不存在的话，我们应该抛出404的错误，让我们能够捕捉到错误。 同时在polls/detail.html的文件中添加如在下代码： 1&#123; &#123; question &#125; &#125; 1.4：404函数的缩写get_object_or_404()1234567from django.shortcuts import get_object_or_404, renderfrom .models import Question# ...def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;) get_object_or_404()函数第一个参数为：Django的Model, 第二个参数，是一个列表，是任意数量参数的列表,当get不到任何东西的时候，就会返回Http404的对象。 1.5:使用系统模板 回到我们之前写的polls/detail.html，改为这样： 123456&lt;h1&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/h1&gt;&lt;ul&gt;&#123; % for choice in question.choice_set.all % &#125; &lt;li&gt;&#123; &#123; choice.choice_text &#125; &#125;&lt;/li&gt;&#123; % endfor % &#125;&lt;/ul&gt; 当我们运用系统的模板的时候，可以看到系统是用的点语法,例如{ { question.question_text } }，Django 先去寻找question这个对象是否存在，然后再去寻找question是否存在question_text的这个属性值。 { % for % }这是一个for循环，question.choice_set.all=question.choice_set.all()这个返回的是一个包含Choice，可迭代的集合。 系统模板更多信息[https://docs.djangoproject.com/en/1.11/topics/templates/] 1.6：去除系统模板中的硬编码 我们在写index.html模板的时候，我们写到这样一段代码&lt;li&gt;&lt;a href=&quot;/polls/{ { question.id } }/&quot;&gt;{ { question.question_text } }&lt;/a&gt;&lt;/li&gt;，通过我们在views.py的函数中将question的数据中传递到模板上，并且在模板上这样使用，道理上来说是没毛病的。 这样写的问题，在于模板和数据，紧密耦合在一起，在很多模板中，假如我一旦修改了URL，我们就得去一堆的模板中修改这个写死的url。 因为我们在polls/urls.py中已经用到了url的模块,那么我们就能够通过之前定义的url,并且知道下面将要跳转url。 123urlpatterns = [ url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'), ] 因此可以修改为： 1234//修改前&lt;li&gt;&lt;a href="/polls/&#123; &#123; question.id &#125; &#125;/"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt;//修改后&lt;li&gt;&lt;a href="&#123; % url 'detail' question.id % &#125;"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt; 如果你想要修改详情页面的url，假如现在的url不是之前的polls/12,而是最新的url：polls/specifics/12,此时你只需要在你的url中加一个一个url，例如： 123...url(r'^specifics/(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'),... 1.7:URL的命名空间 在这个项目中，我们仅仅只是创建了一个app，叫做polls,但是在实际的Django的项目中，其实会有10、20几个app, 那么我们在使用之前提到的{ % url % },Django如何区分url呢？比如我polls下面有一个detail，假如我还有个新的app，下面也有一个detail,我改怎么区分呢？ 官方的意思是去定义app_name,打开polls/url.py 1234567891011from django.conf.urls import urlfrom . import viewsapp_name = 'polls'urlpatterns = [ url(r'^$', views.index, name='index'), url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'), url(r'^(?P&lt;question_id&gt;[0-9]+)/results/$', views.results, name='results'), url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),] 并且家模板里面的代码也做一下修改： 12345//未使用app_name&lt;li&gt;&lt;a href="&#123; % url 'detail' question.id % &#125;"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt;//使用app_name = 'polls'&lt;li&gt;&lt;a href="&#123; % url 'polls:detail' question.id % &#125;"&gt;&#123; &#123; question.question_text &#125; &#125;&lt;/a&gt;&lt;/li&gt; ps: 最后说一下，hexo好坑呐！在markdown格式中不能出现”{ {“ 以及 “{ %”,必须要在中间添加个空格。哎！无语。。。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django第二部分[官网教程]]]></title>
    <url>%2F2017%2F05%2F14%2F20170514%2F</url>
    <content type="text"><![CDATA[学习Django的第二部分[对官网Demo教程的翻译，以及自己的一些认识]第一部分，已经使用了Django写了一个简单View，并且配置了我们的url，是的我们能够正常访问到我们新建的View页面。今天开始第二部分： 我们需要到xxxProject/settings.py文件去修改配置，我们这里主要讲的是数据库的配置。 Django默认是安装了SQLite，这里不需要额外下载什么。 如果需要用到别的数据库，可以去settings文件去修改。默认是这样的： 123456DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125; &#125; 这里解释一下： ENGINE字段根据选用数据库的不同，Django已经给我们做好了数据的枚举：django.db.backends.sqlite3,django.db.backends.postgresql,django.db.backends.mysql,django.db.backends.oracle NAME数据库的名字 如果你和我一样，不是选用的Django默认的使用的sqlite的话，除此之外，还需要配置USER,PASSWORD,HOST,我用的mysql,这里如果需要正常使用mysql的话，可能还需要安装其他的一些依赖库，这里可以参考 [https://docs.djangoproject.com/en/1.11/topics/install/#database-installation] 官方给出了demo，可以根据自己的需求进行修改 12345678910 DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.postgresql', 'NAME': 'mydatabase', 'USER': 'mydatabaseuser', 'PASSWORD': 'mypassword', 'HOST': '127.0.0.1', 'PORT': '5432', &#125;&#125; 数据库配置好之后，然后我们开始配置TIME_ZONE,默认值为America/Chicago,如果在中国的话，应该是Asia/Shanghai北京时间吧，至于时区的列表： [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones]。这里重点说一下INSTALLED_APPS的配置，放在这个选项中的列表的字符串，代表运行Django同事需要激活这些对应的Django应用，app能够在不同的project中使用，并且你也能够打包、分发给别人来使用。12345678910# Application definition INSTALLED_APPS = [ 'django.contrib.admin',//Django 的默认后台系统 'django.contrib.auth', //Django 的认证系统 'django.contrib.contenttypes', // 管理内容类型 'django.contrib.sessions', // 管理sessions 'django.contrib.messages', // 管理消息 'django.contrib.staticfiles', // 管理静态文件 ] 这些已经安装的，默认的app，至少会在后台建立1的表（现在还没有建立表呢），在执行了python manage.py migrate才会在我们的数据库里建立这里app的表。 这里我在linux环境下安装的时候，遇到点问题：包了很多奇葩的错误，这里我就说几个，我遇到的，其他我没有列出来的，可能你直接google就能找到了： 通过sudo pip install MySQL-python来安装mysql的时候包这个错 1Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-7696Ic/MySQL-python/ 直接在命令行运行:12sudo apt install libmysqlclient-devpip install mysql 还有其他的一些小问题： [http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c]执行完 python manage.py migrate 就会看到终端出现这些字样，就代表你的表已经成功生成了, 如果不信，你也可以打开自己mysql数据库，就会发现Django已经为我生成好了表了。12345678910111213141516Operations to perform: Apply all migrations: admin, auth, contenttypes, sessionsRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying sessions.0001_initial... OK 官方给出了关于migrate命令的作用，Django会去project中找我的settings.py文件，并且找到INSTALL_APPS，为这些安装的app创建必要的表, 并且官方也说了，这些默认的INSTALL_APPS并不是每个人都需要他，当不需要的时候，删除掉xxxProject/settings.py文件中对应的app，然后执行migrate就可以了。创建Model好了，现在开始我们需要创建Model了，这也是我为什么喜欢Django的最最根本的原因，Django中的Model不同于其他语言中的Model对象，而是实质性的涉及到数据库的数据。 之前在第一章的时候，我们创建了一个属于我们自己的app，名字叫做polls的app,我们现在围绕这个app创建属于这个app的Model，我们创建两个Model，一个叫做Question,一个叫Choice,Question含有一个问题字段和发布时间的字段，Choice含有两个字段一个choice的Text的字段、一个vote的字段，并且一个choice会关联一个question字段，现在开始编辑polls/models.py文件： 123456789101112from django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 这些model的类都是django.db.models.Model的子类。 这里的每个字段对应的就是数据库中的每个字段。 一些字段是需要必须的参数的，比如CharField必须有参数max_length的存在。 一些字段也可以传入一些可选的参数: 比如：IntegerField的default的字段。 ForeignKey可以通过外键的形式，将choice的类型关联到Question的类型上去，在Django的model数据中，是支持一对多，一对一，多对多的。 激活Model上面虽然外面已经创建了这两个Model，但是目前为止，还没有和我现在有Django项目关联上，在此之前，我们必须要先激活Model,并且根据我们的model代码创建出对应的数据库表的信息。 首先我们先要将我们的polls的app安装上。去settings.py的INSTALL_APPS的列表中，将我们的pollsapp添加进去。 1234567891011 INSTALLED_APPS = [ 'polls.apps.PollsConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 现在执行python manage.py makemigrations polls得到下面的信息： 1234polls/migrations/0001_initial.py - Create model Choice - Create model Question - Add field question to choice 执行makemigrations的目的是告诉Django，你已经对你Model对了一些改变，你希望Django能够保存你的这些改变。 Migrations对你Model的变化仅仅只是将这些变化以文件的形式保存在磁盘中，这些文件，你都是可以看到的polls/migrations/0001_initial.py 下面要执行migrate,将你之前Model的改变同步到数据库表中去。我们为了能够看到具体做了那些SQL上的改变，可以运行sqlmigrate,这个命令会返回对应SQL语句。执行之后，你会看到下面的返回： 12345678910111213141516GhCoder_Site python manage.py sqlmigrate polls 0001BEGIN;---- Create model Choice--CREATE TABLE `polls_choice` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `choice_text` varchar(200) NOT NULL, `votes` integer NOT NULL);---- Create model Question--CREATE TABLE `polls_question` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `question_text` varchar(200) NOT NULL, `pub_date` datetime(6) NOT NULL);---- Add field question to choice--ALTER TABLE `polls_choice` ADD COLUMN `question_id` integer NOT NULL;ALTER TABLE `polls_choice` ADD CONSTRAINT `polls_choice_question_id_c5b4b260_fk_polls_question_id` FOREIGN KEY (`question_id`) REFERENCES `polls_question` (`id`);COMMIT; 注意到下面一些关键的点： 首先表的名字是 AppName_ModelName。 每个表中为我们自动创建了主键：id类型，并且默认不为空，且自增。 外键的添加是ModelName_id。 sqlmigrate其实并没有对数据库做出相应的操作，他只是告诉你这是他将要对数据库所做出的操作，并且能够让你检查是否正确。 123456789//执行下面的命令python manage.py migrate//得到下面的信息GhCoder_Site python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, polls, sessionsRunning migrations: Applying polls.0001_initial... OK 现在你也可以通过phpmyadmin，可以看到数据库中的表都已经如我们之前model定义的那样，创建好了，这就是migragte的魅力所在，可能你在以后的开发中，你根本不需要时不时的去修改数据库，增加修改某个字段，通过migrate就能够实现，只要三个步骤，你就可以显示了了。 改变Model，增加修改字段都可以。 执行python manage.py makemigrations来为这些变化创建migrations。 执行python manage.py migrate来修改数据库表。 运用API来操作ModelDjango非常贴心地为我们提供shell的命令来操作数据。 在操作shell之前，我们首先要运行python manage.py shell。 然后我们就进入到了python的运行环境。下面这段代码是官网给我的，我觉得很详细，也很具体，我只是翻译了一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 从polls.models文件中导入Question、Choice&gt;&gt;&gt; from polls.models import Question, Choice # Import the model classes we just wrote.// 在系统的内存中是否存在Question类型的数据# No questions are in the system yet.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet []&gt;# Create a new Question.# Support for time zones is enabled in the default settings file, so# Django expects a datetime with tzinfo for pub_date. Use timezone.now()# instead of datetime.datetime.now() and it will do the right thing.// 这里创建了Question的数据结构，这个数据结构需要两个字段，一个是字符串，一个date的数据类型，date的数据类型，我这里用timezone来创建，因此这里导入了timezone的模块&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; q = Question(question_text="What's new?", pub_date=timezone.now())// q的实例执行保存的方法# Save the object into the database. You have to call save() explicitly.&gt;&gt;&gt; q.save()// 直接返回里q的id，这里返回的是int，还是long，是根据你选择的数据库来定的。# Now it has an ID. Note that this might say "1L" instead of "1", depending# on which database you're using. That's no biggie; it just means your# database backend prefers to return integers as Python long integer# objects.&gt;&gt;&gt; q.id1// 返回question的实例的属性值# Access model field values via Python attributes.&gt;&gt;&gt; q.question_text"What's new?"&gt;&gt;&gt; q.pub_datedatetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=&lt;UTC&gt;)// 同时也可以修改question实例的属性值，但是要记住保存# Change values by changing the attributes, then calling save().&gt;&gt;&gt; q.question_text = "What's up?"&gt;&gt;&gt; q.save()// 返回内存中所有的Question类型的数据# objects.all() displays all the questions in the database.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: Question object&gt;]&gt; 这里在执行Question.objects.all()，返回是&lt;QuerySet [&lt;Question: Question object&gt;]&gt;，这样可读性不是很好，官方的意思说：只要分别在model文件中覆写def __str__(self):方法就可以了。1234567891011121314from django.db import modelsfrom django.utils.encoding import python_2_unicode_compatible@python_2_unicode_compatible # only if you need to support Python 2class Question(models.Model): # ... def __str__(self): return self.question_text@python_2_unicode_compatible # only if you need to support Python 2class Choice(models.Model): # ... def __str__(self): return self.choice_text 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&gt;&gt;&gt; from polls.models import Question, Choice# Make sure our __str__() addition worked.// 从这里就可以看到我们刚才覆写“def __str__(self):”的作用了&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: What's up?&gt;]&gt;# Django provides a rich database lookup API that's entirely driven by# keyword arguments.// Django 可以通过filter字段来过滤// 也可以通过双下划线来自定义过滤条件&gt;&gt;&gt; Question.objects.filter(id=1)&lt;QuerySet [&lt;Question: What's up?&gt;]&gt;&gt;&gt;&gt; Question.objects.filter(question_text__startswith='What')&lt;QuerySet [&lt;Question: What's up?&gt;]&gt;# Get the question that was published this year.// 导入一些自定义的模块// 生成响应的实例对象，并且用来过滤&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; current_year = timezone.now().year&gt;&gt;&gt; Question.objects.get(pub_date__year=current_year)&lt;Question: What's up?&gt;# Request an ID that doesn't exist, this will raise an exception.// 如果直接通过get的方式来获取某些对象的话，如果对象不存在的话，就会抛出异常&gt;&gt;&gt; Question.objects.get(id=2)Traceback (most recent call last): ...DoesNotExist: Question matching query does not exist.# Lookup by a primary key is the most common case, so Django provides a# shortcut for primary-key exact lookups.# The following is identical to Question.objects.get(id=1).// 查询主键&gt;&gt;&gt; Question.objects.get(pk=1)&lt;Question: What's up?&gt;# Make sure our custom method worked.&gt;&gt;&gt; q = Question.objects.get(pk=1)// 调用自定义的方法&gt;&gt;&gt; q.was_published_recently()True# Give the Question a couple of Choices. The create call constructs a new# Choice object, does the INSERT statement, adds the choice to the set# of available choices and returns the new Choice object. Django creates# a set to hold the "other side" of a ForeignKey relation# (e.g. a question's choice) which can be accessed via the API.&gt;&gt;&gt; q = Question.objects.get(pk=1)# Display any choices from the related object set -- none so far.// 通过set能过找到有没有对应的外键对象存在&gt;&gt;&gt; q.choice_set.all()&lt;QuerySet []&gt;# Create three choices.// 通过create能够创建关联的对象，创建的方法其实就是就可以把它看做是简单的实例化方法，传入对应的字段就可以了。&gt;&gt;&gt; q.choice_set.create(choice_text='Not much', votes=0)&lt;Choice: Not much&gt;&gt;&gt;&gt; q.choice_set.create(choice_text='The sky', votes=0)&lt;Choice: The sky&gt;&gt;&gt;&gt; c = q.choice_set.create(choice_text='Just hacking again', votes=0)# Choice objects have API access to their related Question objects.&gt;&gt;&gt; c.question&lt;Question: What's up?&gt;# And vice versa: Question objects get access to Choice objects.// 取得所有区这个Question 关联的 Choice的对象&gt;&gt;&gt; q.choice_set.all()&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;&gt;&gt;&gt; q.choice_set.count()3# The API automatically follows relationships as far as you need.# Use double underscores to separate relationships.# This works as many levels deep as you want; there's no limit.# Find all Choices for any question whose pub_date is in this year# (reusing the 'current_year' variable we created above).// 可以通过双下划线，在数据结构中找到关系&gt;&gt;&gt; Choice.objects.filter(question__pub_date__year=current_year)&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;// 删除数据# Let's delete one of the choices. Use delete() for that.&gt;&gt;&gt; c = q.choice_set.filter(choice_text__startswith='Just hacking')&gt;&gt;&gt; c.delete() 这些shell的操作，你以为都只是在内存里操作的话，你就错了。打开你的数据库，你会发现你的这些shell的操作会实际操作到数据库的 系统更多关于shell的操作在这里，你可以自己去查阅 [https://docs.djangoproject.com/en/1.11/ref/models/relations/] [https://docs.djangoproject.com/en/1.11/topics/db/queries/] [https://docs.djangoproject.com/en/1.11/topics/db/queries/#field-lookups-intro] 下面介绍Django的一个牛逼的后台，他叫admin 首先我们得先创建我们的最高权限的用户。 执行python manage.py createsuperuser 123456GhCoder_Site python manage.py createsuperuserUsername (leave blank to use 'parallels'): gonghuanEmail address: 11@11.comPassword: Password (again): Superuser created successfully. 再次执行python manage.py runserver,然后打开http://127.0.0.1:8000/admin/，你就会看到admin的后台登录系统了。 登录进去，你只会看见user,group的模块，那如何把我们之前创建的polls的app，展现在后台呢？方便我编辑数据？ 打开polls/admin.py,并且我们需要告诉admin，Question这个数据类型，admin是有数据接口的，可以控制他。编辑如下代码： 12345from django.contrib import adminfrom .models import Questionadmin.site.register(Question) *此时我们就可以看到我们的Question的配置出现在后台了，并且可以增删改查了。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Python的Django框架搭建前后台[官网教程]]]></title>
    <url>%2F2017%2F05%2F09%2F20170509%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python–不管你之前写过多少其他语言，当你有一天回来写python的时候，你就会觉得“世界是那么的美好！”今天我就来讲讲我是如何用Python的django[https://docs.djangoproject.com] 来搭建后台的： 我是在mac的环境下搭建的，linux也试过，其实搭建环境来说，都差不多,这里就以mac为例子 首先mac或者linux的话，应该是自带python的，如果是win系统的话，你可以自己去下载[https://www.python.org/] 数据库（database）也是很重要的，因为我们想做的是一个健全的前后台系统、后期还需要给移动端提供数据来源，所以我这里选用mysql，我这里偷懒就用了MAMP一键安装，在linux下也有相应的叫LAMP,一步步点击下一步之后就完成了，这里我用的是Apache+Mysql。安装完成之后，你就可以看到mysql的端口、密码、用户名啥的（这里可能有些坑，需要自己去踩，这里就不说了，自行google),这里要弄好，因为我们后续在配置django的时候需要配置。 下面进入正式安装jdango，官方建议通过pip去安装。 1pip install -U pip 如果报错就执行下面的命令：1pip install --upgrade pip 不出意外的话，此时你的pip，应该已经安装好了。下面来安装环境，这里环境，官方的意见是安装virtualenv或者virtualenvwrapper,这里其实我都试过，你也可以试试，这里就用virtualenv [https://virtualenv.pypa.io/en/stable/] , 你也可以自己参考一下virtualenv的官方介绍 [https://virtualenv.pypa.io/en/stable/installation/] :1[sudo] pip install virtualenv 最后执行安装django的命令：1pip install Django 官方给出了严重你是否安装成功，以及安装的版本,当成功打印的时候，就代表已经成功安装了。123&gt;&gt;&gt; import django&gt;&gt;&gt; print(django.get_version())1.11 也可以直接在终端输入1python -m django --version 直接开始项目： 直接在终端输入：此时在当前路径下就会看到我们创建的GhCoder_Site文件夹： 1django-admin startproject GhCoder_Site 文件夹的结构： 123456├── GhCoder_Site│ ├── __init__.py│ ├── settings.py│ ├── urls.py│ └── wsgi.py└── manage.py 这里官方给了一些解释，我觉得很好，有助于我们的理解, 其实我之前都是写php的，深有感触–note: If your background is in plain old PHP (with no use of modern frameworks), you’re probably used to putting code under the Web server’s document root (in a place such as /var/www). With Django, you don’t do that. It’s not a good idea to put any of this Python code within your Web server’s document root, because it risks the possibility that people may be able to view your code over the Web. That’s not good for security.Put your code in some directory outside of the document root, such as /home/mycode. 官方对于每个文件夹以及文件的作用都做了一定的解释，这里我就不解释了很通俗易懂： The outer GhCoder_Site/ root directory is just a container for your project. Its name doesn’t matter to Django; you can rename it to anything you like. manage.py: A command-line utility that lets you interact with this Django project in various ways. You can read all the details about manage.py in django-admin and manage.py. The inner GhCoder_Site/ directory is the actual Python package for your project. Its name is the Python package name you’ll need to use to import anything inside it (e.g. GhCoder_Site.urls). GhCoder_Site/init.py: An empty file that tells Python that this directory should be considered a Python package. If you’re a Python beginner, read more about packages in the official Python docs. GhCoder_Site/settings.py: Settings/configuration for this Django project. Django settings will tell you all about how settings work. GhCoder_Site/urls.py: The URL declarations for this Django project; a “table of contents” of your Django-powered site. You can read more about URLs in URL dispatcher. GhCoder_Site/wsgi.py: An entry-point for WSGI-compatible web servers to serve your project. See How to deploy with WSGI for more details. 下面直接运行下面的命令：1python manage.py runserver 你会得到这样的反馈：123456789101112Performing system checks...System check identified no issues (0 silenced).//请忽略这里You have 13 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.Run 'python manage.py migrate' to apply them.May 09, 2017 - 07:08:16Django version 1.11, using settings 'GhCoder_Site.settings'Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 此时打开浏览器，输入http://127.0.0.1:8000/，你就会看到Welcome to Django” page, in pleasant, light-blue pastel. It worked!，就代表成功了。切换端口：1python manage.py runserver 8080 切换ip、监听所有的ip1python manage.py runserver 0:8000 Django的开发模式都是依赖于一个个app，这一点我非常喜欢，后期就算项目很大，也不会很乱，创建第一个app:1python manage.py startapp polls 结构如下：123456789101112131415161718192021.├── db.sqlite3├── GhCoder_Site│ ├── __init__.py│ ├── __init__.pyc│ ├── settings.py│ ├── settings.pyc│ ├── urls.py│ ├── urls.pyc│ ├── wsgi.py│ └── wsgi.pyc├── manage.py└── polls ├── admin.py ├── apps.py ├── __init__.py ├── migrations │ └── __init__.py ├── models.py ├── tests.py └── views.py 创建第一个views,打开polls/views.py,输入：12def index(request): return HttpResponse("Hello, world, You are in polls app") 现在配置一下路由,到文件polls,创建一个名为urls.py的文件。将之前写的view和这个url对应上：123456from django.conf.urls import url from . import views urlpatterns = [ url(r'^$', views.index, name='index') ] 最后将app的url，写到项目中的urls.py的文件里面去，到GhCoder_Site/urls.py文件里面，添加如下代码：1234567from django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [ url(r'^polls/', include('polls.urls')), url(r'^admin/', admin.site.urls),] 这里关于include的官方介绍： The include() function allows referencing other URLconfs. Note that the regular expressions for the include() function doesn’t have a $ (end-of-string match character) but rather a trailing slash. Whenever Django encounters include(), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing. The idea behind include() is to make it easy to plug-and-play URLs. Since polls are in their own URLconf (polls/urls.py), they can be placed under “/polls/”, or under “/fun_polls/”, or under “/content/polls/”, or any other path root, and the app will still work. 此时你访问http://127.0.0.1:8000/polls/就看到你刚才写的view以及url]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Python、Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object-C 网管、以及切换AppDelegate的RootViewCtroller]]></title>
    <url>%2F2017%2F05%2F05%2F20170505%2F</url>
    <content type="text"><![CDATA[昨天将最新版1.9.5发布上线。总结一下这一版本中踩过的坑。产品的需求： app中默认是游客身份，随着不同身份的切换，可能需要切换不同的网管。(假如请求的url为: http://www.siji.com/a.php,那么随着身份的切换的话，可能 http://www.siji.com需要修改为http://www.chengke.com)，并且有些请求，是不需要依赖身份的：(比如登录部分请求就是http://www.login.com/login.php、支付部分的请求就是http://www.pay.com/pay.php)。 app中需要区分两种身份(例如 1.司机身份 2.乘客身份)，未来可能还需要更多身份去切换，伴随着身份切换，可能UI上会发生重大的改变，例如：司机身份是UITabBarController为rootViewController的，乘客身份只是(UIViewController+UISlideViewController)侧滑的样式。 之前发布的版本，有一点很重的线程安全的问题，我没有考虑到，现在我已经做了响应的修改了。在关于能够修改字典、数组的方法中我都用到了NSRecursiveLock，从而能够保证线程是安全的。属性的相关安全性，我也查了些资料：[https://zhuanlan.zhihu.com/p/23998703] 解决第一个问题： 首先我这里希望我在app刚进来的时候，就配置好，并且我这里希望他是线程安全，并且方便get/set值。这里我选用单例。并且在系统刚进来的时候就配置, 我已经加入cocoapods了：[https://github.com/Ghstart/GateWayObject]： 12345678910111213141516171819- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[RootWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; //1.设置默认URL，就是其中一种身份对应的URL //2.设置一些URL的映射，不会根据之前身份设置来修改 [GateWayObject sharedInstanceWithDefaultURL:@"https://cz.redlion56.com/gwcz/" ReflectURLS:@&#123; @"user/login.do": @"https://login.redlion56.com/gwlogin/user/login.do", @"uic/user/logout.do": @"https://cz.redlion56.com/gwcz/uic/user/logout.do" &#125;]; // 3. 设置乘客身份对应的网管 [[GateWayObject currentGateWay] setGateWayURL:@"https://cz.redlion56.com/gwcz/" forKeyObject:carownerRole]; // 4.设置乘客对应的网管 [[GateWayObject currentGateWay] setGateWayURL:@"https://sj.redlion56.com/gwsj/" forKeyObject:driverRole];&#125; 123456789// 5.并且还可以根据相应的条件来切换网管 if (xxx) &#123; [[GateWayObject currentGateWay] swichGateWayBaseOn:carownerRole]; &#125; else &#123; [[GateWayObject currentGateWay] swichGateWayBaseOn:driverRole]; &#125; 12345678910// 7.直接可以取得次环境下对应的正确URL[self GET:[[GateWayObject currentGateWay] currentURLBaseOnRelativeURL:url] parameters:parameters success:^(NSURLSessionDataTask *task, id responseObject) &#123; &#125; &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; if (failure &amp;&amp; error.code != -999 &amp;&amp; ![error.localizedDescription isEqualToString:@"已取消"]) &#123; failure(error); &#125; &#125;]; 下面看一下我的.h文件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546@interface GateWayObject : NSObject@property (nonatomic, readonly) NSString *currentRelateURL;///////////-init-///////////////* ** 获得当前的网管 */+ (GateWayObject *)currentGateWay;/* ** 网管实例化方法 ** 默认网关 */+ (GateWayObject *)sharedInstanceWithDefaultURL:(NSString *)url;/* ** 网关实例化 ** 可以配置一些默认的URL对应的一些网关 */+ (GateWayObject *)sharedInstanceWithDefaultURL:(NSString *)url ReflectURLS:(NSDictionary *)reflectURLS;/* ** 设置网关 */- (void)setGateWayURL:(NSString *)url forKeyObject:(id)keyObject;/* ** 设置默认的一些网关，优先级仅次于http/https */- (void)setDefaultRelativeURL:(NSString *)relativeURL fullURL:(NSString *)fullURL;/* ** 根据之前的设置的身份切换网管 ** 返回值为true则切换成功 false失败 */- (BOOL)swichGateWayBaseOn:(id)keyObject;/* ** 取得当前URL */- (NSString *)currentURLBaseOnRelativeURL:(NSString *)url;@end 第二个问题的解决方案，自定义RootWindow,让它集成于 UIWindow，并且覆写，然后自己写一套新的stroyboard，每次身份切换的时候，直接切换keyWindow的rootViewController123456789101112131415161718192021222324252627- (void)setRootViewController:(UIViewController *)rootViewController&#123; // 这里我发现在某些设备上由于push、present之后就不能够正常销毁,这里就需要你去判断，做相应的pop、dismiss之后，在去setRootViewController // 但是后来又发现系统的navigation的栈，栈的弹出需要时间才能弹出，不是立刻弹出啊的，这里就很鸡肋了，目前我还没想到啥解决方案。 [UIViewController fastToRootVC]; //remove old rootViewController's sub views for (UIView* subView in self.rootViewController.view.subviews) &#123; [subView removeFromSuperview]; &#125; //remove old rootViewController's view [self.rootViewController.view removeFromSuperview]; //set new rootViewController [super setRootViewController:rootViewController]; //remove empty UILayoutContainerView(s) remaining on root window for (UIView *subView in self.subviews) &#123; if (subView.subviews.count == 0) &#123; [subView removeFromSuperview]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Object-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PHP7的新坑]]></title>
    <url>%2F2017%2F03%2F27%2F20170327%2F</url>
    <content type="text"><![CDATA[距离上次写PHP已经过了2、3年了，最近闲来无事，想再整整PHP。我是通过mac安装了虚拟机，Ubuntn16.04的版本，在安装PHP环境的时候，就发现很多坑，一些小问题google可以查到的我这里就不说了，在安装完Apache、PHP、Mysql的时候，并且安装完Phpmyadmin的时候，会报错： 1The mysqli extension is missing.... google一搜就会发现：1sudo apt-get install php5-mysql 这里对应的php5的安装，那你这里是写php7.0-mysql还是写php7.1-mysql就需要看你安装php的版本号了。你可以通过&lt;?php echo phpinfo();?&gt;、也可以通过php --version可以知道，你需要安装的是多少。在调用mysql的时候，之前我记得我很久之前就一直都在使用mysql_connect()这个函数来连接数据库，但是最近我发现我通过这个函数、没有任何的反馈，通过try/catch也没有任何error、这个问题一直纠结了好久，今天才发现原来在php7的版本的时候，已经完全废弃了这个函数了，而是已经使用mysqli_connect(),这里是PHP官方手册的说明：1234Warning本扩展自 PHP 5.5.0 起已废弃，并在自 PHP 7.0.0 开始被移除。应使用 MySQLi 或 PDO_MySQL 扩展来替换之。参见 MySQL：选择 API 指南以及相关 FAQ 来获取更多信息。用以替代本函数的有：mysqli_connect()PDO::__construct() 所以我这里就用mysqli_connect()来替换，我这里建立一个video的库，并且建了一个test的表：123456789101112131415161718192021222324$servername = "localhost";$username = "root";$password = "123456789";$dbname = "video";// Create connection$conn = new mysqli($servername, $username, $password, $dbname);// Check connectionif ($conn-&gt;connect_error) &#123; die("Connection failed: " . $conn-&gt;connect_error);&#125; $sql = "SELECT * FROM test";$result = $conn-&gt;query($sql);if($result -&gt; num_rows &gt; 0) &#123; while($row = $result -&gt; fetch_assoc()) &#123; echo "Name: ".$row["name"]."-Status: ".$row["status"]."-Time:".$row["time"]."&lt;br&gt;"; &#125;&#125; else &#123; echo 'no datas';&#125;$result-&gt;close();]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新Reveal2的一些问题]]></title>
    <url>%2F2017%2F03%2F15%2F20170315%2F</url>
    <content type="text"><![CDATA[最近任务也不是很多，尽量逼自己把每天学的一些的东西都记录下来。 这张图来自简书APP，也是一个朋友闻起来来的，他说这是在无数据、无网络的状态下就会出现这样的界面，这个是怎么做到的呢？ 1 . 我当时想了一下，还是觉得要用collectionView来实现吧，其实热门文章的内容，其实自己看就会发现，他就一种cell格式，而热门专题应该就是用collectionview来做的吧。 2 .后来一拍脑子觉得不对啊，这tm得多烦啊，而且这个仅仅只是无数据的一种页面的展示啊，要我做，那就直接一张image遮罩着不就行了。 猜想了半天还是用Reveal来看一下吧。1 .由于很长时间不用Reveal了，而且我之前的Reveal还是1.x的版本，然后用越狱机器一看，一直导入失败，一直在报这个错误(❌) The operation couldn’t be completed. The app is linked against an older version of the Reveal library. You may need to update the Reveal library in your app. 2 .后来发现之前导入到机器中的一个libReveal.dylib的文件以及找不到了，这下，我tm傻眼了，我一直以为让我更新一下这个所谓的动态库呢！ 后来google了一下，发现了官方的回复： We no longer ship a dynamic library starting with Reveal 2, we include an iOS 8+ framework instead. The good news is that you should be able to make a copy of, and rename the framework’s binary (RevealServer.framework/ReveaServer) to libReveal.dylib and then follow the instructions as before 最后还发现几个好玩的东西： 可以发现真的就如我的猜想，他其实这些都是之前就定死的一个image，遮罩在上面的，其他也就不用说了。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Reveal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试Swift搭建服务器-建立自己的网站]]></title>
    <url>%2F2017%2F02%2F25%2F20170225%2F</url>
    <content type="text"><![CDATA[学习Paul大神的swift-server，我也尝试用Swift来搭建自己的网站。这里主要依赖的是IBM开源的Kitura框架。 环境搭建 （Mac下） 因为我们是在自己的mac上搭建环境，所以需要下载Docker[https://docs.docker.com/docker-for-mac/] 这个软件，这个软件的作用就相当于一台看不见的虚拟机，能够在mac上运行Linux。 下载完成之后，建立根目录文件夹。 1234cd ~/Desktopmkdir servercd serverdocker run -itv $(pwd):/projects --name projects -w /projects -p 8089:8089 -p 8090:8090 -p 5984:5984 twostraws/server-side-swift /bin/bash 3 . 这里docker开头的命令，是让doker软件来运行的，其中’/projects’ 指的是文件内建立以projects开头的文件默认指向的是当前的文件路径，并且建立的8090、5984这两个端口。 4 . 建立好之后你就会看到类似如下的返回值： 1root@f2429f0045db:/projects# 建立第一个文件 运行如下命令： 1234cd ~/Desktop/servermkdir project1cd project1swift package init --type executable 最后一行命令可能比较困惑，其实这行命令就是告诉swift package（这里的swift package相当于OC中的cocoapods、或者NodeJS中的npm一样）,我们需要建立一个新的项目，’–type executable‘的意思是我们希望建立一个独立的部分。看到如下返回值就代表成功了：123456Creating executable package: project1Creating Package.swiftCreating .gitignoreCreating Sources/Creating Sources/main.swiftCreating Tests/ 2 .运行： 1swift build 3 . 再运行 1.build/debug/project1 当看到”Hello world!”就代表已经成功了。 4 .再运行 1swift package generate-xcodeproj 此时用Xcode打开刚刚生成的project1.xcodeproj,切换project1&gt;Sources&gt;project1,当控制台中打印“Hello world!” 5 . 找到Main.swift文件，更换内容，我们引入路由模块，并且实例化，并且监听8090端口 123456import Kituralet router = Router()Kitura.addHTTPServer(onPort: 8090, with: router)Kitura.run() 此时打开浏览器”http://localhost:8090&quot;,大功告成！！！ 环境搭建 （Linux下） 先下载适合你Linux版本的Swift的版本[https://swift.org/download/] 其实这里Kitura的官网给出了教程，你也可以按照官方的教程走下去。[http://www.kitura.io/en/starter/settingup.html] 12$ sudo apt-get update$ sudo apt-get install clang libicu-dev libcurl4-openssl-dev libssl-dev 1$ export PATH=&lt;path to uncompressed tar contents&gt;/usr/bin:$PATH 2 .这里已经介绍解释的很清楚了，就是将&lt;&gt;以及其中的内容替换成你刚才下载并解压下来的Swift包路径，假设我的路径为/home/gh/swift-3.0.2-release/, 那就可以在终端运行： 1$ export PATH=/home/gh/swift-3.0.2-release/usr/bin:$PATH 3 .紧接着运行,看到正常的返回就代表已经安装正常。 1swift --version 4 .下面的方法步骤就和之前在Mac上的配置是一样的了，你也可以参考Kitura的教程[http://www.kitura.io/en/starter/gettingstarted.html]]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习阿里开源项目BeeHive(三)]]></title>
    <url>%2F2016%2F12%2F01%2F20161201%2F</url>
    <content type="text"><![CDATA[最后总结一下整个BeeHive项目的搭建。以及我看完之后的一些质疑和想法，有些作者以及给出了回答，会在下一版本的更新中进行修改。 先贴上我自己画的一个提纲 首先，为什么每个ViewController都需要配备一个配备一个Module的文件？因为他需要通过+(void)load{}的方法，动态的将moduleInfo的信息存储下来，这里是存储在BHModuleManager文件中的self.BHModules此时这里存储的都是字符串，还没有创建为实例对象。为什么有些module的文件中没有load方法，但是他还是在启动之前也注册进去了呢？答：因为这里作者都是通过宏的的形式，来快速实现加载的信息，本质上和+(void)load{}是一样的。BH_EXPORT_MODULE(NO) 这里在官方的demo中看到TestAppDelegate进行了ModuleConfigName、ServiceConfigName的设置，不设置可以吗？答：可以！！这里在BHContext对象实例化的时候，已经默认设置了初始值了。 这里假如我有新的功能，我应该往哪里去添加呢？答：这里只是我的猜想-&gt;应该在BHContext中去添加，因为在BHContext实例化的时候，就顺带实例化了一系列的对象：BHShortCutItem、BHOpenURLItem、BHNotificationItem、BHUserActivity、BHConfig,并且这些对象都是单例，这里我保持我的态度。这里的if调试时作者的笔误，他会在下一版本更新 if ([BHInstance isKindOfClass:[BHContext class]]) {}1234567891011121314151617181920-(instancetype)init&#123; self = [super init]; if (self) &#123; self.modulesByName = [[NSMutableDictionary alloc] initWithCapacity:1]; self.servicesByName = [[NSMutableDictionary alloc] initWithCapacity:1]; self.moduleConfigName = @"BeeHive.bundle/BeeHive"; self.serviceConfigName = @"BeeHive.bundle/BHService";#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80400 self.touchShortcutItem = [BHShortcutItem new];#endif self.openURLItem = [BHOpenURLItem new]; self.notificationsItem = [BHNotificationsItem new]; self.userActivityItem = [BHUserActivityItem new]; &#125; return self;&#125; 1234567891011121314+(instancetype) shareInstance&#123; static dispatch_once_t p; static id BHInstance = nil; dispatch_once(&amp;p, ^&#123; BHInstance = [[[self class] alloc] init]; if ([BHInstance isKindOfClass:[BHContext class]]) &#123; ((BHContext *) BHInstance).config = [BHConfig shareInstance]; &#125; &#125;); return BHInstance;&#125; 系统是在什么时候载入本地的组件信息的呢？答：是在哎BeeHive调用setContext对象的时候，进行调用的。并且这里通过context中的文件名，进行拼接，返回plist文件的信息。 比起在这里将self.BHModules 文件信息换成了响应的实例对象 那看到各个Module都会调用modSetUp、modInit类似的方法，那这些方法是在什么时候调用的？答：是在调用父类的Appdelegate的方法的时候调用的， 初了一些主动调用的上面这些方法，那什么时候才会调用系统的方法，类似进入后台、被挂起、进入前台。答：这是在appdelegate的响应方法调用的时候，也会调用。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习阿里开源项目BeeHive(二)]]></title>
    <url>%2F2016%2F11%2F28%2F20161128%2F</url>
    <content type="text"><![CDATA[紧接着前面那篇文章，回到BHAppDelegate.m的文件里面的1- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 之前已经把所有的timeProdiler的这个类的作用，实例，已经public的方法都已经说了。在这个方法的实现中，作者还做了另外一件事情。 123456[[BHModuleManager sharedManager] tiggerEvent:BHMSetupEvent];[[BHModuleManager sharedManager] tiggerEvent:BHMInitEvent];dispatch_async(dispatch_get_main_queue(), ^&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMSplashEvent];&#125;); BHModuleManager从字面上理解应该就是管理模块之前调用逻辑的意思，并且在BHModuleManager.m中，我们可以看出来这个类也是个单例。 在init之后，紧接着就是调用- (void)tiggerEvent:(BHModuleEventType)eventType;的方法。 在这个方法的实现中可以看到一个很长的swich语句，遍历你传入的一个枚举类型，来做一系列的事情。 先看在didFinishLaunch中，第一次调用这个方法，传入的参数为BHMSetupEvent。 123case BHMSetupEvent:[self handleModuleEvent:kSetupSelector];break; 123456789101112131415- (void)handleModuleEvent:(NSString *)selectorStr&#123; SEL seletor = NSSelectorFromString(selectorStr); [self.BHModules enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([moduleInstance respondsToSelector:seletor]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks" [moduleInstance performSelector:seletor withObject:self.wholeContext];#pragma clang diagnostic pop [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@"%@ --- %@", [moduleInstance class], NSStringFromSelector(seletor)]]; &#125; &#125;];&#125; 可以看到传入了一个字符串作为入参，而这个参数写在这个文件的.m中。static NSString *kSetupSelector = @&quot;modSetUp:&quot;;写死了。 紧接着在handleModuleEvent的实现中，通过runtime的NSSelectorFromString的方法将字符串转化为SEL的类型。 再枚举BHModules数组，从枚举中我们发现，不是所有的object对象都添加在BHModules的MutableArray中，这些object的对象必须要遵守id&lt;BHModuleProtocol&gt;的协议。 查询数组中有没有对象可以响应这个方法的，如果有的话，就调用这个方法，并且开始reordTime。 并且为了消除编译器所报的警告，可以通过添加#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;,来消除warning。 紧接着调用了同一个方法，却传入了不同的参数1234567[[BHModuleManager sharedManager] tiggerEvent:BHMInitEvent]; case BHMInitEvent: //special [self handleModulesInitEvent]; break; 123456789101112131415161718192021222324252627282930313233- (void)handleModulesInitEvent&#123; [self.BHModules enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123; __weak typeof(&amp;*self) wself = self; void ( ^ bk )(); bk = ^()&#123; __strong typeof(&amp;*self) sself = wself; if (sself) &#123; if ([moduleInstance respondsToSelector:@selector(modInit:)]) &#123; [moduleInstance modInit:sself.wholeContext]; &#125; &#125; &#125;; [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@"%@ --- modInit:", [moduleInstance class]]]; if ([moduleInstance respondsToSelector:@selector(async)]) &#123; BOOL async = [moduleInstance async]; if (async) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; bk(); &#125;); &#125; else &#123; bk(); &#125; &#125; else &#123; bk(); &#125; &#125;];&#125; 首先循环遍历self.BHModules这个数组对象，先用Timer 开始记录下init方法的时间。 判断数组中的元素是否响应async的方法, 这个- (BOOL)async;的方法定义在BHModuleProtocol中，如果响应了这个方法，就取得这个方法的返回值,从字面上判断这个变量记录了是否运行在多线程中，这里我只是个猜测。 如果是在多线程中，就回到主线程中来执行上面所定义的block：void ( ^ bk )();，如果不是的话或者没有响应async,都直接运行这个block，应该默认状态下就是主线程了。 从代码上看来，就是不管在什么线程或者是否响应async的方法，上面的block是肯定要执行的。 block中所做的事情也很简单，就是判断这个元素对象是否响应- (void)modInit:(BHContext *)context;,这个protocol的代理方法，如果响应的话，就会执行这段代码，至于这里的BHContext的对象，我目前没看到在哪里传入进来，这里只看到了一个Setter的方法。 12345- (void)setWholeContext:(BHContext *)wholeContext&#123; _wholeContext = wholeContext; self.modulesConfigFilename = _wholeContext.moduleConfigName;&#125; 最后执行的一个方法123dispatch_async(dispatch_get_main_queue(), ^&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMSplashEvent]; &#125;); 这个方法和[self handleModuleEvent:kSetupSelector];一样，除了传入的参数不同，响应的方法不同，其他都是一样。 这里还要强制要求这个方法的调用一定要在主线程中。 这样就已经把自定义的BHAppDelegate的主要几个实现已经介绍了一下，下面来看看demo中的实现。在TestAppDelegate的didFinishLaunchingWithOptions的方法中。这四行代码涉及到了同一个对象BHContext,从字面上判断应该是上下文对象，应该是对象之间的调用会需要用它来记录一下，这里是我的猜测1234[BHContext shareInstance].application = application;[BHContext shareInstance].launchOptions = launchOptions;[BHContext shareInstance].moduleConfigName = @"BeeHive.bundle/BeeHive";//可选，默认为BeeHive.bundle/BeeHive.plist[BHContext shareInstance].serviceConfigName = @"BeeHive.bundle/BHService"; 在BHContext.m的代码中可以看出来，这个对象也是个单例，在这个单例的init方法中：1234567891011121314151617181920-(instancetype)init&#123; self = [super init]; if (self) &#123; self.modulesByName = [[NSMutableDictionary alloc] initWithCapacity:1]; self.servicesByName = [[NSMutableDictionary alloc] initWithCapacity:1]; self.moduleConfigName = @"BeeHive.bundle/BeeHive"; self.serviceConfigName = @"BeeHive.bundle/BHService";#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80400 self.touchShortcutItem = [BHShortcutItem new];#endif self.openURLItem = [BHOpenURLItem new]; self.notificationsItem = [BHNotificationsItem new]; self.userActivityItem = [BHUserActivityItem new]; &#125; return self;&#125; 定义了modulesByName、servicesByName为NSMutableDictionary的对象，只能容纳一个元素。 定义了moduleConfigName、serviceConfigName为String的对象。 在系统大于8.0.4的时候，支持3D touch的话，会额外设置一个对象，这个对象里面就两个对象，一个是UIApplicationShortcutItem *shortcutItem;, 一个是typedef void (^shortcutItemCompletionHandler)(BOOL);,都是在调用3D touch的时候会调用到。 涉及到了另一个对象BHOpenURLItem,这个对象含有三个变量NSURL *openURL;,NSString *sourceApplication;,NSDictionary *options;。 设计了通知的一个对象BHNotificationsItem,这个对象含有五个变量：NSError *notificationsError;,NSData *deviceToken;,NSDictionary *userInfo;,typedef void (^notificationResultHandler)(UIBackgroundFetchResult);,UILocalNotification *localNotification;。 还有一个涉及到用户信息的一个对象：BHUserActivityItem,含有四个变量：NSString *userActivityType;,NSUserActivity *userActivity;,NSError *userActivityError;, typedef void (^restorationHandler)(NSArray *);。 总体看来这个对象完成的功能很多，并且以后很多类似3D touch 这种针对某种系统的新功能都可以在这个类中来拓展，而且很方便使用。 在本类的shareInstance的方法中：123456dispatch_once(&amp;p, ^&#123; BHInstance = [[[self class] alloc] init]; if ([BHInstance isKindOfClass:[BHContext class]]) &#123; ((BHContext *) BHInstance).config = [BHConfig shareInstance]; &#125; &#125;); 这里在设置config的变量之前判断if ([BHInstance isKindOfClass:[BHContext class]]) {}这个说实话，我没太明白这么做的原因是什么，上面都已经BHInstance = [[[self class] alloc] init];调用了，那这个判断还有什么意思吗？并且这个对象是继承的NSObject的对象。 这里的BHConfig对象，从代码上看也是一个单例，并且定义了一系列存储，判断是否存在，在.m的文件中定义了一个NSMutableDictionary *config;的对象，统一存储在这个里面，可以是对象类型，也可以是一些基础的数据类型。 1234[BHContext shareInstance].application = application;[BHContext shareInstance].launchOptions = launchOptions;[BHContext shareInstance].moduleConfigName = @"BeeHive.bundle/BeeHive";//可选，默认为BeeHive.bundle/BeeHive.plist[BHContext shareInstance].serviceConfigName = @"BeeHive.bundle/BHService"; 现在可以看出来，首先这4行代码就是简单的赋值的动作，有些类的值你可以不赋值，类似的有：moduleConfigName,serviceConfigName,因为在对象实例化的时候，就已经进行了赋值。 紧接着在下面的两行代码中涉及到了一个新的对象：12[BeeHive shareInstance].enableExpection = YES;[[BeeHive shareInstance] setContext:[BHContext shareInstance]]; 123456789101112#pragma mark - Private-(void)setContext:(BHContext *)context&#123; _context = context; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self loadStaticServices]; [self loadStaticModules]; &#125;);&#125; 首先在BeeHive.m的文件中，可以看出来，这个对象也是个单例。 紧接着在public的属性中，设置了全局了BHContext的对象，并且将它保存下来，并且在这里复写了Setter的方法,并且在Setter方法的时候,又调用了两个新的方法，并且这两个方法有且仅调用一次。 123456789-(void)loadStaticServices&#123; [BHServiceManager sharedManager].enableException = self.enableExpection; [[BHServiceManager sharedManager] setWholeContext:self.context]; [[BHServiceManager sharedManager] registerLocalServices];&#125; 在loadStaticServices的方法中，又创建了一个BHServiceManager的单例对象。 在BHServiceManager中设计了enableException的属性。 在BHServiceManager中设置了BHContext的对象，将BHContext对象也能够在BHServiceManager中能够持有这个对象。 最后调用到了loadStaticServices中的registerLocalServices的方法。方法如下： 123456789101112131415- (void)registerLocalServices&#123; NSString *serviceConfigName = self.wholeContext.serviceConfigName; NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@"plist"]; if (!plistPath) &#123; return; &#125; NSArray *serviceList = [[NSArray alloc] initWithContentsOfFile:plistPath]; [self.lock lock]; [self.allServices addObjectsFromArray:serviceList]; [self.lock unlock];&#125; 通过传入的context找到serviceConfigName的变量，拼接成plist文件名，如果项目中确实存在的话，就打开这个文件的内容。 这里通过锁，来将plist文件中取到的变量NSArray，存储到allServices私有变量中去。 另一个方法：12345678- (void)loadStaticModules&#123; [[BHModuleManager sharedManager] setWholeContext:self.context]; [[BHModuleManager sharedManager] loadLocalModules]; [[BHModuleManager sharedManager] registedAllModules];&#125; 上面已经分析过了，这个BHModuleManager也是一个单例。首先将全局的context的变量设置上去，并且将context中的moduleConfigName的变量赋值给modulesConfigFilename。 将刚才的变量modulesConfigFilename拼接成plist文件，然后将取得的数据放入到数组中。 在registedAllModules的方法中，听过比较字典中的moduleLevel的value值，进行比较、排序，然后通过枚举，挨个实例化对象之后，在存入BHModules的可变数组中。 1id&lt;HomeServiceProtocol&gt; homeVc = [[BeeHive shareInstance] createService:@protocol(HomeServiceProtocol)]; 123456789101112131415161718192021222324252627282930313233- (id)createService:(Protocol *)service&#123; id implInstance = nil; if (![self checkValidService:service] &amp;&amp; self.enableException) &#123; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@"%@ protocol does not been registed", NSStringFromProtocol(service)] userInfo:nil]; &#125; Class implClass = [self serviceImplClass:service]; implInstance = [[implClass alloc] init]; if (![implInstance respondsToSelector:@selector(singleton)]) &#123; return implInstance; &#125; NSString *serviceStr = NSStringFromProtocol(service); if ([implInstance singleton]) &#123; id protocol = [[BHContext shareInstance].servicesByName objectForKey:serviceStr]; if (protocol) &#123; return protocol; &#125; else &#123; [[BHContext shareInstance].servicesByName setObject:implInstance forKey:serviceStr]; &#125; &#125; else &#123; [[BHContext shareInstance].servicesByName setObject:implInstance forKey:serviceStr]; &#125; return implInstance;&#125; 紧接着调用了BeeHive的public的方法：- (id)createService:(Protocol *)proto;传入一个protocol，返回一个id类型的对象。 其实这里self checkValidService:service值是判断之前registerLocalServices这个里面有没有遵循这个protocol的，假如没有，并且开启self.enableException的话，他就会抛出一个NSException。 否则就会遵循这个protocol的类，并且返回。 判断这个类有没有遵循BHServiceProtocol这个协议的singleton,并且实现，假如没有实现的话，就直接返回这个对象，不再往下执行了。 根据这个protocol在[BHContext shareInstance].servicesByName字典中查找有没有对应value值，如果有的话，就直接放回这个对象，如果没有的话，放回对象的同时，将这个protocol存储到这个[BHContext shareInstance].servicesByName字典中。 最后讲个homeVC设置为Appdelegate的RootWindow。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习阿里开源项目BeeHive(-)]]></title>
    <url>%2F2016%2F11%2F25%2F20161125%2F</url>
    <content type="text"><![CDATA[学习阿里开源 BeeHive ,每次学习别人写的框架，或者好东西都会让自己学到很多东西，废话不多说，直接扯代码。源码中的几个小问题：1. 在Example中，程序的入口文件TestAppDelegate,你就惊奇地发现，他不是继承了UIAppDelegate，也不是继承了UIAppDelegate的子类，而是自己写了一个&quot;AppDelegate&quot; 1@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt; 在 BHAppDelegate.m的文件中，我们发现这个类实现了很多appDelegae的很多代理方法 123456789101112131415161718192021222324- (void)applicationWillResignActive:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMWillResignActiveEvent];&#125;- (void)applicationDidEnterBackground:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMDidEnterBackgroundEvent];&#125;- (void)applicationWillEnterForeground:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMWillEnterForegroundEvent];&#125;- (void)applicationDidBecomeActive:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMDidBecomeActiveEvent];&#125;- (void)applicationWillTerminate:(UIApplication *)application&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMWillTerminateEvent];&#125; ####当然这里先忽略，我们一点点说： 1234567891011121314151617181920- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;#ifdef DEBUG self.timeProdiler = [BHTimeProfiler sharedTimeProfiler];#endif [[BHModuleManager sharedManager] tiggerEvent:BHMSetupEvent]; [[BHModuleManager sharedManager] tiggerEvent:BHMInitEvent]; dispatch_async(dispatch_get_main_queue(), ^&#123; [[BHModuleManager sharedManager] tiggerEvent:BHMSplashEvent]; &#125;);#ifdef DEBUG [self.timeProdiler printOutTimeProfileResult]; [self.timeProdiler saveTimeProfileDataIntoFile:@"BeeHiveTimeProfiler"];#endif return YES;&#125; 在debug状态下，这个程序启动的方法创建了一个timeProdiler的实例，并且在return之前执行了timeProdiler的两个方法。进入到 BHTimeProfiler.m的文件里面发现，这个类是一个单例。在这个类的init的方法中发现12345678910- (instancetype)initTimeProfilerWithMainKey:(NSString *)mainKey&#123; self = [super init]; if (self) &#123; _mainIdentifier = [mainKey copy]; _lastTime = CACurrentMediaTime(); _recordStartTime = CACurrentMediaTime(); &#125; return self;&#125; 用一个字符串对私有的_mainIdentifier的字符串类型进行了赋值。 创建了一个时间的值赋给了_lastTime。 创建了一个时间的值赋给了_recordStartTime。这里的时间类型并没有用NSDate去实例化，而是用了CACurrentMediaTime，这个时间在设备上所有进程都是全局的，并且在设备休眠的状态的时候，这个值会暂停 123456789- (void)recordEventTime:(NSString *)eventName&#123;#ifdef DEBUG NSString *keyName = [eventName copy]; [self.identifiers addObject:keyName]; [self.timeDataDic setObject:@(CACurrentMediaTime()) forKey:keyName];#endif&#125; 只有在debug的状态下调用这个public的方法才有意义。这个方法很简单，其实就是用mutableArray来存储keyName,并且将时间的值作为value存储在MutableDictionary中。这其实没什么好说的，但是这里有一点却引起了我的注意： 12345678#if __has_feature(objc_generics)# define TM__GENERICS(class, ...) class&lt;__VA_ARGS__&gt;#else# define TM__GENERICS(class, ...) class#endif#define TMMutableArrayWith(valueType) TM__GENERICS(NSMutableArray, valueType)#define TMMutableDictionaryWith(keyType, valueType) TM__GENERICS(NSMutableDictionary, keyType, valueType) __has_feature(objc_generics)判断是否支持Obj-C泛型的特征。 ...表示，这个表示符里面可以接受0个，或者1个，或者多个参数。 除了第一个class的参数，其他的参数作为一个整体在__VA_ARGS__里面返回。 1234567891011121314- (void)printOutTimeProfileResult&#123;#ifdef DEBUG for (NSString *eventName in self.identifiers) &#123; NSAssert([self.timeDataDic objectForKey:eventName] != nil &amp;&amp; [[self.timeDataDic objectForKey:eventName] isKindOfClass:[NSNumber class]], @"Save Wrong Type TimeStamp"); CFTimeInterval current = [[self.timeDataDic objectForKey:eventName] doubleValue]; printf("[%s] time stamp: %gms and execute for %gms -&gt; \n", [eventName UTF8String], (current - self.recordStartTime) * 1000, (current - self.lastTime) * 1000); self.lastTime = current; &#125;#endif&#125; 遍历keyName的数组，拿到每个keyName，先去字典中找对应的时间值，假如没有的话，就只会断点断住。 算出现在的时间值，与lastTime,recordTime的值得差值。 最后加lastTime的值重新设置为当前的值。 1234567891011121314151617181920212223242526272829- (void)saveTimeProfileDataIntoFile:(NSString *)fileName&#123; NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *filePath = [documentPath stringByAppendingPathComponent:[fileName stringByAppendingPathExtension:@"txt"]]; NSLog(@"TMTimeProfiler::SaveFilePath is %@", filePath); BOOL res=[[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:nil]; if (!res) &#123; return; &#125; NSFileHandle *handle = [NSFileHandle fileHandleForWritingAtPath:filePath]; for (NSString *eventName in self.identifiers) &#123; CFTimeInterval current = [[self.timeDataDic objectForKey:eventName] doubleValue]; NSString *output = [NSString stringWithFormat:@"%@ time stamp %g and execute for %g\n", eventName, current, (current - self.lastTime) * 1000]; [handle writeData:[output dataUsingEncoding:NSUTF8StringEncoding]]; self.lastTime = current; &#125; [handle closeFile];&#125; 这个函数的作用就是传入一个文件的名字，然后将启动时间，record时间，记录下来，这个没什么好说的。 123456789101112131415161718- (void)postTimeProfileResultNotification&#123; NSMutableArray *logArray = [NSMutableArray array]; for (NSString *eventName in self.identifiers) &#123; CFTimeInterval current = [[self.timeDataDic objectForKey:eventName] doubleValue]; [logArray addObject: @&#123;@"eventName":eventName,@"costTime": @((current - self.lastTime) * 1000)&#125;]; self.lastTime = current; &#125; [[NSNotificationCenter defaultCenter] postNotificationName:kTimeProfilerResultNotificationName object:nil userInfo:@&#123;kNotificationUserInfoKey:logArray&#125;];&#125; 1.用NSNotificationCenter，将上次lastTime与现在时间的差值作为NSNotificationCenter中的userInfo的参数传输出去。这样只要监听这个NSNotificationCenter，你每次post就能接受到这个全局的通知。光这一个时间的统计功能，产品、技术上就能做好多文章。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建私有的Cocoapods]]></title>
    <url>%2F2016%2F10%2F28%2F20161028%2F</url>
    <content type="text"><![CDATA[创建私有Cocoapods,最近一直想将自己的App模块化，就想就App拆成每个模块组件，比如：登录模块、网络模块、消息模块、用户中心模块…但是基于这些想法，我首先要先搞定私有化Cocoapods的问题，这样团队中新人，想调用的时候，就能够快速，便捷的调用了，只需要 pod xxx 1.先到自己的git账号，创建一个新的仓库 ，我们取名字 GH 2.开始终端，找到一个合适的位置： 1cd ~/Desktop 3.初始化pod 1pod lib create GH 4.接着系统会问一下问题，你可以自己按照项目需求来回答，也可以参照我的 123456789101112131415What language do you want to use?? [ Swift / ObjC ] &gt; ObjCWould you like to include a demo application with your library? [ Yes / No ] &gt; YesWhich testing frameworks will you use? [ Specta / Kiwi / None ] &gt; NoneWould you like to do view based testing? [ Yes / No ] &gt; NoWhat is your class prefix? &gt; GG 5.修改一下pod的配置文件,pod的配置文件应该都是一样的后缀名，我这里叫 Gh.podspec steps1.这里我先讲description的描述内容注释掉123#s.description = &lt;&lt;-DESC#TODO: Add long description of the pod here.# DESC 2.修改homepage的路径，在第24行1s.homepage = 'https://github.com/Ghstart/Gh' 3.修改git的路径，在第28行1s.source = &#123; :git =&gt; 'https://github.com/Ghstart/Gh.gi t', :tag =&gt; s.version.to_s &#125; 5.保存好退出，再次进入到那个文件夹中，将文件内容提交到github上,我这里选择的是命令的方式，你也可以用github客户端 1234567cd Ghgit initgit remote add origin https://github.com/Ghstart/GH.git // 这个路径在你刚才新建仓库的那个页面就能找到git add .git commit -m 'Gh first creats private own cocoapods'git tag 0.1.0 // 这里的0.1.0在刚才的配置文件里有，对应起来就好了git push -u origin master --tags 最后再去你刚才新建仓库的页面刷新一下，就会发现奇迹。。 现在开始添加自己的类 找到存放类的目录下，/Users/自己的mac名字/Desktop/Gh/Gh/Classes，在这个文件夹下面，你会发现一个名字叫做ReplaceMe.m，这个真是太贴心了，cocoapods都已经为我们想到了，在这里你先删除这个类，然后添加自己想要的类，然后在走一下下面的命令。 我觉得这里，你既然已经修改了内容，或者想发布第一版本，那么修改配置文件的tags修改为0.1.1 1234git add .git commit -m"add files"git tag 0.1.1git push -u origin master --tags 现在到自己的github页面熟悉一下，就会发现自己创建的0.1.1的版本，以及新添加的文件。下面我们需要将我们自己创建的这个cocoapods提交给cocoapods审核，并且发布。 12pod lib lint Gh.podspec // 认证通过pod trunk push // 提交 123456在最后 pod trunk push 时候如果报错 如：[!] Authentication token is invalid or unverified. Either verify it with the email that was sent or register a new session.这说明你之前的认证token已经失效了，重新注册一下就好了，输入以下命令： pod trunk register gonghuan2020@gmail.com 'gonghuan'然后在重新 pod trunk push 就可以了。 123456如果弹 [!] The spec did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it).pod trunk push --allow-warnings如果弹 You can use the `--no-clean` option to inspect any issue.pod lib lint GateWayObject.podspec --allow-warnings --no-clean 大功告成！！这里cocoapods是一个很关键的问题，尤其你刚跟新pod或者xcode，那问题会很多，建议出现一些奇葩的问题，可以先卸载cocoapods，然后再装最新的稳定版本。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 实战(-)]]></title>
    <url>%2F2016%2F10%2F21%2F20161021%2F</url>
    <content type="text"><![CDATA[实战(-) React-Native 重写红狮物流App的项目。下面的的几次博客我会以完成一个现有的项目，将它整体都用React重写。项目我已经上传到github[https://github.com/Ghstart/HongshiWuliuRN]首先找到index.ios.js文件，由于我们的app的架构就是主流的tab的这种，所以我这里用到了TabBarIOS的主件，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, TabBarIOS&#125; from 'react-native';import Task from './ios_views/task';import Goods from './ios_views/goods'import Home from './ios_views/home'import Message from './ios_views/message'import Setting from './ios_views/setting'class HongshiWuLiuRN extends Component &#123; constructor() &#123; super(); this.state = &#123; selected: 'home' &#125; &#125; _renderView(moduleName) &#123; switch (moduleName) &#123; case 'task': return ( &lt;Task/&gt; ); break; case 'goods': return ( &lt;Goods/&gt; ); break; case 'home': return ( &lt;Home/&gt; ); break; case 'message': return ( &lt;Message/&gt; ); break; case 'setting': return ( &lt;Setting/&gt; ); break; default: return ( &lt;View&gt;&lt;/View&gt; ); break; &#125; &#125; render() &#123; return( &lt;TabBarIOS tintColor = '#e23f42' &gt; &lt;TabBarIOS.Item title = "任务" selected = &#123; this.state.selected === 'task' &#125; icon = &#123;require('./images/mission@2x.png')&#125; selectedIcon=&#123;require('./images/mission-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'task' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title = "货源" selected = &#123; this.state.selected === 'goods' &#125; icon = &#123;require('./images/goods@2x.png')&#125; selectedIcon=&#123;require('./images/goods-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'goods' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title = "首页" selected = &#123; this.state.selected === 'home' &#125; icon = &#123;require('./images/home@2x.png')&#125; selectedIcon=&#123;require('./images/home-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'home' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title = "消息" selected = &#123; this.state.selected === 'message' &#125; icon = &#123;require('./images/news@2x.png')&#125; selectedIcon=&#123;require('./images/news-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'message' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title = "设置" selected = &#123; this.state.selected === 'setting' &#125; icon = &#123;require('./images/user@2x.png')&#125; selectedIcon=&#123;require('./images/user-1@2x.png')&#125; onPress = &#123;() =&gt; &#123; this.setState(&#123; selected: 'setting' &#125;) &#125;&#125;&gt; &#123;this._renderView(this.state.selected)&#125; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123;&#125;);AppRegistry.registerComponent('HongshiWuLiuRN', () =&gt; HongshiWuLiuRN); 首先你先不要运行，我先解释一下几点比较重要的问题： 引入系统主件(关于系统主件，你可以直接copy就好，这里我的意见就是官方建议那种写法，你就以这种写法为主)、第三方主件、以及自己定义的主件(这里一定要理清楚自己写的主件的路径)。 12345678910111213141516// 引入系统主件import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, TabBarIOS&#125; from 'react-native';// 引入自定义的主件import Task from './ios_views/task';import Goods from './ios_views/goods'import Home from './ios_views/home'import Message from './ios_views/message'import Setting from './ios_views/setting' 如何定义主件,这里我目前写了两个方法，也是最常使用的两个方法：其中constructor是这个主件的实例化方法，而真正让视图渲染到屏幕上的是render的方法，你可以在这里添加想渲染上去的视图内容。 123456789class HongshiWuLiuRN extends Component &#123; constructor() &#123; super(); &#125; render() &#123; &#125;&#125; 如何定义主件视图的样式，这里我们就需要用到stylesheet 所创创建的对象，在这里你就可以像写CSS样式一样，来定义视图了。 123const styles = StyleSheet.create(&#123;&#125;); 如何定义应用的入口文件，就想C函数一样，需要一个main函数作为入口文件，在RN中，我需要使用AppRegistry来注册这个主件，同时也作为入口文件。 1AppRegistry.registerComponent('HongshiWuLiuRN', () =&gt; HongshiWuLiuRN); 如何添加图片，你可以发现这段代码 导入图片和自定义的主件是一样，需要写清楚图片所在的路径，这里为了调试，你可以先注释到： 12icon = &#123;require('./images/news@2x.png')&#125;selectedIcon=&#123;require('./images/news-1@2x.png')&#125; 整个TabBar的功能，是由TabBarIOS来实现的，具体在这里，我们可以通过设置tintColor = ‘#e23f42’可以设置TabBar点选适合的颜色，而具体的图片的样式，文字，以及点击的方法就需要在TabBarIOS.Item来进行设置,重点说一下这个这段代码：这里定义一个私有方法，传入了一个字符串类型的参数，在拿到的参数的时候，我用swich的的方法，根据传入不同的参数，返回不同的自定义的主件 12345678910111213141516171819202122232425262728293031323334&#123;this._renderView(this.state.selected)&#125; _renderView(moduleName) &#123; switch (moduleName) &#123; case 'task': return ( &lt;Task/&gt; ); break; case 'goods': return ( &lt;Goods/&gt; ); break; case 'home': return ( &lt;Home/&gt; ); break; case 'message': return ( &lt;Message/&gt; ); break; case 'setting': return ( &lt;Setting/&gt; ); break; default: return ( &lt;View&gt;&lt;/View&gt; ); break; &#125; &#125; 这里根据自定义主件的路径，可以猜到，我在同级目录下创建一个ios_views的文件夹，在ios_views的文件下我有创建了四个js文件： goods.js、home.js、message.js、setting.js、task.js,代码如下,这个五个文件，你目前可以一样的代码，只需要修改相应的名字，就可以了： 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, View, NavigatorIOS&#125; from 'react-native';class home_views extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;/View&gt; ); &#125;&#125;class home extends Component &#123; render() &#123; return( &lt;NavigatorIOS initialRoute=&#123;&#123; component: home_views, title: "红狮物流", titleTextColor: '#fff', barTintColor: '#e23f42', &#125;&#125; /&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123;&#125;);module.exports = home 这里用到了NavigatorIOS的主件，这个就是强大的路由主件。你可以看到，在里面必须要定义初始路由对应于哪个主件，以及nav的背景色，title，字体颜色等等。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习React Native中]]></title>
    <url>%2F2016%2F08%2F24%2F20160824%2F</url>
    <content type="text"><![CDATA[其实从去年我就一直看学习并看React Native,开始学习只是为了兴趣，现在项目中用到了有些更新的功能，我就是用React native 来做的。其实还是蛮好的，但是我发现更新实在是太快了，现在官网的稳定版本是0.31版本 使用 打开terminal, cd到某个路径下，执行命令 react-native init helloworld[^这里的helloword就是你创建的项目名字]如果出现这样的代码就代码创建成功。 12345678910To run your app on iOS: cd /Users/gonghuan/Desktop/helloworld react-native run-ios - or - Open /Users/gonghuan/Desktop/helloworld/ios/helloworld.xcodeproj in Xcode Hit the Run buttonTo run your app on Android: Have an Android emulator running (quickest way to get started), or a device connected cd /Users/gonghuan/Desktop/helloworld react-native run-android 此时你可以通过类似react-native run-ios可以直接调起iOS模拟器，此时你可以看到你的终端不断在解析，然后就可以成功运行了。 说到这里，应该你已经可以运行你的app了，至于之前要安装 brew node等等，我这里就不再多说了，你可以去官网上走一遍，很简单。 工具 我这里我选用的是atom，这里说一个我遇到的小问题，也许你也会遇到，在我们使用atom的时候，需要安装一些插件来帮助我们能够更加高效的写代码，就比如facebook开发的Nuclide 按照官方install的说明，我们可以知道有两种安装的方式，一种就是通过直接在终端输入apm install nuclide,但是说实话，我就成功过一次，而且还是要挂vpn，之后就一直没有成功过了，这我就呵呵了。 官方建议第二种方式：直接在atom-&gt;Setting Views-&gt;Manage Packages,搜索Nuclide，直接安装。 第三种：通过这种方式你可以安装Themes、packages 1234 cd ~/.atom/packagesgit clone [packgae-url] # git clone https://github.com/facebook/nuclidecd [package] #nuclidenpm install ###好了，到目前为止，你已经可以，我们已经可以开始运行，并且可以安装自己喜欢的插件，已经修改自己喜欢的主题了。下面我们开始coding,我们先通过atom打开我们之前创建的helloworld的项目，并且找到index.ios.js,删除里面所有的代码，不要着急，我们会慢慢的添加进去所有的代码。 1234567891011class firstRN extends Component &#123; render() &#123; return( &lt;Text&gt; Hello world &lt;/Text&gt; ); &#125;&#125;AppRegistry.registerComponent('helloworld', ()=&gt;firstRN); 这里我们先创建一个firstRN的类，继承自Component对象，这里你先不要管，我们后面都会解释的。 第二步，我们用AppRegistry这个注册一个对象，这个对象的名字是我们应用的名字‘helloworld’，第二个参数指向的是我们刚才创建的firstRN类。 我们点击模拟器，发现报错，Unhandled JS Exception:xxxx: Can&#39;t find variable: Component,在文件头部添加 12import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text &#125; from 'react-native'; The AppRegistry just tells React Native which component is the root one for the whole application. You won’t be thinking about AppRegistry a lot - there will probably just be one call to AppRegistry.registerComponent in your whole app. It’s included in these examples so you can paste the whole thing into your index.ios.js or index.android.js file and get it running.—-这里是官方给的AppRegistry，其实AppRegistry只做了一件事情，就是告诉这个应用，谁是整个应用的根控制器，这样你可以通过修改index.ios.js来修改iOS的根控制器是啥？安卓也是一样，修改的index.android.js再次刷新模拟器，就会发现左上角会出现我们写的Hello world的文字。这里我们觉得样式好丑，那该怎么办，没事，RN也是可以做到修改的。 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text , StyleSheet &#125; from 'react-native';class firstRN extends Component &#123; render() &#123; return( &lt;Text style = &#123;styles.helloWorldStyle&#125;&gt; Hello world &lt;/Text&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; helloWorldStyle: &#123; color:'red', fontSize:30, fontWeight:'bold' &#125;&#125;)AppRegistry.registerComponent('helloworld', ()=&gt;firstRN); 这里我们需要在import中导读 StyleSheet,因为我们需要在后面的设置样式的时候，用到这个类。直接在text后面添加style的样式熟悉直接在后面创建styles的属性，通过StyleSheet来创建。再次刷新模拟器，你就可以看到效果了。 先说这么多，后期我们还会说到很多在app开发中遇到的各种问题，导航栏，网络请求，传值等等。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因为我不想打卡，不要问我为什么？？]]></title>
    <url>%2F2016%2F08%2F15%2F20160815%2F</url>
    <content type="text"><![CDATA[最近一直没啥时间来整理一些学习资料以及学习的内容，感觉这样不是很好。又由于公司要打卡了，所以我就写写我是怎么不打卡的吧！O(∩_∩)O~~~ mac电脑先安装抓包神器：Charles (网上有很多这个使用教程，我就不多说了，毕竟是工具，没啥难度) 点击Help-&gt;Local IP Address,将本机的IP打印出来，然后在手机里面设置代理为相应的IP，端口为：8888 此时你就可以开始看到数据的返回、和请求了。 ![1.pi](media/14712518179704/1.pic.jpg) 然后你就可以看到你想要的代码请求了，其实这个Android和iOS,还有点不同，Android返回的代码不是text/json,而是text/html,我在我代码中加入了代码格式的转换。 1234567891011__block NSDictionary *par = @&#123;@&quot;employeeNo&quot;:pp.employeeNo,@&quot;coord&quot;:@&quot;30.249812,120.211494&quot;,@&quot;img_ids&quot;:@&quot;&quot;,@&quot;identifier&quot;: pp.identifier,@&quot;type&quot;: @&quot;0&quot;&#125;&#125;; AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; [manager POST:@&quot;http://xxxx/HSSCM/appmail/employeeRecordManage/sign.do&quot; parameters:par success:^(AFHTTPRequestOperation * _Nonnull operation, id _Nonnull responseObject) &#123; NSLog(@&quot;%@&quot;,operation); NSLog(@&quot;%@&quot;,responseObject); &#125; failure:^(AFHTTPRequestOperation * _Nullable operation, NSError * _Nonnull error) &#123; NSLog(@&quot;%@&quot;,operation); NSLog(@&quot;%@&quot;,error); &#125;]; 你或许已经发现了参数的规律了，这里的employeeNO就是我们之前抓包的用户唯一标示符（安卓这边还耍了个心眼，取了一个很怪的名字，视图误导我们） coord就是经纬度，用逗号链接起来的一个字符串 img_ids我不知道是个什么东西，反正可有可无 identifior是手机的udid（iOS中这样称呼吧）,这里我猜想他的employeeNO与手机identifior是一一对应的，所以这也就解释了为什么我在换手机的时候，会报错 type:0–就是签出，1–就是签到 ##现在问题都已经分析完了，我们该用什么对策来自动帮我们打卡呢。 ####由于必须需要内网才能打卡，我们不能外网或者4G的条件下打卡，折让我们很蛋疼，这里我想到几个解决方案： 安卓的手机，可以借用一款叫做&lt;按键精灵&gt;的app,但是有个条件就是你必须拿到root权限，这样就可以录制你按键的动作，你可以指定时间执行。 公司的电脑、或者测试机，安装一个teamViewer，这样你就可以在家里远程操控他。 公司的测试机充当服务器的功能、一直在跑，这样我需要关心的只有一件事：手机有电。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 - (NSArray *)setUPDatas:(TypeStatus)typeStatus &#123; NSMutableArray *datas = [NSMutableArray new]; NSArray *employeeNos = @[@"31330034", @"31330040", @"31330035"]; NSArray *identifiers = @[@"05B7A575-2D2A-4006-890A-D0994EFF3DAC", @"a000004f73cb94", @"1B65EB63-487B-49BF-B751-F2D544175BE7"]; for (int i = 0 ; i &lt; employeeNos.count ; i++) &#123; People *people = [[People alloc] init]; people.employeeNo = employeeNos[i]; people.coord = @"30.249812,120.211494"; people.img_ids = @""; people.identifier = identifiers[i]; if (typeStatus == LogIn) &#123; people.type = @"1"; &#125; else &#123; people.type = @"0"; &#125; people.random_signInMin = [self getRandomNumber:5 to:25]; people.random_signInSec = [self getRandomNumber:1 to:59]; people.random_signOutMin = [self getRandomNumber:5 to:25]; people.random_signOutSec = [self getRandomNumber:1 to:59]; [datas addObject:people]; &#125; return [datas copy]; &#125; - (int)getRandomNumber:(int)from to:(int)to &#123; return (int)(from + (arc4random() % (to - from + 1))); &#125;#### 我在这里实例化了用户的对象，在这个对象生成的同事，就已经确定这个对象签到的时间，和签出的时间（在某个数范围内随机生成）。if (hour == signOutHour) &#123; // 签出--0 if (self.needSignOut.count == 0) return; for (int i = 0 ; i &lt; self.needSignOut.count; i++) &#123; People *pp = self.needSignOut[i]; if (pp.random_signOutMin &lt; min || (pp.random_signOutMin == min &amp;&amp; pp.random_signOutSec &lt;= sec)) &#123; par = @&#123; @"employeeNo":pp.employeeNo, @"coord": @"30.249812,120.211494", @"img_ids":@"", @"identifier": pp.identifier, @"type": pp.type&#125;; [self SignOrSignOut:par week:week time:[NSString stringWithFormat:@"%ld:%ld:%ld",(long)hour,(long)min,(long)sec]]; &#125; &#125; &#125; 12345678910111213141516171819- (void)needToRemove:(TypeStatus)status identifior:(NSString *)identifior realtime:(NSString *)realtime&#123; if (status == LogIn) &#123; for (int i = 0 ; i &lt; self.needSignIn.count; i++) &#123; NSMutableDictionary *tempDic = [NSMutableDictionary new]; People *pp = self.needSignIn[i]; if ([pp.identifier isEqualToString:identifior] &amp;&amp; ![identifior isEqualToString:@""]) &#123; NSLog(@"移除people:%@---loginMin:%ld----loginSec:%ld",pp.identifier,(long)pp.random_signInMin, (long)pp.random_signInSec); [self.needSignIn removeObject:pp]; if (pp.identifier != nil) [tempDic setObject:pp.identifier forKey:@"iden"]; [tempDic setObject:[NSString stringWithFormat:@"签到时间:%ld:%ld:%ld", signInHour, pp.random_signInMin, pp.random_signInSec] forKey:@"time"]; if (realtime != nil) [tempDic setObject:realtime forKey:@"realtime"]; if (tempDic != nil) [self.tableViewDatas addObject:tempDic]; &#125; &#125; 这里你会发现我在遍历的同事，又对mutableArray对象进行的操作，开始一直crash，会报这个错：collection __nsarraym was mutated while being enumerated 意思就是说，你在遍历这个对象的同事，又对这个对象进行了添加、删除的操作。这里给你三种解决的思路。 1 1for (int i = 0 ; i &lt; self.needSignIn.count; i++) &#123;&#125; 替换 1for (People *pp in self.needSignIn) &#123;&#125; 2 123NSSortDescriptor *sd1 = [NSSortDescriptor sortDescriptorWithKey:nil ascending:NO];//yes升序排列，no,降序排列NSArray *myary = [ary sortedArrayUsingDescriptors:[NSArray arrayWithObjects:sd1, nil]];//注意这里的ary进行排序后会生产一个新的数组指针，myary，不能在用ary,ary还是保持不变的。for (People *pp in myary) &#123;&#125; 3 1生成一个零时的数组，用来遍历，之前的数据用来操作。 其实这里有个问题，想了好久才想明白：为什么正序排列不行，倒序就可以呢？？,为什么for不行，但是forin的可以呢？ ####其实for的语句可以等同于：假如说我有10个元素，在第一个的时候，我就remove了，那是不是到了第九个的时候就越界了呢？？ 1int count = arr.count; for (i=0;i&lt;count;i++) &#123;&#125; 倒序同样的道理： 12int count = arr.count;for (i = count - 1;i&gt;=0 ;i—) &#123;&#125; 当我移除当前这个的时候，其实比不影响我其他的元素布局。但是这两种情况，假如你使用for的语句格式，就不会有问题了 1for (int i = 0 ; i &lt; self.needSignIn.count; i++) &#123;&#125; ###总结一句话： 当我们正序遍历时,如果删除了一个,那么没有遍历到的元素位置都会往前移动一位,这样系统就无法确定接下来遍历是从删除位置开始呢,还是从删除位置下一位开始呢 对于逆序遍历就不会,因为我们逆序遍历时,遇到匹配的元素删除后,位置改变的是遍历过得元素,而没有遍历到的元素位置却没有改变,所以遍历能够正常进行.]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Obeject-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建SDK中所遇到的坑]]></title>
    <url>%2F2016%2F05%2F10%2F20160510%2F</url>
    <content type="text"><![CDATA[其实开始之前，我找到一篇很不错的文章，想翻译的，但是google了一下，发现已经有好多人翻译过这篇文章了，这里我就不再多说什么了，把原文的链接贴出来。https://www.raywenderlich.com/65964/create-a-framework-for-ios,这里我就说一下，我在搭建sdk的时候，遇到的坑吧。 其实你要是能够走完上面的流程，你基本上已经完成了80%了，剩下的就是发现问题，再去打包。 第一个错误*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;Could not find a storyboard named &#39;XXXXname&#39; in bundle NSBundle 这个错误可能直接就会导致app起不来，一启动就会crash，这里需要将所有你用到xib，storyboard的文件都统一作出修改。其实这个问题在遇到用xib/SB创建的cell的时候、在xib/SB中添加图片的时候需要将[UIImage imageNamed:@&quot;&quot;] =======&gt; 修改为 [UIImage imageNamed:@&quot;xxxx.bundle/xxxxName&quot;] 12345UIStoryboard *main = [UIStoryboard storyboardWithName:@"xxxxName" bundle:[NSBundle mainBundle]];修改为===============================UIStoryboard *main = [UIStoryboard storyboardWithName:@"xxxx.bundle/xxxxName" bundle:[NSBundle mainBundle]]; 第二个错误可能会在Iphone4的时候，直接无法build,直接报这个错： dyld: Symbol not found: ___NSDictionary0__ 1需要将项目中的build Phases 中的core foundation的stastu的状态 从Required修改为Optional 后续如果还有其他的bug，我再贴出来吧！]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Obeject-c</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于学习UITableViewCell的高度计算的框架-UITableView-FDTemplateLayoutCell。]]></title>
    <url>%2F2016%2F05%2F05%2F20160505%2F</url>
    <content type="text"><![CDATA[学习UITableView的高度计算的框架 这里学习的是UITableView-FDTemplateLayoutCellhttps://github.com/forkingdog/UITableView-FDTemplateLayoutCell你也可以自己去下载并且学习。 他的文件很简单，直接在UITableView的高度放回中去调用方法：直接调用UITableView 中(FDTemplateLayoutCell)的category的方法,其实他的category里面一共写了三种可以计算高度的方法，这是其中的一种： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration &#123; //1. if (!identifier) &#123; return 0; &#125; //2. UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier]; // Manually calls to ensure consistent behavior with actual cells. (that are displayed on screen) [templateLayoutCell prepareForReuse]; //8. // Customize and provide content for our template cell. if (configuration) &#123; configuration(templateLayoutCell); &#125; return [self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];//2.- (__kindof UITableViewCell *)fd_templateCellForReuseIdentifier:(NSString *)identifier &#123; //.... //4. if (!templateCellsByIdentifiers) &#123; templateCellsByIdentifiers = @&#123;&#125;.mutableCopy; objc_setAssociatedObject(self, _cmd, templateCellsByIdentifiers, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; //5. if (!templateCell) &#123; templateCell = [self dequeueReusableCellWithIdentifier:identifier]; NSAssert(templateCell != nil, @"Cell must be registered to table view for identifier - %@", identifier); //6. templateCell.fd_isTemplateLayoutCell = YES; templateCell.contentView.translatesAutoresizingMaskIntoConstraints = NO; templateCellsByIdentifiers[identifier] = templateCell; [self fd_debugLog:[NSString stringWithFormat:@"layout cell created - %@", identifier]]; &#125; //....)//3./** * Returns the value associated with a given object for a given key. * * @param object The source object for the association. * @param key The key for the association. * * @return The value associated with the key \e key for \e object. * * @see objc_setAssociatedObject */OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)//6./// Indicate this is a template layout cell for calculation only./// You may need this when there are non-UI side effects when configure a cell./// Like:/// - (void)configureCell:(FooCell *)cell atIndexPath:(NSIndexPath *)indexPath &#123;/// cell.entity = [self entityAtIndexPath:indexPath];/// if (!cell.fd_isTemplateLayoutCell) &#123;/// [self notifySomething]; // non-UI side effects/// &#125;/// &#125;///@property (nonatomic, assign) BOOL fd_isTemplateLayoutCell;//7.- (BOOL)fd_isTemplateLayoutCell &#123; return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)setFd_isTemplateLayoutCell:(BOOL)isTemplateLayoutCell &#123; objc_setAssociatedObject(self, @selector(fd_isTemplateLayoutCell), @(isTemplateLayoutCell), OBJC_ASSOCIATION_RETAIN);&#125; 这里假如不传入identifior的值得话，他就直接直接返回0，表示不计算高度了。 这里根据传入的identifior的值，来找到相应的UITableViewCell 这里是runtime源码中所申明的，可以看到这个是根据给的Object以及给的Key来返回一个对象 第一次申明的话，它就会创建一个空的可变字典对象,字典的对象是{},key是String, value是UITableViewCell。 当第一次没有UITableViewCell的对象的时候，就开始在重用池中，找UITableViewCell的对象,并将UITableViewCell对象塞进之前的字典对象。 这边在塞入UITableViewCell对象的时候，通过category(7.)来这是这个UITableViewCell的属性，这个作者的用意就是表明这个只是用计算高度的。 如果需要在cell中设置cell元素中的值，就在这里设置。最后拿到UITableViewCell的对象。 最后将拿到的UITableViewCell的对象丢到这个函数中计算123456- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell &#123; // Auto layout engine does its math // 6. fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; [cell.contentView removeConstraint:widthFenceConstraint];&#125; 这里首先获得这个UITableViewCell的宽度，赋值给contentViewWidth的对象。 下面判断这个cell中有没有设置accessoryView的这个view，如果设置了accessoryView的话，这个cell的宽度按会稍微小一点（16 + CGRectGetWidth(cell.accessoryView.frame)） 否则会根据accessoryView的类型不同，需要减去不同的宽度。 fd_enforceFrameLayout是用autolayout的、还是使用的frame的布局。 通过NSLayoutConstraint，将cell.contentView的宽度设置为contentViewWidth。 直接返回高度，并将约束移除掉。这里我不是很明白，为什么要这样做。 如果这里的UITableview的格式如果不是UITableViewCellSeparatorStyleNone，高度可能会有点偏差，加上这个偏差（1.0 / [UIScreen mainScreen].scale） ##Demo中第二种方法，其他参数都是一样的，就是多了一个cacheByIndexPath,就是根据IndexPath的对象来存储刚才计算的高度。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/// This method does what "-fd_heightForCellWithIdentifier:configuration" does, and/// calculated height will be cached by its index path, returns a cached height/// when needed. Therefore lots of extra height calculations could be saved.////// No need to worry about invalidating cached heights when data source changes, it/// will be done automatically when you call "-reloadData" or any method that triggers/// UITableView's reloading.////// @param indexPath where this cell's height cache belongs.///- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration &#123; // Hit cache //1. if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123; [self fd_debugLog:[NSString stringWithFormat:@"hit cache by index path[%@:%@] - %@", @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]]; return [self.fd_indexPathHeightCache heightForIndexPath:indexPath]; &#125; //9. CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration]; [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath]; [self fd_debugLog:[NSString stringWithFormat: @"cached by index path[%@:%@] - %@", @(indexPath.section), @(indexPath.row), @(height)]]; return height;&#125;//2.- (BOOL)existsHeightAtIndexPath:(NSIndexPath *)indexPath &#123; //6. NSNumber *number = self.heightsBySectionForCurrentOrientation[indexPath.section][indexPath.row]; return ![number isEqualToNumber:@-1];&#125;//3.- (void)buildCachesAtIndexPathsIfNeeded:(NSArray *)indexPaths &#123; [indexPaths enumerateObjectsUsingBlock:^(NSIndexPath *indexPath, NSUInteger idx, BOOL *stop) &#123; //4. [self buildSectionsIfNeeded:indexPath.section]; //5. [self buildRowsIfNeeded:indexPath.row inExistSection:indexPath.section]; &#125;];&#125;- (void)buildSectionsIfNeeded:(NSInteger)targetSection &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; for (NSInteger section = 0; section &lt;= targetSection; ++section) &#123; if (section &gt;= heightsBySection.count) &#123; heightsBySection[section] = [NSMutableArray array]; &#125; &#125; &#125;];&#125;- (void)buildRowsIfNeeded:(NSInteger)targetRow inExistSection:(NSInteger)section &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; NSMutableArray&lt;NSNumber *&gt; *heightsByRow = heightsBySection[section]; for (NSInteger row = 0; row &lt;= targetRow; ++row) &#123; if (row &gt;= heightsByRow.count) &#123; heightsByRow[row] = @-1; &#125; &#125; &#125;];&#125;//6.typedef NSMutableArray&lt;NSMutableArray&lt;NSNumber *&gt; *&gt; FDIndexPathHeightsBySection;//7.- (CGFloat)heightForIndexPath:(NSIndexPath *)indexPath &#123; [self buildCachesAtIndexPathsIfNeeded:@[indexPath]]; NSNumber *number = self.heightsBySectionForCurrentOrientation[indexPath.section][indexPath.row];&#125;//8.- (FDIndexPathHeightsBySection *)heightsBySectionForCurrentOrientation &#123; return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation) ? self.heightsBySectionForPortrait: self.heightsBySectionForLandscape;&#125; 和上面方法一样的我就不说了，这里的高度缓存部分还是蛮有意思的，这里新建了一个fd_indexPathHeightCache的对象，这个对象就是用来管理缓存的部分，对象继承的是NSObject 通过传入的indexPath来返回这个对象是否已经缓存进去了。 在将indexPath的对象打包成NSArray的对象，对到下一个函数中 将indexPath.section,如果数组中不含有这个section的话，那就新建一个，通过6.可以知道，这个是个二位数组，最外层数组的index的数目就是section 下一个方法就是根据section，找到里面一层的数组，这个数组放的就是对应的rows的对象，如果没有就会默认塞入一个-1的值。 再根据同样的方法，到二维数组中查找对象，如果不是我们之前塞入的-1,那就是true，否则就是false。 这里我没看懂，已经知道在缓存中存在了，为什么还要再掉一遍[self buildCachesAtIndexPathsIfNeeded:@[indexPath]]; 这里可以知道，作者根据横竖屏设置了两个不同的数据，就是为了分别存储、提取。 如果之前没有缓存的话，它会先去调用一遍之前计算高度的方法，然后将计算出来的高度，丢到之前的二维数组中去。 ###第三种的计算方式，就是根据每个model设置不同key值来存储高度。123456789101112131415161718/// This method caches height by your model entity's identifier./// If your model's changed, call "-invalidateHeightForKey:(id &lt;NSCopying&gt;)key" to/// invalidate cache and re-calculate, it's much cheaper and effective than "cacheByIndexPath".////// @param key model entity's identifier whose data configures a cell.///- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration &#123; //1. // Hit cache if ([self.fd_keyedHeightCache existsHeightForKey:key]) &#123; CGFloat cachedHeight = [self.fd_keyedHeightCache heightForKey:key]; [self fd_debugLog:[NSString stringWithFormat:@"hit cache by key[%@] - %@", key, @(cachedHeight)]]; return cachedHeight; &#125; //2. @property (nonatomic, strong) NSMutableDictionary&lt;id&lt;NSCopying&gt;, NSNumber *&gt; *mutableHeightsByKeyForPortrait;&#125; 作者也说了，这个效率会比之前按照indexPath的计算效率要高。 通过这个，我们大概就知道，作者所谓的效率高，应该就是这个意思，这里不是什么二维数组，而是一个NSMutableDictionary对象。其他基本上类似。 最后说一下自己的一个疑问：第二种方法中，作者为什么不将key和value经过简单的运算，作为key，来用NSDictionary来存储数据呢？作者的解释是：里面要配合 section row 的insert remove的话，会比较麻烦。所以作者最后还是选择的二维数组。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Obeject-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于图片圆角的功能学习。]]></title>
    <url>%2F2016%2F04%2F19%2F20160418%2F</url>
    <content type="text"><![CDATA[图片的性能问题，基本上面试的时候，都会被问到，现在在自己的app中，我也是为了解决的性能的问题，所以了解了一些关于图片性能的库，看一下源码, 现在应该有很多这种库了。我看的是这个：https://github.com/CoderJackyHuang/HYBImageCliped 这个库是通过Category来分别实现这些功能，首先看看UIView的Category,是怎么实现的UIView的圆角。 1234567891011121314151617/** * 使用指定的图片来填充，但是生成的是圆形图片，背景颜色为白色。 * * @param image 图片名称或者图片对象，甚至支持NSData * @param targetSize 生成指定大小的图片 * @param isEqualScale 是否等比例缩放图片 * @param backgroundColor 默认取最顶层父视图的背景色，若为透明，则取本身背景色，若也为透明，则取白色 * @parma callback 只有当图片真正被裁剪成功后，才会回调，返回裁剪后的图片 * * @return 裁剪前的图片 */- (UIImage *)hyb_setCircleImage:(id)image size:(CGSize)targetSize isEqualScale:(BOOL)isEqualScale backgrounColor:(UIColor *)backgroundColor onCliped:(HYBClipedCallback)callback; 这只是其中一种Public的方法，我是按照Demo来看的。但是无论哪一种Public的方法，最终调用的都是统一的一个Private 的方法。 12345678- (UIImage *)hyb_private_setImage:(id)image size:(CGSize)targetSize cornerRadius:(CGFloat)cornerRadius rectCorener:(UIRectCorner)rectCorner backgroundColor:(UIColor *)bgColor isEqualScale:(BOOL)isEqualScale isCircle:(BOOL)isCircle onCliped:(HYBClipedCallback)callback 里面有个这个方法：可以看出来，假如你不设置bgColor这个属性的话，他会遍历循环，一直会找到最顶层的父类，去除父类的颜色。所以我觉得你要是没事话，还是自己设置一下颜色吧！这边假如层级很复杂，并且元素很多的话，这个性能可能会让你哭吧... 123456789101112 if (bgColor == nil || CGColorEqualToColor(bgColor.CGColor, [UIColor clearColor].CGColor)) &#123; UIView *superview = self.superview; while (superview.backgroundColor == nil || CGColorEqualToColor(superview.backgroundColor.CGColor, [UIColor clearColor].CGColor)) &#123; if (!superview) &#123; break; &#125; superview = [superview superview]; &#125; bgColor = superview.backgroundColor;&#125; 好吧，下面这段代码又要提到面试宝典中啥经典话题了，如何在category中给现有的类添加属性呢？http://nshipster.com/associated-objects/Matt 大神曾经写过，你可以看一下。 123456789__block UIImage *clipedImage = nil; //1. dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //2. willBeClipedImage.hyb_pathColor = self.hyb_pathColor; willBeClipedImage.hyb_pathWidth = self.hyb_pathWidth; willBeClipedImage.hyb_borderColor = self.hyb_borderColor; willBeClipedImage.hyb_borderWidth = self.hyb_borderWidth; &#125;); 123456789101112这里涉及到的pathColor,pathWidth,borderColor,borderWidth,都是通过在runtime的特性，在已有的类中添加属性的方式来存储和使用的。- (UIColor *)hyb_pathColor &#123; UIColor *color = objc_getAssociatedObject(self, s_hyb_image_pathColorKey); if (color) &#123; return color; &#125; return [UIColor whiteColor];&#125;//...下面都是换汤不换药的。 下面涉及到真正的画图部分了 这里另起一个线程来绘制圆角。这里我有个问题：每个图片都创建一个线程，这个是不是有点问题。而且这个dispatch_get_global_queue也有问题，Global Dispatch Queue创建的队列,其线程数目是不定的,是根据XNU内核决定的。我觉得这一点，源码中没有解释。 绘制圆角的核心函数是这个。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//1.- (UIImage *)hyb_private_clipImageToSize:(CGSize)targetSize cornerRadius:(CGFloat)cornerRadius corners:(UIRectCorner)corners backgroundColor:(UIColor *)backgroundColor isEqualScale:(BOOL)isEqualScale isCircle:(BOOL)isCircle &#123;&#125; CGContextRef ctx = UIGraphicsGetCurrentContext(); //2. if (isCircle) &#123; CGContextAddEllipseInRect(ctx, rect); &#125; else &#123; CGContextAddRect(ctx, rect); &#125; CGContextClip(ctx); [self drawInRect:rectImage]; //3. CGContextSetStrokeColorWithColor(ctx, [borderColor CGColor]); CGContextSetLineWidth(ctx, borderWidth); if (isCircle) &#123; CGContextStrokeEllipseInRect(ctx, rectImage); CGContextStrokeEllipseInRect(ctx, rect); &#125; else if (cornerRadius == 0) &#123; CGContextStrokeRect(ctx, rectImage); CGContextStrokeRect(ctx, rect); &#125; //4. UIBezierPath *path2 = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:CGSizeMake(cornerRadius + minusPath1 ,cornerRadius + minusPath1)]; //5. UIImage *finalImage = UIGraphicsGetImageFromCurrentImageContext(); return finalImage; 里面更新size做了一些文章。是到底要做截成一个正圆，还是只截在哪个角的圆。 如果是正圆、并且不带圆角的话，就用core graphic来画。 内线和外线的绘制、以及粗细、颜色。 如果不是正圆、带圆角的多边形的图形，用UIBezierPath 曲线来绘制。关键是第二个参数，是一个枚举类型，代表哪一个或者哪一些圆角需要绘制、苹果官方的文档为corners: A bitmask value that identifies the corners that you want rounded. You can use this parameter to round only a subset of the corners of the rectangle. 最后直接将绘制的图形返回出来。 最后说一点、无论是UIbutton、UIImage、还是什么、笔者的思路都是先在UIView中添加方法、再在UIImage添加方法、并且进行调用、绘制图形，并且返回。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Obeject-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习YYModel]]></title>
    <url>%2F2016%2F04%2F01%2F20160401%2F</url>
    <content type="text"><![CDATA[以YYModel的例子，它以类的方式调用 1234567+ (instancetype)yy_modelWithJSON:(id)json &#123; NSDictionary *dic = [self _yy_dictionaryWithJSON:json]; return [self yy_modelWithDictionary:dic];&#125;&lt;!-- 1. 直接将json的格式丢给这个函数 --&gt;&lt;!-- 2. 然后调用下面的这个函数，主要是讲这个json转化为NSDictionary的格式，如果是字符串会将字符串转化为NSData,然后再转化为NSDictionary --&gt; 1+ (NSDictionary *)_yy_dictionaryWithJSON:(id)json &#123; 现在开始进入最重要的函数部分了 12//这个函数里获取model元是通过调用下面的方法，cls是获取本类而得到的Class类型+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary &#123;&#125; 1[_YYModelMeta metaWithClass:cls] 1234567891011121314151617181920212223+ (instancetype)metaWithClass:(Class)cls &#123; if (!cls) return nil; static CFMutableDictionaryRef cache; static dispatch_once_t onceToken; //1.. static dispatch_semaphore_t lock; dispatch_once(&amp;onceToken, ^&#123; cache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); lock = dispatch_semaphore_create(1); &#125;); dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls)); dispatch_semaphore_signal(lock); if (!meta || meta-&gt;_classInfo.needUpdate) &#123; meta = [[_YYModelMeta alloc] initWithClass:cls]; if (meta) &#123; dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta)); dispatch_semaphore_signal(lock); &#125; &#125; return meta;&#125; 1234&lt;!-- //以信号量的方式保持同步，作用是为了从cache的内存中获取meta的数据是同步的。 --&gt;dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls)); dispatch_semaphore_signal(lock); 123456789&lt;!-- //或者在讲meta的值塞入内存中保持同步 --&gt; if (!meta || meta-&gt;_classInfo.needUpdate) &#123; meta = [[_YYModelMeta alloc] initWithClass:cls]; if (meta) &#123; dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta)); dispatch_semaphore_signal(lock); &#125; &#125; 1234567&lt;!-- 其中创建meta的时候回调用 --&gt;meta = [[_YYModelMeta alloc] initWithClass:cls];- (instancetype)initWithClass:(Class)cls &#123; YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls]; ..... &#125; 12345678910111213141516 &lt;!-- 这里涉及到YYClassInfo的实例化方法,通过runtime的一些方法，找到本类，父类，元类。 --&gt; - (instancetype)initWithClass:(Class)cls &#123; if (!cls) return nil; self = [super init]; _cls = cls; _superCls = class_getSuperclass(cls); _isMeta = class_isMetaClass(cls); if (!_isMeta) &#123; _metaCls = objc_getMetaClass(class_getName(cls)); &#125; _name = NSStringFromClass(cls); [self _update]; _superClassInfo = [self.class classInfoWithClass:_superCls]; return self;&#125; 然后在_update的方法中 12345678910111213141516171819202122232425&lt;!-- 这里讲model中的方法、属性，ivar以key-value的形式存放在字典中。本类调用完后会在父类中调用再调用一遍。 --&gt; Class cls = self.cls; unsigned int methodCount = 0; Method *methods = class_copyMethodList(cls, &amp;methodCount); if (methods) &#123; NSMutableDictionary *methodInfos = [NSMutableDictionary new]; _methodInfos = methodInfos; for (unsigned int i = 0; i &lt; methodCount; i++) &#123; YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:methods[i]]; if (info.name) methodInfos[info.name] = info; &#125; free(methods); &#125; unsigned int propertyCount = 0; objc_property_t *properties = class_copyPropertyList(cls, &amp;propertyCount); if (properties) &#123; NSMutableDictionary *propertyInfos = [NSMutableDictionary new]; _propertyInfos = propertyInfos; for (unsigned int i = 0; i &lt; propertyCount; i++) &#123; YYClassPropertyInfo *info = [[YYClassPropertyInfo alloc] initWithProperty:properties[i]]; if (info.name) propertyInfos[info.name] = info; &#125; free(properties); &#125;.... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!-- * 最最关键的映射来了，YYModel把这个功能用一个递归函数来实现了。 --&gt;// create mapper NSMutableDictionary *mapper = [NSMutableDictionary new]; NSMutableArray *keyPathPropertyMetas = [NSMutableArray new]; NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new]; if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) &#123; NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper]; [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) &#123; _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName]; if (!propertyMeta) return; [allPropertyMetas removeObjectForKey:propertyName]; if ([mappedToKey isKindOfClass:[NSString class]]) &#123; if (mappedToKey.length == 0) return; propertyMeta-&gt;_mappedToKey = mappedToKey; NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;]; if (keyPath.count &gt; 1) &#123; propertyMeta-&gt;_mappedToKeyPath = keyPath; [keyPathPropertyMetas addObject:propertyMeta]; &#125; propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil; mapper[mappedToKey] = propertyMeta; &#125; else if ([mappedToKey isKindOfClass:[NSArray class]]) &#123; NSMutableArray *mappedToKeyArray = [NSMutableArray new]; for (NSString *oneKey in ((NSArray *)mappedToKey)) &#123; if (![oneKey isKindOfClass:[NSString class]]) continue; if (oneKey.length == 0) continue; NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;]; if (keyPath.count &gt; 1) &#123; [mappedToKeyArray addObject:keyPath]; &#125; else &#123; [mappedToKeyArray addObject:oneKey]; &#125; if (!propertyMeta-&gt;_mappedToKey) &#123; propertyMeta-&gt;_mappedToKey = oneKey; propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil; &#125; &#125; if (!propertyMeta-&gt;_mappedToKey) return; propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray; [multiKeysPropertyMetas addObject:propertyMeta]; propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil; mapper[mappedToKey] = propertyMeta; &#125; &#125;]; &#125; &lt;!-- * 源码中就可以看出，这个映射的函数，你需要复写modelCustomPropertyMapper 这个函数 * 映射这个函数，你可以定义一个NSString的字符串，假如你得字符串中含有“.”这个的话，他就会将这个字符串以“.”分隔成NSArray,然后存入到_mappedToKeyPath 这个变量中。 * 映射也可以是一个NSArray,这样就可以实现同一个model映射到不同的key上了。 --&gt;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Obeject-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2016%2F03%2F28%2F20160328%2F</url>
    <content type="text"><![CDATA[最近身边发生了太多太多事情，让我认识到了生命是多么的脆弱。满怀期望等待着一个什么的到来、可惜Ta却悄悄地离开了我们。我现在只想好好爱着我身边肉丝，一辈子都呵护在她身边，一直保护她，爱护她，不要让她收到一点点的伤害。 为了Rose、我了这个家、为了TA到来。我要好好鼓励工作，给你们最好的未来。 123while(!isSuccess)&#123; func keepMoving()&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>我</tag>
      </tags>
  </entry>
</search>