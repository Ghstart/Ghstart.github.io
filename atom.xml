<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-24T06:53:43.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习React Native中</title>
    <link href="http://yoursite.com/2016/08/24/20160824/"/>
    <id>http://yoursite.com/2016/08/24/20160824/</id>
    <published>2016-08-24T06:53:12.000Z</published>
    <updated>2016-08-24T06:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="其实从去年我就一直看学习并看React-Native-开始学习只是为了兴趣，现在项目中用到了有些更新的功能，我就是用React-native-来做的。其实还是蛮好的，但是我发现更新实在是太快了，现在官网的稳定版本是0-31版本"><a href="#其实从去年我就一直看学习并看React-Native-开始学习只是为了兴趣，现在项目中用到了有些更新的功能，我就是用React-native-来做的。其实还是蛮好的，但是我发现更新实在是太快了，现在官网的稳定版本是0-31版本" class="headerlink" title="其实从去年我就一直看学习并看React Native,开始学习只是为了兴趣，现在项目中用到了有些更新的功能，我就是用React native 来做的。其实还是蛮好的，但是我发现更新实在是太快了，现在官网的稳定版本是0.31版本"></a>其实从去年我就一直看学习并看React Native,开始学习只是为了兴趣，现在项目中用到了有些更新的功能，我就是用React native 来做的。其实还是蛮好的，但是我发现更新实在是太快了，现在官网的稳定版本是<a href="https://facebook.github.io/react-native/" target="_blank" rel="external">0.31版本</a></h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>打开terminal, cd到某个路径下，执行命令 <code>react-native init helloworld</code>[^这里的helloword就是你创建的项目名字]<br>如果出现这样的代码就代码创建成功。</p>
</blockquote>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>To run your app on iOS:
   cd /Users/gonghuan/Desktop/helloworld
   react-native run-ios
   - or -
   Open /Users/gonghuan/Desktop/helloworld/ios/helloworld.xcodeproj in Xcode
   Hit the Run button
To run your app on Android:
   Have an Android emulator running (quickest way to get started), or a device connected
   cd /Users/gonghuan/Desktop/helloworld
   react-native run-android
</code></pre><blockquote>
<p>此时你可以通过类似<code>react-native run-ios</code>可以直接调起iOS模拟器，此时你可以看到你的终端不断在解析，然后就可以成功运行了。</p>
<h2 id="说到这里，应该你已经可以运行你的app了，至于之前要安装-brew-node等等，我这里就不再多说了，你可以去官网上走一遍，很简单。"><a href="#说到这里，应该你已经可以运行你的app了，至于之前要安装-brew-node等等，我这里就不再多说了，你可以去官网上走一遍，很简单。" class="headerlink" title="说到这里，应该你已经可以运行你的app了，至于之前要安装 brew node等等，我这里就不再多说了，你可以去官网上走一遍，很简单。"></a>说到这里，应该你已经可以运行你的app了，至于之前要安装 brew node等等，我这里就不再多说了，你可以去官网上走一遍，很简单。</h2></blockquote>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><blockquote>
<p>我这里我选用的是atom，这里说一个我遇到的小问题，也许你也会遇到，在我们使用atom的时候，需要安装一些插件来帮助我们能够更加高效的写代码，就比如facebook开发的<a href="https://nuclide.io/docs/editor/setup/#quick-install" target="_blank" rel="external">Nuclide</a></p>
</blockquote>
<ol>
<li>按照官方install的说明，我们可以知道有两种安装的方式，一种就是通过直接在终端输入<code>apm install nuclide</code>,但是说实话，我就成功过一次，而且还是要挂vpn，之后就一直没有成功过了，这我就呵呵了。</li>
<li>官方建议第二种方式：直接在atom-&gt;Setting Views-&gt;Manage Packages,搜索Nuclide，直接安装。</li>
<li>第三种：通过这种方式你可以安装Themes、packages</li>
</ol>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code> cd ~/.atom/packages
git clone [packgae-url] # git clone https://github.com/facebook/nuclide
cd [package] #nuclide
npm install
</code></pre><hr>
<p>###好了，到目前为止，你已经可以，我们已经可以开始运行，并且可以安装自己喜欢的插件，已经修改自己喜欢的主题了。下面我们开始coding,我们先通过atom打开我们之前创建的helloworld的项目，并且找到<code>index.ios.js</code>,删除里面所有的代码，不要着急，我们会慢慢的添加进去所有的代码。</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>class firstRN extends Component {
  render() {
    return(
      &lt;Text&gt;
        Hello world
      &lt;/Text&gt;
    );
  }
}

AppRegistry.registerComponent(&#39;helloworld&#39;, ()=&gt;firstRN);
</code></pre><ol>
<li>这里我们先创建一个firstRN的类，继承自Component对象，这里你先不要管，我们后面都会解释的。</li>
<li>第二步，我们用AppRegistry这个注册一个对象，这个对象的名字是我们应用的名字‘helloworld’，第二个参数指向的是我们刚才创建的firstRN类。</li>
<li>我们点击模拟器，发现报错，<code>Unhandled JS Exception:xxxx: Can&#39;t find variable: Component</code>,在文件头部添加</li>
</ol>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>import React, { Component } from &#39;react&#39;;
import { AppRegistry, Text } from &#39;react-native&#39;;
</code></pre><blockquote>
<p>The AppRegistry just tells React Native which component is the root one for the whole application. You won’t be thinking about AppRegistry a lot - there will probably just be one call to AppRegistry.registerComponent in your whole app. It’s included in these examples so you can paste the whole thing into your index.ios.js or index.android.js file and get it running.—-这里是官方给的AppRegistry，其实AppRegistry只做了一件事情，就是告诉这个应用，谁是整个应用的根控制器，这样你可以通过修改index.ios.js来修改iOS的根控制器是啥？安卓也是一样，修改的index.android.js<br>再次刷新模拟器，就会发现左上角会出现我们写的Hello world的文字。<br>这里我们觉得样式好丑，那该怎么办，没事，RN也是可以做到修改的。</p>
</blockquote>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>import React, { Component } from &#39;react&#39;;
import { AppRegistry, Text , StyleSheet } from &#39;react-native&#39;;

class firstRN extends Component {
  render() {
    return(
      &lt;Text style = {styles.helloWorldStyle}&gt;
        Hello world
      &lt;/Text&gt;
    );
  }
}

const styles = StyleSheet.create({
  helloWorldStyle: {
    color:&#39;red&#39;,
    fontSize:30,
    fontWeight:&#39;bold&#39;
  }
})


AppRegistry.registerComponent(&#39;helloworld&#39;, ()=&gt;firstRN);
</code></pre><blockquote>
<p>这里我们需要在import中导读 StyleSheet,因为我们需要在后面的设置样式的时候，用到这个类。<br>直接在text后面添加style的样式熟悉<br>直接在后面创建styles的属性，通过StyleSheet来创建。<br>再次刷新模拟器，你就可以看到效果了。</p>
</blockquote>
<hr>
<h3 id="先说这么多，后期我们还会说到很多在app开发中遇到的各种问题，导航栏，网络请求，传值等等。"><a href="#先说这么多，后期我们还会说到很多在app开发中遇到的各种问题，导航栏，网络请求，传值等等。" class="headerlink" title="先说这么多，后期我们还会说到很多在app开发中遇到的各种问题，导航栏，网络请求，传值等等。"></a>先说这么多，后期我们还会说到很多在app开发中遇到的各种问题，导航栏，网络请求，传值等等。</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;其实从去年我就一直看学习并看React-Native-开始学习只是为了兴趣，现在项目中用到了有些更新的功能，我就是用React-native-来做的。其实还是蛮好的，但是我发现更新实在是太快了，现在官网的稳定版本是0-31版本&quot;&gt;&lt;a href=&quot;#其实从去年我就
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>因为我不想打卡，不要问我为什么？？</title>
    <link href="http://yoursite.com/2016/08/15/20160815/"/>
    <id>http://yoursite.com/2016/08/15/20160815/</id>
    <published>2016-08-15T06:28:12.000Z</published>
    <updated>2016-08-15T10:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>###最近一直没啥时间来整理一些学习资料以及学习的内容，感觉这样不是很好。又由于公司要打卡了，所以我就写写我是怎么不打卡的吧！O(∩_∩)O~~~</p>
<ol>
<li>mac电脑先安装抓包神器：Charles (网上有很多这个使用教程，我就不多说了，毕竟是工具，没啥难度)</li>
<li>点击Help-&gt;Local IP Address,将本机的IP打印出来，然后在手机里面设置代理为相应的IP，端口为：8888</li>
<li>此时你就可以开始看到数据的返回、和请求了。</li>
</ol>
<pre><code>![1.pi](media/14712518179704/1.pic.jpg)
</code></pre><ol>
<li>然后你就可以看到你想要的代码请求了，其实这个Android和iOS,还有点不同，Android返回的代码不是text/json,而是text/html,我在我代码中加入了代码格式的转换。</li>
</ol>
<p></p><p class="code-caption" data-lang="object-c" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code class="object-c">
     __block NSDictionary *par = @{@&quot;employeeNo&quot;:pp.employeeNo,@&quot;coord&quot;:@&quot;30.249812,120.211494&quot;,@&quot;img_ids&quot;:@&quot;&quot;,@&quot;identifier&quot;: pp.identifier,@&quot;type&quot;: @&quot;0&quot;}};

     AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
            [manager POST:@&quot;http://xxxx/HSSCM/appmail/employeeRecordManage/sign.do&quot; parameters:par success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
                NSLog(@&quot;%@&quot;,operation);
                NSLog(@&quot;%@&quot;,responseObject);
            } failure:^(AFHTTPRequestOperation * _Nullable operation, NSError * _Nonnull error) {
                NSLog(@&quot;%@&quot;,operation);
                NSLog(@&quot;%@&quot;,error);
            }];
</code></pre>
<ol>
<li>你或许已经发现了参数的规律了，这里的employeeNO就是我们之前抓包的用户唯一标示符（安卓这边还耍了个心眼，取了一个很怪的名字，视图误导我们）</li>
<li>coord就是经纬度，用逗号链接起来的一个字符串</li>
<li>img_ids我不知道是个什么东西，反正可有可无</li>
<li>identifior是手机的udid（iOS中这样称呼吧）,这里我猜想他的employeeNO与手机identifior是一一对应的，<strong>所以这也就解释了为什么我在换手机的时候，会报错</strong></li>
<li>type:0–就是签出，1–就是签到</li>
</ol>
<hr>
<p>##现在问题都已经分析完了，我们该用什么对策来自动帮我们打卡呢。</p>
<p>####由于必须需要内网才能打卡，我们不能外网或者4G的条件下打卡，折让我们很蛋疼，这里我想到几个解决方案：</p>
<ol>
<li>安卓的手机，可以借用一款叫做&lt;按键精灵&gt;的app,但是有个条件就是你必须拿到root权限，这样就可以录制你按键的动作，你可以指定时间执行。</li>
<li>公司的电脑、或者测试机，安装一个teamViewer，这样你就可以在家里远程操控他。</li>
<li>公司的测试机充当服务器的功能、一直在跑，这样我需要关心的只有一件事：手机有电。</li>
</ol>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>
    - (NSArray *)setUPDatas:(TypeStatus)typeStatus {
     NSMutableArray *datas = [NSMutableArray new];

     NSArray *employeeNos = @[@&quot;31330034&quot;, @&quot;31330040&quot;, @&quot;31330035&quot;];
     NSArray *identifiers = @[@&quot;05B7A575-2D2A-4006-890A-D0994EFF3DAC&quot;, @&quot;a000004f73cb94&quot;, @&quot;1B65EB63-487B-49BF-B751-F2D544175BE7&quot;];
     for (int i = 0 ; i &lt; employeeNos.count ; i++) {
         People *people = [[People alloc] init];
         people.employeeNo = employeeNos[i];
         people.coord = @&quot;30.249812,120.211494&quot;;
         people.img_ids = @&quot;&quot;;
         people.identifier = identifiers[i];
         if (typeStatus == LogIn) {
             people.type = @&quot;1&quot;;
         } else {
             people.type = @&quot;0&quot;;
         }

         people.random_signInMin = [self getRandomNumber:5 to:25];
         people.random_signInSec = [self getRandomNumber:1 to:59];
         people.random_signOutMin = [self getRandomNumber:5 to:25];
         people.random_signOutSec = [self getRandomNumber:1 to:59];

         [datas addObject:people];
     }

     return [datas copy];
     }



     - (int)getRandomNumber:(int)from to:(int)to {
     return (int)(from + (arc4random() % (to - from + 1)));
     }

#### 我在这里实例化了用户的对象，在这个对象生成的同事，就已经确定这个对象签到的时间，和签出的时间（在某个数范围内随机生成）。


if (hour == signOutHour) { // 签出--0

             if (self.needSignOut.count == 0) return;

             for (int i = 0 ; i &lt; self.needSignOut.count; i++) {
                 People *pp = self.needSignOut[i];

                 if (pp.random_signOutMin &lt; min || (pp.random_signOutMin == min &amp;&amp; pp.random_signOutSec &lt;= sec)) {
                     par = @{
                             @&quot;employeeNo&quot;:pp.employeeNo,
                             @&quot;coord&quot;: @&quot;30.249812,120.211494&quot;,
                             @&quot;img_ids&quot;:@&quot;&quot;,
                             @&quot;identifier&quot;: pp.identifier,
                             @&quot;type&quot;: pp.type};

                     [self SignOrSignOut:par week:week time:[NSString stringWithFormat:@&quot;%ld:%ld:%ld&quot;,(long)hour,(long)min,(long)sec]];
                 }
             }
            }
</code></pre><hr>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>- (void)needToRemove:(TypeStatus)status identifior:(NSString *)identifior realtime:(NSString *)realtime{
 if (status == LogIn) {
     for (int i = 0 ; i &lt; self.needSignIn.count; i++) {
         NSMutableDictionary *tempDic = [NSMutableDictionary new];
         People *pp = self.needSignIn[i];
         if ([pp.identifier isEqualToString:identifior] &amp;&amp; ![identifior isEqualToString:@&quot;&quot;]) {
             NSLog(@&quot;移除people:%@---loginMin:%ld----loginSec:%ld&quot;,pp.identifier,(long)pp.random_signInMin, (long)pp.random_signInSec);

             [self.needSignIn removeObject:pp];


             if (pp.identifier != nil) [tempDic setObject:pp.identifier forKey:@&quot;iden&quot;];
             [tempDic setObject:[NSString stringWithFormat:@&quot;签到时间:%ld:%ld:%ld&quot;, signInHour, pp.random_signInMin, pp.random_signInSec] forKey:@&quot;time&quot;];
             if (realtime != nil) [tempDic setObject:realtime forKey:@&quot;realtime&quot;];

             if (tempDic != nil) [self.tableViewDatas addObject:tempDic];

         }
     }
</code></pre><ol>
<li>这里你会发现我在遍历的同事，又对mutableArray对象进行的操作，开始一直crash，会报这个错：<strong>collection __nsarraym was mutated while being enumerated</strong></li>
<li>意思就是说，你在遍历这个对象的同事，又对这个对象进行了添加、删除的操作。这里给你三种解决的思路。</li>
</ol>
<blockquote>
<p>1</p>
</blockquote>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>for (int i = 0 ; i &lt; self.needSignIn.count; i++) {}
</code></pre><p>替换</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>for (People *pp in self.needSignIn) {}
</code></pre><blockquote>
<p>2</p>
</blockquote>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>NSSortDescriptor *sd1 = [NSSortDescriptor sortDescriptorWithKey:nil ascending:NO];//yes升序排列，no,降序排列
NSArray *myary = [ary sortedArrayUsingDescriptors:[NSArray arrayWithObjects:sd1, nil]];//注意这里的ary进行排序后会生产一个新的数组指针，myary，不能在用ary,ary还是保持不变的。
for (People *pp in myary) {}
</code></pre><blockquote>
<p>3</p>
</blockquote>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>生成一个零时的数组，用来遍历，之前的数据用来操作。
</code></pre><p><strong>其实这里有个问题，想了好久才想明白：为什么正序排列不行，倒序就可以呢？？,为什么for不行，但是forin的可以呢？</strong></p>
<p>####其实for的语句可以等同于：假如说我有10个元素，在第一个的时候，我就remove了，那是不是到了第九个的时候就越界了呢？？</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>int count =  arr.count; for (i=0;i&lt;count;i++) {}
</code></pre><p><strong>倒序同样的道理：</strong></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>int count =  arr.count;
for (i = count - 1;i&gt;=0 ;i—) {}
</code></pre><h4 id="当我移除当前这个的时候，其实比不影响我其他的元素布局。"><a href="#当我移除当前这个的时候，其实比不影响我其他的元素布局。" class="headerlink" title="当我移除当前这个的时候，其实比不影响我其他的元素布局。"></a>当我移除当前这个的时候，其实比不影响我其他的元素布局。</h4><p><strong>但是这两种情况，假如你使用for的语句格式，就不会有问题了</strong></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>for (int i = 0 ; i &lt; self.needSignIn.count; i++) {}
</code></pre><p>###总结一句话：</p>
<ol>
<li>当我们正序遍历时,如果删除了一个,那么没有遍历到的元素位置都会往前移动一位,这样系统就无法确定接下来遍历是从删除位置开始呢,还是从删除位置下一位开始呢</li>
<li>对于逆序遍历就不会,因为我们逆序遍历时,遇到匹配的元素删除后,位置改变的是遍历过得元素,而没有遍历到的元素位置却没有改变,所以遍历能够正常进行.</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###最近一直没啥时间来整理一些学习资料以及学习的内容，感觉这样不是很好。又由于公司要打卡了，所以我就写写我是怎么不打卡的吧！O(∩_∩)O~~~&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mac电脑先安装抓包神器：Charles (网上有很多这个使用教程，我就不多说了，毕竟是工具，没啥难
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Obeject-c" scheme="http://yoursite.com/tags/Obeject-c/"/>
    
  </entry>
  
  <entry>
    <title>搭建SDK中所遇到的坑</title>
    <link href="http://yoursite.com/2016/05/10/20160510/"/>
    <id>http://yoursite.com/2016/05/10/20160510/</id>
    <published>2016-05-10T01:41:12.000Z</published>
    <updated>2016-05-10T01:44:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="其实开始之前，我找到一篇很不错的文章，想翻译的，但是google了一下，发现已经有好多人翻译过这篇文章了，这里我就不再多说什么了，把原文的链接贴出来。https-www-raywenderlich-com-65964-create-a-framework-for-ios-这里我就说一下，我在搭建sdk的时候，遇到的坑吧。"><a href="#其实开始之前，我找到一篇很不错的文章，想翻译的，但是google了一下，发现已经有好多人翻译过这篇文章了，这里我就不再多说什么了，把原文的链接贴出来。https-www-raywenderlich-com-65964-create-a-framework-for-ios-这里我就说一下，我在搭建sdk的时候，遇到的坑吧。" class="headerlink" title="其实开始之前，我找到一篇很不错的文章，想翻译的，但是google了一下，发现已经有好多人翻译过这篇文章了，这里我就不再多说什么了，把原文的链接贴出来。https://www.raywenderlich.com/65964/create-a-framework-for-ios,这里我就说一下，我在搭建sdk的时候，遇到的坑吧。"></a>其实开始之前，我找到一篇很不错的文章，想翻译的，但是google了一下，发现已经有好多人翻译过这篇文章了，这里我就不再多说什么了，把原文的链接贴出来。<a href="https://www.raywenderlich.com/65964/create-a-framework-for-ios" target="_blank" rel="external">https://www.raywenderlich.com/65964/create-a-framework-for-ios</a>,这里我就说一下，我在搭建sdk的时候，遇到的坑吧。</h2><ol>
<li>其实你要是能够走完上面的流程，你基本上已经完成了80%了，剩下的就是发现问题，再去打包。</li>
</ol>
<h3 id="第一个错误"><a href="#第一个错误" class="headerlink" title="第一个错误"></a>第一个错误</h3><p><code>*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;Could not find a storyboard named &#39;XXXXname&#39; in bundle NSBundle</code></p>
<ul>
<li>这个错误可能直接就会导致app起不来，一启动就会crash，这里需要将所有你用到xib，storyboard的文件都统一作出修改。<code>其实这个问题在遇到用xib/SB创建的cell的时候、在xib/SB中添加图片的时候需要将[UIImage imageNamed:@&quot;&quot;] =======&gt; 修改为 [UIImage imageNamed:@&quot;xxxx.bundle/xxxxName&quot;]</code></li>
</ul>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>UIStoryboard *main = [UIStoryboard storyboardWithName:@&quot;xxxxName&quot; bundle:[NSBundle mainBundle]];

修改为===============================

UIStoryboard *main = [UIStoryboard storyboardWithName:@&quot;xxxx.bundle/xxxxName&quot; bundle:[NSBundle mainBundle]];
</code></pre><h3 id="第二个错误"><a href="#第二个错误" class="headerlink" title="第二个错误"></a>第二个错误</h3><p><code>可能会在Iphone4的时候，直接无法build,直接报这个错： dyld: Symbol not found: ___NSDictionary0__</code></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>需要将项目中的build Phases 中的core foundation的stastu的状态 从Required修改为Optional
</code></pre><p><code>后续如果还有其他的bug，我再贴出来吧！</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;其实开始之前，我找到一篇很不错的文章，想翻译的，但是google了一下，发现已经有好多人翻译过这篇文章了，这里我就不再多说什么了，把原文的链接贴出来。https-www-raywenderlich-com-65964-create-a-framework-for-
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Obeject-c" scheme="http://yoursite.com/tags/Obeject-c/"/>
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>关于学习UITableViewCell的高度计算的框架-UITableView-FDTemplateLayoutCell。</title>
    <link href="http://yoursite.com/2016/05/05/20160505/"/>
    <id>http://yoursite.com/2016/05/05/20160505/</id>
    <published>2016-05-05T09:06:12.000Z</published>
    <updated>2016-05-06T06:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习UITableView的高度计算的框架"><a href="#学习UITableView的高度计算的框架" class="headerlink" title="学习UITableView的高度计算的框架"></a>学习UITableView的高度计算的框架</h2><h2 id="这里学习的是UITableView-FDTemplateLayoutCellhttps-github-com-forkingdog-UITableView-FDTemplateLayoutCell你也可以自己去下载并且学习。"><a href="#这里学习的是UITableView-FDTemplateLayoutCellhttps-github-com-forkingdog-UITableView-FDTemplateLayoutCell你也可以自己去下载并且学习。" class="headerlink" title="这里学习的是UITableView-FDTemplateLayoutCellhttps://github.com/forkingdog/UITableView-FDTemplateLayoutCell你也可以自己去下载并且学习。"></a>这里学习的是UITableView-FDTemplateLayoutCell<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a>你也可以自己去下载并且学习。</h2><ul>
<li>他的文件很简单，直接在UITableView的高度放回中去调用方法：直接调用UITableView 中(FDTemplateLayoutCell)的category的方法,其实他的category里面一共写了三种可以计算高度的方法，这是其中的一种：</li>
</ul>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration {
        //1.
        if (!identifier) {
        return 0;
    }

    //2.
    UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];

    // Manually calls to ensure consistent behavior with actual cells. (that are displayed on screen)
    [templateLayoutCell prepareForReuse];

    //8.
    // Customize and provide content for our template cell.
    if (configuration) {
        configuration(templateLayoutCell);
    }

    return [self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];


//2.
- (__kindof UITableViewCell *)fd_templateCellForReuseIdentifier:(NSString *)identifier {
    //....
        //4.
        if (!templateCellsByIdentifiers) {
        templateCellsByIdentifiers = @{}.mutableCopy;
        objc_setAssociatedObject(self, _cmd, templateCellsByIdentifiers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }

        //5.
        if (!templateCell) {
        templateCell = [self dequeueReusableCellWithIdentifier:identifier];
        NSAssert(templateCell != nil, @&quot;Cell must be registered to table view for identifier - %@&quot;, identifier);
        //6.
        templateCell.fd_isTemplateLayoutCell = YES;
        templateCell.contentView.translatesAutoresizingMaskIntoConstraints = NO;
        templateCellsByIdentifiers[identifier] = templateCell;
        [self fd_debugLog:[NSString stringWithFormat:@&quot;layout cell created - %@&quot;, identifier]];
    }

    //....
)

//3.
/**
 * Returns the value associated with a given object for a given key.
 *
 * @param object The source object for the association.
 * @param key The key for the association.
 *
 * @return The value associated with the key \e key for \e object.
 *
 * @see objc_setAssociatedObject
 */
OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)

//6.
/// Indicate this is a template layout cell for calculation only.
/// You may need this when there are non-UI side effects when configure a cell.
/// Like:
///   - (void)configureCell:(FooCell *)cell atIndexPath:(NSIndexPath *)indexPath {
///       cell.entity = [self entityAtIndexPath:indexPath];
///       if (!cell.fd_isTemplateLayoutCell) {
///           [self notifySomething]; // non-UI side effects
///       }
///   }
///
@property (nonatomic, assign) BOOL fd_isTemplateLayoutCell;

//7.
- (BOOL)fd_isTemplateLayoutCell {
    return [objc_getAssociatedObject(self, _cmd) boolValue];
}

- (void)setFd_isTemplateLayoutCell:(BOOL)isTemplateLayoutCell {
    objc_setAssociatedObject(self, @selector(fd_isTemplateLayoutCell), @(isTemplateLayoutCell), OBJC_ASSOCIATION_RETAIN);
}
</code></pre><ol>
<li>这里假如不传入identifior的值得话，他就直接直接返回0，表示不计算高度了。</li>
<li>这里根据传入的identifior的值，来找到相应的UITableViewCell</li>
<li>这里是runtime源码中所申明的，可以看到这个是根据给的Object以及给的Key来返回一个对象</li>
<li>第一次申明的话，它就会创建一个空的可变字典对象,字典的对象是{<nsstring *,="" uitableviewcell="" *="">},key是String, value是UITableViewCell。</nsstring></li>
<li>当第一次没有UITableViewCell的对象的时候，就开始在重用池中，找UITableViewCell的对象,并将UITableViewCell对象塞进之前的字典对象。</li>
<li>这边在塞入UITableViewCell对象的时候，通过category(7.)来这是这个UITableViewCell的属性，这个作者的用意就是表明这个只是用计算高度的。</li>
<li>如果需要在cell中设置cell元素中的值，就在这里设置。最后拿到UITableViewCell的对象。</li>
</ol>
<h2 id="最后将拿到的UITableViewCell的对象丢到这个函数中计算"><a href="#最后将拿到的UITableViewCell的对象丢到这个函数中计算" class="headerlink" title="最后将拿到的UITableViewCell的对象丢到这个函数中计算"></a>最后将拿到的UITableViewCell的对象丢到这个函数中计算</h2><p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell {
      // Auto layout engine does its math
      // 6.
        fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;
        [cell.contentView removeConstraint:widthFenceConstraint];
}
</code></pre><ol>
<li>这里首先获得这个UITableViewCell的宽度，赋值给contentViewWidth的对象。</li>
<li>下面判断这个cell中有没有设置accessoryView的这个view，如果设置了accessoryView的话，这个cell的宽度按会稍微小一点（16 + CGRectGetWidth(cell.accessoryView.frame)）</li>
<li>否则会根据accessoryView的类型不同，需要减去不同的宽度。</li>
<li>fd_enforceFrameLayout是用autolayout的、还是使用的frame的布局。</li>
<li>通过NSLayoutConstraint，将cell.contentView的宽度设置为contentViewWidth。</li>
<li><code>直接返回高度，并将约束移除掉。这里我不是很明白，为什么要这样做。</code></li>
<li>如果这里的UITableview的格式如果不是UITableViewCellSeparatorStyleNone，高度可能会有点偏差，加上这个偏差（1.0 / [UIScreen mainScreen].scale）</li>
</ol>
<p>##Demo中第二种方法，其他参数都是一样的，就是多了一个cacheByIndexPath,就是根据IndexPath的对象来存储刚才计算的高度。</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>/// This method does what &quot;-fd_heightForCellWithIdentifier:configuration&quot; does, and
/// calculated height will be cached by its index path, returns a cached height
/// when needed. Therefore lots of extra height calculations could be saved.
///
/// No need to worry about invalidating cached heights when data source changes, it
/// will be done automatically when you call &quot;-reloadData&quot; or any method that triggers
/// UITableView&#39;s reloading.
///
/// @param indexPath where this cell&#39;s height cache belongs.
///
- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration {

        // Hit cache
        //1.
    if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) {
        [self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @([self.fd_indexPathHeightCache heightForIndexPath:indexPath])]];
        return [self.fd_indexPathHeightCache heightForIndexPath:indexPath];
    }
    //9.
     CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration];
    [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath];
    [self fd_debugLog:[NSString stringWithFormat: @&quot;cached by index path[%@:%@] - %@&quot;, @(indexPath.section), @(indexPath.row), @(height)]];

    return height;
}

//2.
- (BOOL)existsHeightAtIndexPath:(NSIndexPath *)indexPath {
    //6.
     NSNumber *number = self.heightsBySectionForCurrentOrientation[indexPath.section][indexPath.row];
    return ![number isEqualToNumber:@-1];
}

//3.
- (void)buildCachesAtIndexPathsIfNeeded:(NSArray *)indexPaths {
      [indexPaths enumerateObjectsUsingBlock:^(NSIndexPath *indexPath, NSUInteger idx, BOOL *stop) {
      //4.
        [self buildSectionsIfNeeded:indexPath.section];
      //5.
        [self buildRowsIfNeeded:indexPath.row inExistSection:indexPath.section];
    }];
}

- (void)buildSectionsIfNeeded:(NSInteger)targetSection {
    [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) {
        for (NSInteger section = 0; section &lt;= targetSection; ++section) {
            if (section &gt;= heightsBySection.count) {
                heightsBySection[section] = [NSMutableArray array];
            }
        }
    }];
}

- (void)buildRowsIfNeeded:(NSInteger)targetRow inExistSection:(NSInteger)section {
    [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) {
        NSMutableArray&lt;NSNumber *&gt; *heightsByRow = heightsBySection[section];
        for (NSInteger row = 0; row &lt;= targetRow; ++row) {
            if (row &gt;= heightsByRow.count) {
                heightsByRow[row] = @-1;
            }
        }
    }];
}

//6.
typedef NSMutableArray&lt;NSMutableArray&lt;NSNumber *&gt; *&gt; FDIndexPathHeightsBySection;

//7.
- (CGFloat)heightForIndexPath:(NSIndexPath *)indexPath {
    [self buildCachesAtIndexPathsIfNeeded:@[indexPath]];
    NSNumber *number = self.heightsBySectionForCurrentOrientation[indexPath.section][indexPath.row];
}

//8.
- (FDIndexPathHeightsBySection *)heightsBySectionForCurrentOrientation {
    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation) ? self.heightsBySectionForPortrait: self.heightsBySectionForLandscape;
}
</code></pre><ol>
<li>和上面方法一样的我就不说了，这里的高度缓存部分还是蛮有意思的，这里新建了一个fd_indexPathHeightCache的对象，这个对象就是用来管理缓存的部分，对象继承的是NSObject</li>
<li>通过传入的indexPath来返回这个对象是否已经缓存进去了。</li>
<li>在将indexPath的对象打包成NSArray的对象，对到下一个函数中</li>
<li>将indexPath.section,如果数组中不含有这个section的话，那就新建一个，通过6.可以知道，这个是个二位数组，最外层数组的index的数目就是section</li>
<li>下一个方法就是根据section，找到里面一层的数组，这个数组放的就是对应的rows的对象，如果没有就会默认塞入一个-1的值。</li>
<li>再根据同样的方法，到二维数组中查找对象，如果不是我们之前塞入的-1,那就是true，否则就是false。</li>
<li><code>这里我没看懂，已经知道在缓存中存在了，为什么还要再掉一遍[self buildCachesAtIndexPathsIfNeeded:@[indexPath]];</code></li>
<li>这里可以知道，作者根据横竖屏设置了两个不同的数据，就是为了分别存储、提取。</li>
<li>如果之前没有缓存的话，它会先去调用一遍之前计算高度的方法，然后将计算出来的高度，丢到之前的二维数组中去。</li>
</ol>
<p>###第三种的计算方式，就是根据每个model设置不同key值来存储高度。</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>/// This method caches height by your model entity&#39;s identifier.
/// If your model&#39;s changed, call &quot;-invalidateHeightForKey:(id &lt;NSCopying&gt;)key&quot; to
/// invalidate cache and re-calculate, it&#39;s much cheaper and effective than &quot;cacheByIndexPath&quot;.
///
/// @param key model entity&#39;s identifier whose data configures a cell.
///
- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration {
    //1.
       // Hit cache
    if ([self.fd_keyedHeightCache existsHeightForKey:key]) {
        CGFloat cachedHeight = [self.fd_keyedHeightCache heightForKey:key];
        [self fd_debugLog:[NSString stringWithFormat:@&quot;hit cache by key[%@] - %@&quot;, key, @(cachedHeight)]];
        return cachedHeight;
    }

    //2.
    @property (nonatomic, strong) NSMutableDictionary&lt;id&lt;NSCopying&gt;, NSNumber *&gt; *mutableHeightsByKeyForPortrait;
}
</code></pre><ol>
<li>作者也说了，这个效率会比之前按照indexPath的计算效率要高。</li>
<li>通过这个，我们大概就知道，作者所谓的效率高，应该就是这个意思，这里不是什么二维数组，而是一个NSMutableDictionary对象。其他基本上类似。</li>
</ol>
<p><code>最后说一下自己的一个疑问：第二种方法中，作者为什么不将key和value经过简单的运算，作为key，来用NSDictionary来存储数据呢？作者的解释是：里面要配合 section row 的insert remove的话，会比较麻烦。所以作者最后还是选择的二维数组。</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;学习UITableView的高度计算的框架&quot;&gt;&lt;a href=&quot;#学习UITableView的高度计算的框架&quot; class=&quot;headerlink&quot; title=&quot;学习UITableView的高度计算的框架&quot;&gt;&lt;/a&gt;学习UITableView的高度计算的框架&lt;/
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Obeject-c" scheme="http://yoursite.com/tags/Obeject-c/"/>
    
  </entry>
  
  <entry>
    <title>关于图片圆角的功能学习。</title>
    <link href="http://yoursite.com/2016/04/19/20160418/"/>
    <id>http://yoursite.com/2016/04/19/20160418/</id>
    <published>2016-04-19T03:12:12.000Z</published>
    <updated>2016-04-19T03:17:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>###图片的性能问题，基本上面试的时候，都会被问到，现在在自己的app中，我也是为了解决的性能的问题，所以了解了一些关于图片性能的库，看一下源码, 现在应该有很多这种库了。我看的是这个：<a href="https://github.com/CoderJackyHuang/HYBImageCliped" target="_blank" rel="external">https://github.com/CoderJackyHuang/HYBImageCliped</a></p>
<ul>
<li>这个库是通过Category来分别实现这些功能，首先看看UIView的Category,是怎么实现的UIView的圆角。</li>
</ul>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>/**
 *    使用指定的图片来填充，但是生成的是圆形图片，背景颜色为白色。
 *
 *    @param image            图片名称或者图片对象，甚至支持NSData
 *    @param targetSize    生成指定大小的图片
 *    @param isEqualScale    是否等比例缩放图片
 *  @param backgroundColor 默认取最顶层父视图的背景色，若为透明，则取本身背景色，若也为透明，则取白色
 *  @parma callback   只有当图片真正被裁剪成功后，才会回调，返回裁剪后的图片
 *
 *    @return 裁剪前的图片
 */

- (UIImage *)hyb_setCircleImage:(id)image
                           size:(CGSize)targetSize
                   isEqualScale:(BOOL)isEqualScale
                 backgrounColor:(UIColor *)backgroundColor
                       onCliped:(HYBClipedCallback)callback;
</code></pre><ul>
<li>这只是其中一种Public的方法，我是按照Demo来看的。但是无论哪一种Public的方法，最终调用的都是统一的一个Private 的方法。</li>
</ul>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>- (UIImage *)hyb_private_setImage:(id)image
                             size:(CGSize)targetSize
                     cornerRadius:(CGFloat)cornerRadius
                      rectCorener:(UIRectCorner)rectCorner
                  backgroundColor:(UIColor *)bgColor
                     isEqualScale:(BOOL)isEqualScale
                         isCircle:(BOOL)isCircle
                         onCliped:(HYBClipedCallback)callback
</code></pre><ul>
<li>里面有个这个方法：可以看出来，假如你不设置bgColor这个属性的话，他会遍历循环，一直会找到最顶层的父类，去除父类的颜色。<code>所以我觉得你要是没事话，还是自己设置一下颜色吧！这边假如层级很复杂，并且元素很多的话，这个性能可能会让你哭吧...</code></li>
</ul>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>   if (bgColor == nil || CGColorEqualToColor(bgColor.CGColor, [UIColor clearColor].CGColor)) {
    UIView *superview = self.superview;
    while (superview.backgroundColor == nil || CGColorEqualToColor(superview.backgroundColor.CGColor, [UIColor clearColor].CGColor)) {
      if (!superview) {
        break;
      }

      superview = [superview superview];
    }

    bgColor = superview.backgroundColor;
  }
</code></pre><ul>
<li>好吧，下面这段代码又要提到面试宝典中啥经典话题了，<code>如何在category中给现有的类添加属性呢？</code><br><a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">http://nshipster.com/associated-objects/</a>Matt 大神曾经写过，你可以看一下。</li>
</ul>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code>__block UIImage *clipedImage = nil;
    //1.
  dispatch_async(dispatch_get_global_queue(0, 0), ^{
  //2.
    willBeClipedImage.hyb_pathColor = self.hyb_pathColor;
    willBeClipedImage.hyb_pathWidth = self.hyb_pathWidth;
    willBeClipedImage.hyb_borderColor = self.hyb_borderColor;
    willBeClipedImage.hyb_borderWidth = self.hyb_borderWidth;
  });
</code></pre><pre><code>这里涉及到的pathColor,pathWidth,borderColor,borderWidth,都是通过在runtime的特性，在已有的类中添加属性的方式来存储和使用的。
- (UIColor *)hyb_pathColor {
  UIColor *color = objc_getAssociatedObject(self, s_hyb_image_pathColorKey);

  if (color) {
    return color;
  }

  return [UIColor whiteColor];
}

//...下面都是换汤不换药的。

&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;frontend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;&quot; data-labels_right=&quot;&quot; data-labels_copy=&quot;&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</code></pre><p><code>下面涉及到真正的画图部分了</code></p>
<ol>
<li>这里另起一个线程来绘制圆角。这里我有个问题：<code>每个图片都创建一个线程，这个是不是有点问题。而且这个dispatch_get_global_queue也有问题，Global Dispatch Queue创建的队列,其线程数目是不定的,是根据XNU内核决定的。我觉得这一点，源码中没有解释。</code></li>
</ol>
<ul>
<li>绘制圆角的核心函数是这个。<br>```<br>//1.</li>
</ul>
<ul>
<li><p>(UIImage *)hyb_private_clipImageToSize:(CGSize)targetSize</p>
<pre><code>                      cornerRadius:(CGFloat)cornerRadius
                           corners:(UIRectCorner)corners
                   backgroundColor:(UIColor *)backgroundColor
                      isEqualScale:(BOOL)isEqualScale
                          isCircle:(BOOL)isCircle {}

                          CGContextRef ctx = UIGraphicsGetCurrentContext();
</code></pre></li>
</ul>
<pre><code>//2.
if (isCircle) {
  CGContextAddEllipseInRect(ctx, rect);
} else {
  CGContextAddRect(ctx, rect);
}

CGContextClip(ctx);
[self drawInRect:rectImage];

//3.

    CGContextSetStrokeColorWithColor(ctx, [borderColor CGColor]);
CGContextSetLineWidth(ctx, borderWidth);

if (isCircle) {
  CGContextStrokeEllipseInRect(ctx, rectImage);
  CGContextStrokeEllipseInRect(ctx, rect);
} else if (cornerRadius == 0) {
  CGContextStrokeRect(ctx, rectImage);
  CGContextStrokeRect(ctx, rect);
}

//4.
 UIBezierPath *path2 = [UIBezierPath bezierPathWithRoundedRect:rect
                                            byRoundingCorners:corners
                                                  cornerRadii:CGSizeMake(cornerRadius + minusPath1 ,cornerRadius + minusPath1)];


//5.
UIImage *finalImage = UIGraphicsGetImageFromCurrentImageContext();

return finalImage;
</code></pre><p>```</p>
<ol>
<li>里面更新size做了一些文章。是到底要做截成一个正圆，还是只截在哪个角的圆。</li>
<li>如果是正圆、并且不带圆角的话，就用core graphic来画。</li>
<li>内线和外线的绘制、以及粗细、颜色。</li>
<li><p>如果不是正圆、带圆角的多边形的图形，用UIBezierPath 曲线来绘制。关键是第二个参数，是一个枚举类型，代表哪一个或者哪一些圆角需要绘制、苹果官方的文档为<code>corners:
A bitmask value that identifies the corners that you want rounded. You can use this parameter to round only a subset of the corners of the rectangle.</code></p>
</li>
<li><p>最后直接将绘制的图形返回出来。</p>
</li>
<li>最后说一点、无论是UIbutton、UIImage、还是什么、笔者的思路都是先在UIView中添加方法、再在UIImage添加方法、并且进行调用、绘制图形，并且返回。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###图片的性能问题，基本上面试的时候，都会被问到，现在在自己的app中，我也是为了解决的性能的问题，所以了解了一些关于图片性能的库，看一下源码, 现在应该有很多这种库了。我看的是这个：&lt;a href=&quot;https://github.com/CoderJackyHuang/
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Obeject-c" scheme="http://yoursite.com/tags/Obeject-c/"/>
    
  </entry>
  
  <entry>
    <title>学习YYModel</title>
    <link href="http://yoursite.com/2016/04/01/20160401/"/>
    <id>http://yoursite.com/2016/04/01/20160401/</id>
    <published>2016-04-01T06:28:12.000Z</published>
    <updated>2016-10-13T02:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>以YYModel的例子，它以类的方式调用</p>
<p></p><p class="code-caption" data-lang="{bash}" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code class="{bash}">+ (instancetype)yy_modelWithJSON:(id)json {
    NSDictionary *dic = [self _yy_dictionaryWithJSON:json];
    return [self yy_modelWithDictionary:dic];
}

&lt;!-- 1. 直接将json的格式丢给这个函数 --&gt;
&lt;!-- 2. 然后调用下面的这个函数，主要是讲这个json转化为NSDictionary的格式，如果是字符串会将字符串转化为NSData,然后再转化为NSDictionary --&gt;
</code></pre>
<pre><code class="{bash}">+ (NSDictionary *)_yy_dictionaryWithJSON:(id)json {
&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;frontend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;&quot; data-labels_right=&quot;&quot; data-labels_copy=&quot;&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</code></pre>
<ul>
<li>现在开始进入最重要的函数部分了</li>
</ul>
<pre><code class="{bash}">//这个函数里获取model元是通过调用下面的方法，cls是获取本类而得到的Class类型
+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary {}
</code></pre>
<pre><code class="{bash}">[_YYModelMeta metaWithClass:cls]
&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;frontend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;&quot; data-labels_right=&quot;&quot; data-labels_copy=&quot;&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</code></pre>
<pre><code class="{bash}">+ (instancetype)metaWithClass:(Class)cls {
    if (!cls) return nil;
    static CFMutableDictionaryRef cache;
    static dispatch_once_t onceToken;
    //1..
    static dispatch_semaphore_t lock;
    dispatch_once(&amp;onceToken, ^{
        cache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
        lock = dispatch_semaphore_create(1);
    });
    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);
    _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls));
    dispatch_semaphore_signal(lock);
    if (!meta || meta-&gt;_classInfo.needUpdate) {
        meta = [[_YYModelMeta alloc] initWithClass:cls];
        if (meta) {
            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);
            CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta));
            dispatch_semaphore_signal(lock);
        }
    }
    return meta;
}
</code></pre>
<pre><code class="{bash}"> &lt;!-- //以信号量的方式保持同步，作用是为了从cache的内存中获取meta的数据是同步的。 --&gt;
 dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);
    _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls));
    dispatch_semaphore_signal(lock);
&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;frontend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;&quot; data-labels_right=&quot;&quot; data-labels_copy=&quot;&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</code></pre>
<pre><code class="{bash}"> &lt;!-- //或者在讲meta的值塞入内存中保持同步 --&gt;
         if (!meta || meta-&gt;_classInfo.needUpdate) {
        meta = [[_YYModelMeta alloc] initWithClass:cls];
        if (meta) {
            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);
            CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta));
            dispatch_semaphore_signal(lock);
        }
    }
</code></pre>
<pre><code class="{bash}"> &lt;!-- 其中创建meta的时候回调用 --&gt;
 meta = [[_YYModelMeta alloc] initWithClass:cls];

 - (instancetype)initWithClass:(Class)cls {
    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];
      .....  
  }
&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;frontend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;&quot; data-labels_right=&quot;&quot; data-labels_copy=&quot;&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</code></pre>
<pre><code class="{bash}"> &lt;!-- 这里涉及到YYClassInfo的实例化方法,通过runtime的一些方法，找到本类，父类，元类。 --&gt;
 - (instancetype)initWithClass:(Class)cls {
    if (!cls) return nil;
    self = [super init];
    _cls = cls;
    _superCls = class_getSuperclass(cls);
    _isMeta = class_isMetaClass(cls);
    if (!_isMeta) {
        _metaCls = objc_getMetaClass(class_getName(cls));
    }
    _name = NSStringFromClass(cls);
    [self _update];

    _superClassInfo = [self.class classInfoWithClass:_superCls];
    return self;
}
</code></pre>
<ul>
<li>然后在_update的方法中</li>
</ul>
<p></p><p class="code-caption" data-lang="{bash}" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code class="{bash}">&lt;!-- 这里讲model中的方法、属性，ivar以key-value的形式存放在字典中。本类调用完后会在父类中调用再调用一遍。 --&gt;
  Class cls = self.cls;
    unsigned int methodCount = 0;
    Method *methods = class_copyMethodList(cls, &amp;methodCount);
    if (methods) {
        NSMutableDictionary *methodInfos = [NSMutableDictionary new];
        _methodInfos = methodInfos;
        for (unsigned int i = 0; i &lt; methodCount; i++) {
            YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:methods[i]];
            if (info.name) methodInfos[info.name] = info;
        }
        free(methods);
    }
    unsigned int propertyCount = 0;
    objc_property_t *properties = class_copyPropertyList(cls, &amp;propertyCount);
    if (properties) {
        NSMutableDictionary *propertyInfos = [NSMutableDictionary new];
        _propertyInfos = propertyInfos;
        for (unsigned int i = 0; i &lt; propertyCount; i++) {
            YYClassPropertyInfo *info = [[YYClassPropertyInfo alloc] initWithProperty:properties[i]];
            if (info.name) propertyInfos[info.name] = info;
        }
        free(properties);
    }
....
</code></pre>
<hr>
<p></p><p class="code-caption" data-lang="{bash}" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code class="{bash}"> &lt;!-- * 最最关键的映射来了，YYModel把这个功能用一个递归函数来实现了。 --&gt;
 // create mapper
    NSMutableDictionary *mapper = [NSMutableDictionary new];
    NSMutableArray *keyPathPropertyMetas = [NSMutableArray new];
    NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new];

    if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) {
        NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper];
        [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) {
            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];
            if (!propertyMeta) return;
            [allPropertyMetas removeObjectForKey:propertyName];

            if ([mappedToKey isKindOfClass:[NSString class]]) {
                if (mappedToKey.length == 0) return;

                propertyMeta-&gt;_mappedToKey = mappedToKey;
                NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;];
                if (keyPath.count &gt; 1) {
                    propertyMeta-&gt;_mappedToKeyPath = keyPath;
                    [keyPathPropertyMetas addObject:propertyMeta];
                }
                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;
                mapper[mappedToKey] = propertyMeta;

            } else if ([mappedToKey isKindOfClass:[NSArray class]]) {

                NSMutableArray *mappedToKeyArray = [NSMutableArray new];
                for (NSString *oneKey in ((NSArray *)mappedToKey)) {
                    if (![oneKey isKindOfClass:[NSString class]]) continue;
                    if (oneKey.length == 0) continue;

                    NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;];
                    if (keyPath.count &gt; 1) {
                        [mappedToKeyArray addObject:keyPath];
                    } else {
                        [mappedToKeyArray addObject:oneKey];
                    }

                    if (!propertyMeta-&gt;_mappedToKey) {
                        propertyMeta-&gt;_mappedToKey = oneKey;
                        propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil;
                    }
                }
                if (!propertyMeta-&gt;_mappedToKey) return;

                propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray;
                [multiKeysPropertyMetas addObject:propertyMeta];

                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;
                mapper[mappedToKey] = propertyMeta;
            }
        }];
    }


    &lt;!-- * 源码中就可以看出，这个映射的函数，你需要复写modelCustomPropertyMapper 这个函数
    * 映射这个函数，你可以定义一个NSString的字符串，假如你得字符串中含有“.”这个的话，他就会将这个字符串以“.”分隔成NSArray,然后存入到_mappedToKeyPath 这个变量中。
    * 映射也可以是一个NSArray,这样就可以实现同一个model映射到不同的key上了。 --&gt;
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以YYModel的例子，它以类的方式调用&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p class=&quot;code-caption&quot; data-lang=&quot;{bash}&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;frontend&quot; data-l
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Obeject-c" scheme="http://yoursite.com/tags/Obeject-c/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="http://yoursite.com/2016/03/28/20160328/"/>
    <id>http://yoursite.com/2016/03/28/20160328/</id>
    <published>2016-03-28T06:28:12.000Z</published>
    <updated>2016-10-13T02:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近身边发生了太多太多事情，让我认识到了生命是多么的脆弱。满怀期望等待着一个什么的到来、可惜Ta却悄悄地离开了我们。我现在只想好好爱着我身边肉丝，一辈子都呵护在她身边，一直保护她，爱护她，不要让她收到一点点的伤害。 为了Rose、我了这个家、为了TA到来。我要好好鼓励工作，给你们最好的未来。</p>
<p></p><p class="code-caption" data-lang="{bash}" data-line_number="frontend" data-trim_indent="frontend" data-label_position="outer" data-labels_left="" data-labels_right="" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><p></p>
<pre><code class="{bash}">while(!isSuccess){
    func keepMoving()
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近身边发生了太多太多事情，让我认识到了生命是多么的脆弱。满怀期望等待着一个什么的到来、可惜Ta却悄悄地离开了我们。我现在只想好好爱着我身边肉丝，一辈子都呵护在她身边，一直保护她，爱护她，不要让她收到一点点的伤害。 为了Rose、我了这个家、为了TA到来。我要好好鼓励工作，
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="我" scheme="http://yoursite.com/tags/%E6%88%91/"/>
    
  </entry>
  
</feed>
